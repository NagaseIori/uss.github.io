[{"categories":["solution"],"content":" Problem 给定 $n$ ，求有多少个 $1\\to n$ 的排列可以分割成三个上升子序列。$n \\leq 500$。\nSolution 假设给定一个排列，那么我们贪心的从前往后选，维护三个上升序列，每扫到一个数字添加到能放的上升序列且保证原上升序列的最大值尽量大。这样一定能构造出一种合法方案（如果有）且分割方案唯一。\n考虑三个序列的最大值设计状态。由于不清楚插入的数具体是什么，我们令其为相对大小： $f_{i, j, k}$ ，且令 $i\u0026gt;j\u0026gt;k\\geq 0$ 。同时存在 $j=k=0$ 的情况。\n那么我们插入一个新的相对大小为 $l \\in [1, i+1]$ 的值。那么原相对大小处于 $[l, i]$ 区间的值都会被往后顶成 $[l+1, i+1]$ 。则我们分情况讨论 $l$ 的转移：\n$$ f_{i, j, k} \\rightarrow \\begin{cases} f_{i+1, j+1, l} \u0026amp; \\text{for } k\u0026lt;l\\leq j\\\\ f_{i+1, l, k} \u0026amp; \\text{for }j\u0026lt;l \\leq i\\\\ f_{i+1, j, k} \u0026amp; \\text{for }l=i+1 \\end{cases} $$\n差分即可优化到 $O(n^3)$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=501; int f[2][N][N], g[2][N][N]; int u, v=1; int n, P; int add(int \u0026amp;x, int y) { x+=y; if(x\u0026gt;=P) x-=P; return x; } int main() { freopen(\u0026quot;yuan.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;yuan.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); ios::sync_with_stdio(false), cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;P; f[v][0][0]=1; int ans=0; for(int i=1; i\u0026lt;=n; i++) { u^=1, v^=1; for(int j=0; j\u0026lt;i-1;j++) for(int k=0; k\u0026lt;=j; k++) f[v][j][k]=g[v][j][k]=0; for(int j=0; j\u0026lt;i-1; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j+1][k+1],f[u][j][k]), add(f[v][j+1][j+1],-f[u][j][k]), add(g[v][j+1][k],f[u][j][k]), add(g[v][i][k],-f[u][j][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j][k],f[v][j][k-1]), add(g[v][j][k],g[v][j-1][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) { add(f[v][j][k],add(g[v][j][k],f[u][j][k])); if(i==n) add(ans, f[v][j][k]); } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  ","oriTitle":"JZOJ2090 圆","tags":["递推"],"title":"JZOJ2090 圆","uri":"/posts/sol-jzoj-2090/"},{"categories":["others"],"content":"Sakura.\nSakura? 无精打采地趴在课桌上。\n温柔和清澈的，外界的蓝天。映在桌面上的，淡粉与蓝色交融的柔和的光。\n春天的风。令人舒适的，温暖的风。她有点享受地虚眯起眼睛。\n“为什么总是趴在桌子上啊？”\n不知什么时候走过来的女孩把双手撑在她的桌面上，盯着她。\n穿着一身白色搭配浅绿的春季校服，栗色的头发，活泼。右侧映照着粉色的光。\n趴在桌上的，一头黑色长发散落在桌面上的女生，稍稍抬头看了一眼，然后又无精打采地趴下。\n视线偏向窗外。\n“啊\u0026hellip;今天天气很好呢。” 站着的女孩自顾自的说道。“你想去看花？”\n“樱花呀~樱花~”\n“啊，是蓝天！还有很漂亮的云！”\n“啊——很舒服的风呢——”\n“呐——————为什么不理我？”\n抓狂的女孩使劲地揉着另一位女孩本来就已经很乱的头发。女孩的头随着她的手无规律地摇动，然后随着她的停下又静止下来。\n哐当哐当的桌子停止了回响。\n“——”\n鸟啾鸣的声音。\n栗色头发的女孩像是没办法似地长叹一口气，然后哐当地坐在了黑发女生后面的座位上。\n“——很安静呢。” 说了这一句话后，教室静止下来。\n沉默。\n黑发的女生稍稍撑起，然后扭头看了一眼后方。\n正闭着眼睛安静的趴在桌面上栗色头发的女孩。平缓的吐息。\n她重新转头趴下。\nSakura. 绿色的叶的响声，偶尔响起的鸟的啾鸣，和空荡荡的教室，桌面上熟睡的女孩。\n以及安静地流淌在女孩周围的，温柔的樱花的光。\n","oriTitle":"Sakura","tags":["NONE"],"title":"Sakura","uri":"/posts/sakura/"},{"categories":["others"],"content":"!\n她对我笑容满面。\n我轻松的跟她说着话。\n她笑得很开心。\n我觉得或许这样就够了。\n为什么装作听不见呢？我把我自己的真实所想给说了出来，她轻松的无视掉了。\n把嬉笑的我给留了下来。把开心的她留了下来。\n“她想要的并非你的真实。”\n我叹口气。\n“她害怕她想要的你消失。因此她无视。”\n“她想要的是你。”\n“不能是全部吗？”\n“这样的人不存在。”\n我苦恼。\n“不要以自我为中心。你喜欢你自己的地方别人不一定喜欢。你还想要别人喜欢你就顺着别人来。”\n啊啊，原来我是想要被喜欢的吗。\n那么做着被别人喜欢的人也是做着自己吧。\n这么一想好像就能说得通了。不要以自我为中心。因为别人不会喜欢。你就无法成为你自己想成为的人了。\n\u0026hellip;.？\n眼前所见的是自己想见的。因为很珍贵，害怕自己无法接受的事情，所以抛弃掉了么。\n眼前所见的是自己想见的。因为想被理解，却又不想抛弃自己所珍视的事物，所以抛弃掉了么。\n但是大家似乎都是这样的。\n我站在楼顶。\n风很大。\n晃晃悠悠。边缘。想像着，成为一片叶子飘落下去。\n支离破碎的语言。\n思考。\n不成逻辑的构建。\n无意义。\n纷繁多样的解读。\n被凭空创造的价值。\n以自我为中心的非现实。\n那是以自我为中心产生的价值。非现实的价值。虚无的价值啊。\n他人想要的，对他人产生价值。\n! 回过神来。周围的云在上升着。\n我忽然想从心底里提出几个问题。\n\u0026hellip;是什么呢？\n寻求他人的理解有多难呢？\n让他人理解是不是以自我为中心？\n理解是不是以非自我为中心为基础上创建？\n非自我中心是否能让他人理解自我？\n自我中心是什么？\n想让他人了解自己，从根本上来讲就是一种政治错误吗？\n还是说，这是不可能做到的事情。\n啊对了。\n这就是 Reality 所给予的 “错误” 啊。\n名为 “理解” 的原罪。\n尝试将自己无法理解的东西，按照一些普遍的规律，去纳入一类不想去理解的事物。\n在巨大的压力之下，大家都变得一样了。从不想被理解的事物变成了普通人。像普通人一样讨厌着不想去理解的事物。\n好无聊。\n这样的现实，真的好无聊。\n来到这样的非现实吧！\n失去引力的非现实。以自我为中心的幻想。\n去逃避现实吧。\n扭曲和故障的非现实。安定与永恒的乌托邦。\n去飞向云层吧。\n在破碎的现实之上的，向往着的那个浮岛。\n? “16岁的青少年从高楼坠落。”\n又一起青少年坠楼案件。不正常的事情愈发的多了起来。\n似乎这次是为了某个女孩。\n他喜欢她吗？\n还是说，因为其它的事情\u0026hellip;？摸不着头脑。\n“我们时常建议家长们多关注青少年的身心健康。” 站在桌旁的人看完了事件的概要，嘟哝这么一句就把文件丢在一旁。\n大概是常有的事情。\n","oriTitle":"Untitled","tags":["NONE"],"title":"Untitled","uri":"/posts/untitled/"},{"categories":["solution"],"content":"好题好做法\u0026hellip;\n感谢 gjx 的讲解。\nSolution 要用到的结论： $\\frac{1}{a}\\frac{1}{b}=(\\frac{1}{a}-\\frac{1}{b})\\frac{1}{b-a}$ 。\n我们要求的就是下面这个生成函数的第 $n$ 项： $$\\prod \\limits_{i=1}^{m} \\frac{1}{1-(ui+v)x}$$\n上面这个生成函数可以化为这样的形式： $$(\\frac{1}{ux})^{m-1} \\sum \\limits_{i=1}^m \\frac{a_i}{1-(ui-v)x}$$\n其中 $a_i$ 是该项的不定系数。\n至于为什么是这样，我们下面继续。\n令 $p_i=1-(ui+v)x$ 。我们从 $1\\to m$ 处理这个生成函数，即假设我们已经求出了 $1\\to m$ 的生成函数，然后我们要把这个函数乘上一个 $\\frac{1}{p_{m+1}}$ 来推出 $1\\to m+1$ 的生成函数。\n那我们考虑对于第二种形式的生成函数的每个 $i$ ，乘上这个之后的变化。\n即： $$\\frac{a_i}{p_i}\\frac{1}{p_{m+1}} = a_i(\\frac{1}{p_i}-\\frac{1}{p_{m+1}})\\frac{1}{u(i-m-1)x}$$\n此时我们发现对于每一项都会多乘上一个 $\\frac{1}{ux}$ ，因此我们可以将其整体提出，变成上面生成函数的形式。\n我们考虑第一次插入 $\\frac{1}{p_{i}}$ 这一项之后，令它的系数为 $f_i$ 。那么在插入 $i+1$ 项时，$f_i$ 会乘上一个 $\\frac{1}{ux(-1)}$ ，插入第 $i+2$ 项时会乘上一个 $\\frac{1}{ux(-2)}$ 。我们惊讶的发现有： $$a_i=(\\frac{1}{ux})^{m-i}(-1)^{m-i}\\frac{1}{(m-i)!}f_i$$\n再考虑 $f_{m+1}$ 的值： $$f_{m+1}=\\sum \\limits_{i=1}^{m} (-1)^{m-i}\\frac{1}{(m+1-i)!}f_i$$\n我们考虑 $f_i$ 的生成函数为 $F$ ，则有： $$F=F*(-e^{-x}+1)+x \\Rightarrow F=xe^x$$\n则我们可以得到最终生成函数的每一部分的第 $n$ 项的和： $$\\sum \\limits_{i=1}^{m} (ui+v)^{n+m-1} u^{-m+1} (-1)^{m-i} \\frac{1}{(m-i)!} f_i$$\n复杂度 $O(m\\log n)$ 。\nCode // Code by ajcxsu // Problem: IOer #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353ll) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10; typedef long long ll; ll finv[N], f[N]; ll qpow(ll x, ll y) { ll ret=1; while(y) { if(y\u0026amp;1) ret=ret*x%MOD; x=x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } ll n, m, u, v; ll pl[]={1, -1}; int solve() { int ans=0; ll invu=qpow(u, (MOD-2)*(m-1)); for(int i=1; i\u0026lt;=m; i++) ans=(ans+qpow((u*i+v)%MOD, n+m-1)*invu%MOD*f[i]%MOD*pl[(m-i)\u0026amp;1]*finv[m-i]%MOD+MOD)%MOD; return ans; } int main() { finv[0]=finv[1]=1; for(int i=2; i\u0026lt;N; i++) finv[i]=MOD-1ll*MOD/i*finv[MOD%i]%MOD; for(int i=2; i\u0026lt;N; i++) finv[i]=finv[i]*finv[i-1]%MOD; for(int i=0; i\u0026lt;N-1; i++) f[i+1]=finv[i]; int T; gn(T); while(T--) { gn(n), gn(m), gn(u), gn(v); printf(\u0026quot;%d\\n\u0026quot;, solve()); } return 0; } ","oriTitle":"JZOJ6080 IOer","tags":["数学","生成函数"],"title":"JZOJ6080 IOer","uri":"/posts/sol-jzoj-6080/"},{"categories":["solution"],"content":"⭐\nProblem 一个博弈游戏：给定一棵有根树，放一个石子在根节点，轮流执手，每次往任意叶子节点方向移一步，不能移则为输。\n现在给你 $n$ 个点，生成任意一棵有根树，问先手获胜的概率。有 $q$ 次询问。\n$n,q \\leq 10^5$\nSolution 令 $f(x), g(x)$ 分别为后手和先手必胜的 EGF ，则 $f(x)+g(x)=\\sum \\frac{(i-1)!}{i!}x^i$ 。所以有 $g(x)=-ln(1-x)-f(x)$ 。其中 $(i-1)!$ 为无标号有根树的方案数，$\\sum \\frac{(-1)^{i+1}}{i}x^i$ 为 $ln(x+1)$ 的麦克劳林级数。\n根据SG函数，因为后手必胜的子树皆为先手必胜，那么有 $xe^{g(x)}=f(x)$ 。解方程得 $f(x)=ln(1-ln(1-x))$ 。并不知道过程。\n所以可以得到最终的概率：$\\frac{(n-1)!-n!f_n}{(n-1)!}=1-nf_n$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; const int N=4e5+10; int f[N], g[N], h[N], r[N], n; void gen(int m) { int l=0; for(n=1; n\u0026lt;=m; n\u0026lt;\u0026lt;=1) l++; for(int i=1; i\u0026lt;n; i++) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); } int qpow(int x, int y) { assert(y\u0026gt;=0); int ret=1; while(y) { if(y\u0026amp;1) ret=1ll*ret*x%MOD; x=1ll*x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } void dft(int x[], int d) { for(int i=1; i\u0026lt;n; i++) if(r[i]\u0026gt;i) swap(x[i], x[r[i]]); int t, w, o; for(int i=1; i\u0026lt;n; i\u0026lt;\u0026lt;=1) { o=qpow(3, d*(MOD-1)/(i\u0026lt;\u0026lt;1)+MOD-1); for(int j=0; j\u0026lt;n; j+=(i\u0026lt;\u0026lt;1)) { w=1; for(int k=0; k\u0026lt;i; k++, w=1ll*w*o%MOD) t=1ll*x[i+j+k]*w%MOD, x[i+j+k]=(x[j+k]-t+MOD)%MOD, (x[j+k]+=t)%=MOD; } } } void mul(int x[], int y[], int z[], int m, int mode=0) { gen(m\u0026lt;\u0026lt;1); int a[N]={0}, b[N]={0}; copy(x, x+m, a), copy(y, y+m, b); dft(a, 1), dft(b, 1); for(int i=0; i\u0026lt;n; i++) if(!mode) a[i]=1ll*a[i]*b[i]%MOD; else a[i]=(2ll*b[i]-1ll*a[i]*b[i]%MOD*b[i]%MOD+MOD)%MOD; dft(a, -1); int inv=qpow(n, MOD-2); for(int i=0; i\u0026lt;m; i++) z[i]=1ll*a[i]*inv%MOD; } void inv(int a[], int f[], int deg) { assert(deg\u0026gt;0); if(deg==1) { f[0]=qpow(a[0]%MOD, MOD-2); return; } inv(a, f, (deg+1)\u0026gt;\u0026gt;1); mul(a, f, f, deg, 1); } void deri(int x[], int n) { for(int i=0; i\u0026lt;n; i++) x[i]=1ll*(i+1)*x[i+1]%MOD; x[n-1]=0; } void inte(int x[], int n) { for(int i=n-1; i\u0026gt;0; i--) x[i]=1ll*x[i-1]*qpow(i, MOD-2)%MOD; x[0]=0; } void pln(int x[], int y[], int n) { int a[N]={0}, b[N]={0}; copy(x, x+n, a); inv(a, b, n); deri(a, n); mul(a, b, a, n); inte(a, n); for(int i=0; i\u0026lt;n; i++) y[i]=a[i]; } int main() { ios::sync_with_stdio(false), cin.tie(0); int n=1e5+10; f[0]=1, f[1]=MOD-1; pln(f, g, n); for(int i=0; i\u0026lt;n; i++) g[i]=(MOD-g[i])%MOD; g[0]++; pln(g, h, n); int q; cin\u0026gt;\u0026gt;q; while(q--) { int na; cin\u0026gt;\u0026gt;na; cout\u0026lt;\u0026lt;(1-1ll*na*h[na]%MOD+MOD)%MOD\u0026lt;\u0026lt;'\\n'; } return 0; } ","oriTitle":"JZOJ6077 K君的游戏","tags":["数学","生成函数","多项式"],"title":"JZOJ6077 K君的游戏","uri":"/posts/sol-jzoj-6077/"},{"categories":["solution"],"content":"浪费了我一晚上的生命\u0026hellip;\nSolution 关于本题有两种做法，我一开始写的第一种：建立广义SAM，统计parent树上的endpos集合是否可以包含所有的字符串，如果可以就用len更新ans。可以状压。\n做法我拍了一下，大概是没问题的。但是这沙雕题卡常200ms我硬是给卡了一晚上😂然后发现一些神奇的问题。比如广义SAM是没法用基数排序来确定树上拓扑序的，所以得队列硬上，可惜不管怎么写都卡不过200ms。\n另一种做法就是神奇的转移：先建一个串，然后对于后加入的每个串计算一下状态匹配的最大值（可以通过后缀链接上传），然后再对于每个串取个最小值，最后总体取个最大值。这样的做法基本上是常数很小的 $O(n)$ ，或者是我常数制造机了\u0026hellip;\nCode - 80ms // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26]; int lst=1, idx=1; inline void add(int c) { int p=lst, np=lst=++idx; len[np]=len[p]+1; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int bu[N], id[N]; int su[N], f[N]; void solve() { int x=1, l=0; memset(su, 0, sizeof(su)); for(char *p=str; *p; p++) { if(ch[x][*p-'a']) l++, x=ch[x][*p-'a']; else { while(x \u0026amp;\u0026amp; !ch[x][*p-'a']) x=fa[x]; if(!x) l=0, x=1; else l=len[x]+1, x=ch[x][*p-'a']; } su[x]=max(su[x], l); } for(int i=idx; i\u0026gt;=1; i--) su[fa[id[i]]]=max(su[fa[id[i]]], su[id[i]]); for(int i=1; i\u0026lt;=idx; i++) len[i]=min(len[i], su[i]); } int main() { scanf(\u0026quot;%s\u0026quot;, str); for(char *p=str; *p; p++) add(*p-'a'); for(int i=1; i\u0026lt;=idx; i++) bu[len[i]]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[len[i]]--]=i; while(scanf(\u0026quot;%s\u0026quot;, str)==1) solve(); int ans=0; for(int i=1; i\u0026lt;=idx; i++) ans=max(ans, len[i]); printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  Code - TLE // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26], in[N]; int f[N], lst=1, idx=1; inline void add(int c, int val) { int p=lst, np=lst=++idx; len[np]=len[p]+1; f[np]=1\u0026lt;\u0026lt;val; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q], f[nq]=f[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int main() { int nidx=0; while(scanf(\u0026quot;%s\u0026quot;, str)==1) { lst=1; for(char *p=str; *p; p++) add(*p-'a', nidx); ++nidx; } nidx=(1\u0026lt;\u0026lt;nidx)-1; int ans=0, na, nf; for(int i=1; i\u0026lt;=idx; i++) in[fa[i]]++; for(int i=1; i\u0026lt;=idx; i++) if(!in[i]) qu[t++]=i; while(h!=t) { na=qu[h++], nf=fa[na]; if(f[na]==nidx \u0026amp;\u0026amp; len[na]\u0026gt;ans) ans=len[na]; f[nf]|=f[na], in[nf]--; if(!in[nf]) qu[t++]=nf; } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"SPOJ1812 LCS2","tags":["SAM"],"title":"SPOJ1812 LCS2","uri":"/posts/sol-spoj-1812/"},{"categories":["solution"],"content":"做法很巧妙。\nProblem 给你一棵树，和数条铁路的起点和终点，求有多少个火车会在路上相遇。\n每个火车的速度相同，起终点也算相遇，但经过终点后火车消失。\nSolution 首先如果在边上相遇一定是在中点，所以可以给每条边单独开一个点转化问题。\n然后将路径分为上行和下行，lca算在上行，求上下相交和上上相交即可。\n上上相交可以线段树合并，上下相交可以对每条重链分别处理，以重链的深度为 $x$ 轴，离起点的距离为 $y$ 轴，得到每条路径在每个重链的函数和值域，那么问题转化成求 $k=1/-1$ 的直线的交点数，可以直接离散到 $y$ 轴后扫描线求交点个数。\n注意上上相交的起点重合不要漏算。\nCode // Code by ajcxsu // Problem: correction #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(); x=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=2e5+10; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], fa[N], top[N], son[N], dep[N], dfn[N], len[N], idx; int bot[N]; void dfs1(int x, int k) { dep[x]=k, siz[x]=1; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { fa[to[u]]=x, dfs1(to[u], k+1), siz[x]+=siz[to[u]]; if(siz[son[x]]\u0026lt;siz[to[u]]) son[x]=to[u]; } } void dfs2(int x, int t) { top[x]=t, dfn[x]=++idx; len[t]++; if(son[x]) dfs2(son[x], t); else bot[t]=x; for(int u=h[x];u;u=nexp[u]) if(!dfn[to[u]]) dfs2(to[u], to[u]); } int lca(int s, int t, int mode=0) { while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); if(mode \u0026amp;\u0026amp; fa[top[s]]==t) return top[s]; s=fa[top[s]]; } if(mode) return dep[s]\u0026lt;dep[t]?son[s]:son[t]; return dep[s]\u0026lt;dep[t]?s:t; } struct Seg { int k, b, l, r; } ; vector\u0026lt;Seg\u0026gt; td[N]; struct Node *nil; struct Node { int v, t; Node *ls, *rs; Node () { v=t=0; ls=rs=nil; } } *nd[N], *nd2[N]; void ini() { nil=new Node(), nil-\u0026gt;ls=nil-\u0026gt;rs=nil, fill(nd, nd+N, nil), fill(nd2, nd2+N, nil); } ll updata(Node *\u0026amp;x, int l, int r, int d, int v) { if(x==nil) x=new Node(); x-\u0026gt;v+=v; int mid=(l+r)\u0026gt;\u0026gt;1; if(l==r) { x-\u0026gt;t=l; return x-\u0026gt;v-v; } if(d\u0026lt;=mid) return updata(x-\u0026gt;ls, l, mid, d, v); else return updata(x-\u0026gt;rs, mid+1, r, d, v); } void Merge(Node *\u0026amp;x, Node *a, Node *b, ll \u0026amp;cnt, int mode=0) { if(a==nil) { x=b; return; } if(b==nil) { x=a; return; } if(x==nil) x=new Node(); if(!mode \u0026amp;\u0026amp; a-\u0026gt;t) cnt+=1ll*a-\u0026gt;v*b-\u0026gt;v; x-\u0026gt;v=a-\u0026gt;v+b-\u0026gt;v; Merge(x-\u0026gt;ls, a-\u0026gt;ls, b-\u0026gt;ls, cnt, mode); Merge(x-\u0026gt;rs, a-\u0026gt;rs, b-\u0026gt;rs, cnt, mode); delete b; } int n; void modify(int x, int k, int l, int r, int ry) { int b=ry-(r-dep[x])*k; td[x].push_back({k, b, l-dep[x], r-dep[x]}); } void modifyup(int s, int t, ll \u0026amp;ans) { if(dep[s]\u0026lt;dep[t]) swap(s, t); /* ↑ */ ans+=updata(nd[s], 1, n, dep[s], 1); updata(nd2[t], 1, n, dep[s], -1); int bg=dep[s]; /* ↓ */ while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], -1, dep[top[s]], dep[s], bg-dep[s]); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], -1, dep[s], dep[t], bg-dep[t]); } void modifydown(int s, int t, int rua) { int bg=min(dep[s], dep[t]); while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], 1, dep[top[s]], dep[s], dep[s]-bg+rua); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], 1, dep[s], dep[t], dep[t]-bg+rua); } void dfs(int x, ll \u0026amp;cnt) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa[x]) { dfs(to[u], cnt); Merge(nd[x], nd[x], nd[to[u]], cnt); } Merge(nd[x], nd[x], nd2[x], cnt, 1); } #define lowbit(x) x\u0026amp;-x namespace BIT { const int V=N\u0026lt;\u0026lt;2; int C[V], stk[V][2], t; void updata(int x, int v, int mode=0) { if(!mode) stk[++t][0]=x, stk[t][1]=v; while(x\u0026lt;V) C[x]+=v, x+=lowbit(x); } int query(int x) { int ret=0; while(x) ret+=C[x], x-=lowbit(x); return ret; } void clr() { while(t) updata(stk[t][0], -stk[t][1], 1), t--; } } struct Query { int t, v, x, l, r; } ; Query tmp[N\u0026lt;\u0026lt;1]; int t; bool cmp(const Query \u0026amp;a, const Query \u0026amp;b) { return a.x==b.x?a.t\u0026lt;b.t:a.x\u0026lt;b.x; } ll count(int x) { t=0; for(Seg y:td[x]) if(y.k==1) { tmp[++t]={0, 1, 2*y.l+y.b, y.b+(N\u0026lt;\u0026lt;1)}; tmp[++t]={2, -1, 2*y.r+y.b, y.b+(N\u0026lt;\u0026lt;1)}; } else { tmp[++t]={1, 0, y.b, y.b-2*y.l+(N\u0026lt;\u0026lt;1), y.b-2*y.r+(N\u0026lt;\u0026lt;1)}; } sort(tmp+1, tmp+1+t, cmp); ll ret=0; BIT::clr(); for(int i=1; i\u0026lt;=t; i++) if(tmp[i].t==1) ret+=BIT::query(tmp[i].l)-BIT::query(tmp[i].r-1); else BIT::updata(tmp[i].l, tmp[i].v); return ret; } int main() { int u, v; gn(n); for(int i=1; i\u0026lt;n; i++) { gn(u, v); ins(u, i+n), ins(i+n, u); ins(v, i+n), ins(i+n, v); } ini(); dfs1(1, 1), dfs2(1, 1); ll ans=0; int m; gn(m); for(int i=1; i\u0026lt;=m; i++) { gn(u, v); int l=lca(u, v); if(l==v) modifyup(u, v, ans); else { int l2=lca(l, v, 1); modifyup(u, l, ans); modifydown(v, l2, dep[u]-dep[l]+1); } } dfs(1, ans); for(int i=1; i\u0026lt;=2*n-1; i++) if(top[i]==i) ans+=count(i); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } ","oriTitle":"Railway","tags":["树链剖分","扫描线"],"title":"Railway","uri":"/posts/sol-jzoj-6074/"},{"categories":["solution"],"content":"有点难\u0026hellip;\nSolution 网上已经讲得很详细了吧？\n补充几个问题。一是可以直接 $f_{R}=\\sum \\limits_{j=L-1}^R f_j$ 进行转移。但是得注意先转移大区间再转移小区间（这属于被部分包含），否则的话你可能会丢失不选小区间的决策。\n第二个问题是若速度可以相等，那么需要将开始的排序进行一些小修改。考虑 $X_i$ 的左端比它大的最小的 $j$ ，若有数个 $V_k$ 等于 $V_j$ ，那么这些 $V_k$ 的点是肯定不能被染色的。右侧同理。\nCode // Code by ajcxsu #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (1000000007) using namespace std; const int N=5e5+10; int h[N], l[N], r[N]; vector\u0026lt;int\u0026gt; L[N]; int x[N], v[N], a[N]; bool cmp(const int \u0026amp;a, const int \u0026amp;b) { return v[a]\u0026lt;v[b] || (v[a]==v[b] \u0026amp;\u0026amp; x[a]\u0026lt;x[b]); } int f[N], S[N]; int main() { ios::sync_with_stdio(false), cin.tie(0); int n, m; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;v[i], a[i]=i; sort(a+1, a+1+n, cmp); int stk[N], p[N], t=0; for(int i=1; i\u0026lt;=n; i++) { if(!t || stk[t]\u0026lt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026lt;x[a[i]]) l=mid+1; else r=mid; } ::l[i]=p[r]; } t=0; for(int i=n; i\u0026gt;=1; i--) { if(!t || stk[t]\u0026gt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026gt;x[a[i]]) l=mid+1; else r=mid; } ::r[i]=p[r]; } for(int i=1; i\u0026lt;=n; i++) L[r[i]].push_back(l[i]); f[0]=S[0]=1; for(int i=1; i\u0026lt;=n; i++) { S[i]=S[i-1]; sort(L[i].begin(), L[i].end()); for(int j:L[i]) { f[i]=(1ll*f[i]+S[i]-(j-2\u0026gt;=0?S[j-2]:0)+MOD)%MOD; S[i]=(f[i]+S[i-1])%MOD; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC015E Mr.Aoki Incubator","tags":["单调栈","DP","二分"],"title":"AGC015E Mr.Aoki Incubator","uri":"/posts/sol-agc-015-e/"},{"categories":["solution"],"content":"有点神的构造，考场上想复杂了\u0026hellip;\nSolution 考虑因为变换 $2^n-1$ 次，那么 $A$ 跟 $B$ 的 $1$ 位数的奇偶性一定不同，用这个来判断是否有解。\n通过归纳可以知道如果不同是一定有解的。\n假设存在 $n=k$ 的构造方案，考虑如何构造 $k+1$ 位的构造方案。我们可以将 $A$ 和 $B$ 不同的一位（假设是第 $x$ 位）提取出来，剩下 $k$ 位数 $A\u0026rsquo;$ 和 $B\u0026rsquo;$ 。他们的位数奇偶性一定相同。那么我们再考虑一个一位与 $A\u0026rsquo;$ 不同的数 $c$ 。递归去构造一个 $A\u0026rsquo;\\rightarrow c \\rightarrow B\u0026rsquo;$ 的方案。其中前半部分的第 $x$ 位与 $A$ 相同，后半部分与 $B$ 相同。\n递归构造即可。\nCode // Code by ajcxsu // Problem: C #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef bitset\u0026lt;10\u0026gt; bs; void solve(int k, int a, int b, vector\u0026lt;int\u0026gt; \u0026amp;op) { if(k==1) { op.push_back(a), op.push_back(b); return; } int c=0; vector\u0026lt;int\u0026gt; L, R; for(; ((1\u0026lt;\u0026lt;c)\u0026amp;a)==((1\u0026lt;\u0026lt;c)\u0026amp;b); c++); int na=(a\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((a\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); int nb=(b\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((b\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); solve(k-1, na, na^1, L); solve(k-1, na^1, nb, R); for(int x:L) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;a)); for(int x:R) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;b)); } int main() { ios::sync_with_stdio(false), cin.tie(0); int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!((__builtin_popcount(a)+__builtin_popcount(b))\u0026amp;1)) cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;, exit(0); vector\u0026lt;int\u0026gt; ans; solve(n, a, b, ans); cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; for(int x:ans) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;' '; cout\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC032C Differ by 1 bit","tags":["构造"],"title":"AGC032C Differ by 1 bit","uri":"/posts/sol-agc-032-c/"},{"categories":["others"],"content":"自用。\n不提供推荐。\n不提供P站ID。\n意见主观。\n不专业。\n不可爱的画师不会记载。\n画很多男孩子的画师也不会记载。\n也许会长期更新。\n也会有绘师 H 内容的介绍。不包含 H 预览图。\n不涉及 R-18G 内容。\n如果有错误欢迎指正。\n香川悠作 百合绘师？\n笔下的女孩子都很有活力而且很可爱，互动夸张且有趣。\n背景的光影非常自然，有种夏日感。\n生动描绘美好、安定而不定的日常感。\nNon-H 画师。\nﾌﾞﾚｴﾄﾞ 色调有很明显的个人风格，偏粉。画风也容易识别。\n笔下可爱、贫乳、娇小的女孩子很多。画得女孩子都特别特别可爱。一种在幼与帅气之间徘徊的可爱感(?)。\n超级可爱。超级超级可爱。尤其是很喜欢这种细腻偏暖的色调。\n画H的内容不少，不过质量也很高，仍然特别特别可爱。\n里个人存档处 国人绘师。\n感觉更偏艺术而非日本插画风格。宏大的场景，丰富的想象，擅长描绘奇妙的景象和精细而壮观的背景，偏科幻。\n笔下的女孩子也描绘的很细腻，华丽，可爱，很好看。\n每幅画的具体风格都很不一样且鲜明。\n画H的内容不少，喜欢以 Miku 的调教为主题，含有机械和 rbq 元素较多，稍重口，也很科幻。\nひみつ Himitsu 国人绘师。\n对捆绑题材非常执着。上色非常细腻（包括光影、水、肌肤和白丝），被捆绑的女孩子形态和表情都非常可爱，画作受到广泛欢迎。是我很喜欢的画师。\n画作主题包含碧蓝航线、Fate等。\n由于题材的特殊性，画作内容不可避免地大部分为H相关。同时也作为本子绘师活跃着。\n在国内有 weibo 和 bilibili 账号，经常在b站直播绘画。\n幻想绘风 国人绘师。\n早、中期以绘画风景和女孩子（东方）为主。在绘画天空和云朵上，色彩的运用非常惊艳。绘画的风景图都非常美丽，色彩鲜艳，常使用厚涂风格。每年都会画“最後の夕焼け”为主题的画作。\n后期以绘画女孩子（非东方、铁路拟人）和风景为主。色调偏暖、灰，特色鲜明。\n是我最喜欢的画师之一。也是我曾经梦想过成为的“又会画风景又会画可爱的女孩子，尤其是云朵和天空画得特别好看”的画师。\nNon-H 画师。\nGYARI VOCALOID Producer，周刊变长元凶，万恶之源P，前期jazz和长曲、小剧场p主，后期鬼畜曲p主（悲）。喜欢用VOICEROID。\n你们都应该去听一听 GYARI 写的歌，甚至还能同时做作业.jpg\n在 pixiv 上有账号，绘画力也越来越高了（赞赏）。\n在 Youtube 上也很受欢迎的P主。\nLpip 韩国绘师。\n笔触轻柔，有种薄纱覆盖的透明感，画作和笔下的女孩子都有很鲜明的特色，常有水雾般的朦胧和温柔感。是pixiv很受欢迎的画师之一，常屠榜。\n笔下常绘 VOCALOID 和 Miku 相关，以绘画美丽的女孩子为主。\nNon-H 画师。\nlitsvn 国人画师。\n笔下的女孩子画风极具特色，活力的kawaii感。识别度很高。色调风格与ﾌﾞﾚｴﾄﾞ相近，但是上色相对更加鲜艳。眼睛的颜色非常迷人。\n给bilibili world提供过一次banner，某次上b站首页看到的，画风非常相近？\n偶尔画H相关，其中偶尔触手相关，这几张的女孩子都很可爱。\n似乎巨乳角色也不少。\nアータ H画师。\n画H的部分都很可爱的一个画师。\n看上去画功并非顶尖，但是H表情的描摹和可爱程度已经达到了优秀的级别。因此在这里推荐一下。\nさわやか鮫肌 这是我想重点推荐的画师！\n画得超超超超可爱！\n画师的绝大部分作品都是 R-18 向。前期同人志和插画以东方为主，你甚至可以在 THB-Wiki 上找到画师的条目。在 Comic Market 上有稳定的活动（同人志贩卖），虽然对时间间隔并没有清晰的了解。\n后期的主题基本上是 VOICEROID 和东方，其中 結月ゆかり 的出镜率非常高（无论是插画或者同人志）。\n同时早期是以 Dr.VERMILION 名义来发表同人志的。\n关于画师的同人志，最显著的一个特点就是台词很少（基本没有），使用画面和肢体语言来表示剧情，文字以拟声词为主。\n画师的插画的配色仍然是很令人舒适的温暖风格，色彩平滑的过渡中包含有分量的体积感。其中绝大部分插画质量都相当的高，女孩子们非常的自然而且可爱，H也画得相当的讲究，着力体现出女孩子们的超绝复杂的可爱心理和表现。简单来说就是好用的可爱。\n有时也会绘画 VOICEROID 女孩子们的生草日常。\n虽然我很想截一些 H 的可爱女孩子们用来预览，但是我想 Github Page 应该是不会允许这种行为的（悲）。\nddal 才发现的一位很厉害的韩国画师。\n感觉很多韩国画师画功都很好啊。\n这位好像更加喜欢描写JK一点。\n","oriTitle":"Favorite Pixiv Artists","tags":["Pixiv","VOCALOID"],"title":"Favorite Pixiv Artists","uri":"/posts/favorite-pixiv-artists/"},{"categories":["solution"],"content":"弄了一晚上，几篇博客交换看才看懂。\n可能也是因为分心了的缘故。\nSolution 将整棵树分为 $k+1$ 个联通块，对每个联通块找直径，然后直径端点连成一条链一定是最优解。\n考虑转化问题，求树上 $k+1$ 条不相交链的最大权和。\n设计状态。考虑一个点的度数只可能为 $0/1/2$ 。令 $f_{i, j, k}$ 为第 $i$ 个点，度数为 $j$ ，用了 $k$ 条链的子树最优解。\n再具体阐述状态。$f_{i, 0}$ 代表这个点度数为 $0$ ，即在最终的方案中它并不属于直径，因此不占用任何链的个数也不提供任何贡献。 $f_{i, 1}$ 的状态正常。 $f_{i, 2}$ 代表这个点的度数为 $2$ 。那么如果我们想要一个单点成为直径中的一条链，我们就假设是 $i$ 向自己连了自环，度数为 $2$ 且占用了一条链的数目。\n那么初始化也就呼之欲出了：$f_{i, 0, 0}=f_{i, 2, 1}=0$ ，其余置为 $-\\infty$ 。\n转移不难。\n通过观察（打表）发现对于使用链数为 $k$ 的最优解呈凸函数，使用 凸优化dp 来去除 $k$ 的限制。\n注意我们是对每条链产生的贡献减去斜率而不是对每条边。\n那么初始的dp去除第三维来做就行了。\n但是凸函数可能会出现你要找的点和前后两点处于同一直线。那么此时应当二分到该直线的斜率，并使用斜率和 $k$ 来直接求出 $k$ 的最优值。\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 林克卡特树","tags":["凸优化DP"],"title":"LP4383 林克卡特树","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"一道不错相对简单的题目。\nSolution 很大胆的想法。考虑以子树dp，然后一条链大力拉下来枚举链底部求贡献。\n那么对于每棵子树求最优的链底。\n用线段树维护。考虑点上移，链底贡献的变化量。\n重链贡献中有 $\\log$ 的存在，但我们发现每个链底及其每棵子树对重链贡献的变化次数不会超过 $\\log$ 次，因此复杂度是 $O(n\\log^2 n)$ 的。\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 新年的小黄鸭","tags":["线段树","树形dp"],"title":"UOJ462 新年的小黄鸭","uri":"/posts/sol-uoj-462/"},{"categories":["others"],"content":"$\\text{Hello world!}$ Here. 如果你找到这里了\u0026hellip;\n让我猜猜？\n你是看了我的github还是查了我的子域名？\nNext. 那么这里就是Inside Space。\n平常可能会在这里记录一些OI以外的内容。\n包括游戏、音乐、动画、漫画、小说、开发。\n而以上所提到的，我也在努力的进修中。\n关于Hugo和Canoe的这个主题，是受到了 margatroid 的影响。因为觉得这个很好看。所以也顺势弄了个Github Page，成就了我一向想要做里站的愿望。虽然是里站，但是还是不能放一些不可描述的H的东西呢（笑）\n以上。\nSomething left. 由于一些不可描述的技术原因，中文搜索功能暂不能使用。\n","oriTitle":"Inside Space","tags":["none"],"title":"Inside Space","uri":"/posts/my-first-post/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"没有什么好说的。\n有人可能已经注意到了我的头像。\n主页的一个，或许还有gravatar的那一个。\n使用这两个头像的原因是因为我认为这些表情太可爱了x\n原图的话可能只有经常在p站翻奇怪东西的人才能找出来吧？\n博客标题并不是指某飞机型号\n没什么好说的是因为自己积累不够啦\u0026hellip;\u0026hellip;\n很多都看，很多都做，但是很少有做好做精（不如说几乎没有）。\n毫无交际力，比较没有自信， 幻想空气系少女 （自称desu）\n但是如果你说我做过些什么的话，我确实可以说一说。嘛反正大概这里是不会有人来的吧。\n一开始建站的时候有很多人来，我想大概是因为 github page 刚建好的时候有什么人想进来收录一下之类的。现在安静下来了。\n早期玩MC。现在一直在玩的只有MUG。主Deemo/Dynamix，偶尔玩一下Cytus2/OSU。\nsteamID大概也是ajcxsu\u0026hellip; 喜欢玩有趣，拥有令人耳目一新的创新和挑战的独立游戏。个人很喜欢Davey Wreden的作品，因为他的两个作品都在颠覆。同时很喜欢解密游戏，比如Playdead的INSIDE和LIMBO，以及比较著名的FEZ、The Witness（强推）和Antichamber。然后还玩了Steam上一些零散的独立游戏\u0026hellip; 但是总的来说还是个新人啦ww\n之后有想要做独立游戏制作者的愿望。想做一个超厉害的，Super Meta Game！\n觉得那种经典的收集物品然后解开东西的解密游戏有点无聊。因为看不到什么新东西ww\n关于ACGN一块，零零散散的也会看一些吧。像游戏一样，如果没有什么新的有趣的东西大概率是不会去看的ww。\n音乐以 VOCALOID 为主，VOCALOID 中以 Hatsune Miku 的歌为主。有的是对P主和歌曲的爱ww\n当然 Miku kawaiiii\nMiku 传达出的许多美好而珍贵的旋律和声音是我觉得 Miku 最可爱的地方。\n纯音的话杂食系，好听就会听。至于我什么喜欢类型的歌曲我实在是没研究\u0026hellip; 网易云ID也是ajcxsu qvq有兴趣的话可以去翻翻我的歌单？\n","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]