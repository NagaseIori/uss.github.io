[{"categories":["others"],"content":"心血来潮突然想整这么一下来探索一下随机几个关键词跳转网站都会跳转到哪些地方。\n由于 .moe 域名的特殊性，命中率的确不算低。\n下面以表格形式呈现我随机到的一些域名和网站的内容吧。只要能访问的我都会放上来。\n警告：部分网站含 NSFW 内容（包括血腥/色情/暴力等R18/R18G要素），部分网站可能被墙，请谨慎访问\n 目前统计：46个可访问网站。\n    域名 网站标题 网站内容     rin.moe rin 的小窝 是博客   ecchi.moe  牙白的东西 (anime)(NSFW)   setsuna.moe Setsuna\u0026rsquo;s 是博客   miku.moe 初音ミクライブ関連オフ会企画コミュニティサイト    clock.moe clock.moe 有多种口味可选择的在线钟表网站（还有成就）？   bilibili.moe Index of / 似乎是活的服务器欸   sakura.moe  个人网站\u0026hellip; 现在的年轻人都好强啊？   akuma.moe abandon all hope 牙白的东西 (doujinshi)(NSFW)   vtuber.moe Natsumi Moe 跳转到 https://www.youtube.com/user/TheOtakuMoe (www)   aqua.moe Aqua Aria 是博客   rinko.moe 「ラブプラス EVERY」 公式サイト KONAMI 某手游官网？   gfw.moe hello world hello world   despair.moe [ かわいいのルート ] 画的很好的外国画师的个人站点   akarin.moe 阿卡林服务器 是博客   pixiv.moe pixiv ギャラリー pixiv 的代理站点，国内无法访问 1   sensei.moe sensei.moe 意义不明？   lucy.moe asagi.moe 跳转到 https://asagi.moe/ ，是位德国朋友的博客   umi.moe Noirsumi NAS 人家的 NAS\u0026hellip; 好像打扰到了 ww   akame.moe Akame 是博客   mikumiku.moe MIKUMIKU.MOE miku 的简笔画头像   era.moe Moe Era 西方友人开发的 gal 游戏的官网，steam 有售，画风像 DDLC？   waifu.moe Waifu! Aigis 的粉丝站点   kumo.moe 云萌网络 跳转到 https://www.cloudmoe.com/   yuki.moe Yukino\u0026rsquo;s Dev Blog 外国开发者的博客 2   osu.moe 此网站已被续 真正的粉丝站 (NSFW)   mea.moe 幸せはしにがみさんがあいをわたしにせかすこと 梅娅·S·艾菲梅拉尔的粉丝站点   kaguya.moe Kaguya.moe and Mokou.moe 辉夜姬与妹红的粉丝站（似乎未建成）   oier.moe ciwomuli 是博客呢   kira.moe Sotr\u0026rsquo;s blog 是博客   rua.moe RUA! 是博客   watashi.moe  watashi 的粉丝站点 3   chtholly.moe 中国珂学院 珂朵莉的粉丝站点   fly.moe Fly の 宅基地 是博客   mizu.moe  ICE 介入？   boku.moe Yooooooo! 屑油管移除了经典名作（恼）   kaguramea.moe  Kagura Mea 的粉丝站点   hub.moe  个人站点，站长也会画画   nika.moe We \u0026lt;3 Nika 疑似个人站点   ddlc.moe Doki Doki Literature Club! 原来就是DDLC官网啊   dot.moe 猫の国 杂图站   kiana.moe  韩国友人的博客   cow.moe 魯牛窩 个人站点   steam.moe  七日杀的游戏服务器？   suicide.moe  疑似奇怪乐队的主页   fufufu.moe /a/ - anime/random 动漫综合版的匿名论坛 (NSFW)   speed.moe YAIH 普通的图床     但 源码 似乎开放 w [return] 根目录是 apache 的默认界面，但发现这个网站是上了 Let\u0026rsquo;s Encrypt 的，随手往域名后面加了个 /blog 居然进去了 w [return] 出自动画 人类衰退之后 [return]  ","oriTitle":".moe 网站随机跳转探索实录","tags":["日常"],"title":".moe 网站随机跳转探索实录","uri":"/posts/moe-website/"},{"categories":["GUIDE"],"content":"技术性探讨。\n安装 能找到的最方便的方法是使用以下指令从官方安装（会自动编译安装所有依赖包，并同时安装 simple-obfs plugin）：\nmkdir ./build-area cd build-area wget https://github.com/shadowsocks/shadowsocks-libev/raw/master/scripts/build_deb.sh chmod +x build_deb.sh ./build_deb.sh all  配置 文件位于 /etc/shadowsocks-libev/config.json 。\n{ \u0026quot;server\u0026quot;:\u0026quot;example.com or X.X.X.X\u0026quot;, // 这一行可以不填 \u0026quot;server_port\u0026quot;:443, // 或 8443 \u0026quot;password\u0026quot;:\u0026quot;password\u0026quot;, \u0026quot;method\u0026quot;:\u0026quot;aes-128-gcm\u0026quot;, // 或 aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 \u0026quot;timeout\u0026quot;:60, // 适当更改 \u0026quot;plugin\u0026quot;:\u0026quot;/usr/bin/obfs-server\u0026quot;, \u0026quot;plugin_opts\u0026quot;:\u0026quot;obfs=tls;failover=\u0026lt;域名或 IP\u0026gt;\u0026quot; // failover 在非正常请求下会跳转到你设置的域名/IP }  客户端请下载 obfs-local 并将文件置于客户端根目录下，填写参数如下：\n   选项 参数     插件程序 obfs-local.exe   插件选项 obfs=tls;obfs-host=\u0026lt;域名或 IP\u0026gt;    你请求的网址会被伪装成所设置的域名。\n防火墙 执行如下指令：\nufw default allow outgoing ufw default deny incoming ufw allow 22 # 如果你更改了 SSH 端口，这里就填对应的 SSH 端口 ufw allow 443 ufw enable  补充可能会出现的意外情形： 重启之后，443(8443) 端口被封闭，需要使用ufw reload才会打开。查看 ufw 的 log 发现 ufw 的确 BLOCK 了对应端口的连接，但是ufw status查看显示一切正常。我也很奇怪。同时我也发现了 ufw deny 80 端口这条指令并不管用，各种探测方法都显示 80 端口打开，我也很奇怪。\n查了很多教程，直接解决的方法并不管用。一种曲线救国的方式是在 /etc/rc.local 加入一行 /etc/init.d/ufw restart ，你就不用每次重启都要输入 ufw reload 了。\n自动重启 键入命令：crontab -e，随便选择一种编辑器（ nano 就好），然后在最下加入一行：\n0 4 * * * /sbin/reboot\n在每天凌晨四点主机便会重启。\nnano 的保存方式是 Ctrl+O + Enter 后 Ctrl+X 即可。\n引用 https://cokebar.info/archives/767\nhttps://linux.cn/article-8087-1.html\nhttps://stackoverflow.com/questions/41319291/ufw-blocks-most-ports-until-disabled-and-re-enabled-after-reboot\nhttps://www.linuxquestions.org/questions/linux-networking-3/need-to-reload-ufw-after-each-restart-to-apply-rules-4175629240/\n","oriTitle":"ubuntu 18.04 ss-libev 部署踩坑","tags":["NONE"],"title":"ubuntu 18.04 ss-libev 部署踩坑","uri":"/posts/ss-libev/"},{"categories":["others"],"content":"连着把三篇剧场版看完了。粗浅地谈谈感想。\n那么先说说本篇。\n本篇前期着重描写四人：焰，小圆，杏子，沙耶香。其中个人认为表现的最好，最有魅力的也就是杏子。杏子的故事，从单纯到受伤后不再为他人使用膜法，再到发现魔法少女的真相，清楚的认识到“同伴”这一存在而转变对沙耶香的态度，以至于最后为沙耶香冒险而牺牲自我。从头到尾，杏子的心中其实都一直怀有一种理想的愿望，而这种愿望是纯粹的。\n后期着重描写焰和小圆的轮回和真相。这一部分着重体现出了前期的伏笔和象征隐喻，大量回收伏笔和轮回的展开，以及一些实验性的表达都非常过瘾。在这一部分，小圆乐观而果断的人格魅力体现的无以复加，没有一般塑造的圣母的那种扭扭捏捏，瞻前顾后，说救就去救，分得清，放得下，无数次的轮回中都做得无比正确，且有很大的成长，有决心有毅力有魄力，圆神称号名副其实。\n全篇是如何描写焰呢？从柔弱的女孩子再到初次的团灭，无意间许下的美好愿望开启了无尽的轮回。在一次次轮回中逐渐变得坚强，理性，外表变得冷漠，而逐渐从软弱的圆厨成长为扭曲的圆厨，开始走向一个自我承担一切的极端。但最终小圆还是拯救了焰，小圆重新从焰手中拿回一切，选择自我承担，而焰对此怅然若失——她似乎并不想要圆神当神来着。\n她为什么想要自己承担一切？因为她不想让小圆成为魔法少女，她想让小圆过上一个普通人的生活。\n而她自己的实际的内心想法是什么？或许是想和小圆永远在一起，普普通通地作着魔法少女的工作，简简单单的把生活过下去。\n她能做到吗？她做不到。她是魔法少女，而为了避免小圆的悲剧，她不能让小圆成为魔法少女。魔法少女就是魔女，作为魔女的她是无法实现这个愿望的。因此她的一开始的执念就是奉献自己，她从许下愿的一开始便没有退路可走，她便是一个彻头彻尾的悲剧角色。\n那是为了拯救一个人所自己种下的最深的绝望。因此新篇里说这是“爱”，的确是无可非议。\n再来说说新篇。\n新篇即焰个人篇。全篇以焰为中心展开，焰的梦境，焰的执念，焰的选择。\n梦境体现出了焰的理想。她真正想要的是什么？是想和圆神永远在一起。是魔法少女不再有绝望，不再有伤害的世界。在焰和圆神的对话中，圆神一番话使焰清醒地认识到了自己的欲望。我想让你当神吗？我想让你牺牲自我吗？不想。我只是想让你简简单单过上愉快的生活，不再与这些残酷的东西有任何纠葛，不再承担任何事物，可以的话，想和你永远待在一起，不论是以什么样的形式。于是这种欲望终于使天下第一圆厨进化成了扭曲的终极形式——魔女的力量是有极限的，于是焰选择不做魔女。\n焰的执念，焰的悲哀，焰的绝望在最后面对小圆的选择时体现的淋漓尽致，她夺取圆环之理，将小圆的人格剥离，构造新的宇宙，并将QB丢到宇宙里承载诅咒，强行构建出了所谓的“天堂”。这即是焰的欲望，焰的恨意。焰从来都不是圣母，焰的所作所为不求任何人的理解，即使是小圆。即在最后的最后，焰终于从一个三无萌妹变成了一个为爱所困的疯子，将一切的一切都献给“天下第一圆厨”的标签，实为可贵，实为可敬。\n其中不得不说说我觉得最迷的部分。\n小圆下凡。“焰我来接你了” 我寻思你怎么不早些来接焰，你懂个锤子焰？\n焰之悲哀在此刻达到巅峰。\n总而言之小圆三篇看下来，最出彩的是其丰富的实验性质的表达方式，以及一种我能感受到的类故障美感。还有出色的音乐搭配，精彩的演出，优秀的打斗制作和可以看出来想要多度回转的一波三折的剧情。\n令我稍微感到有些无力的则是两个篇章的结尾。\n令我稍微感到尴尬的是第一次看到新篇的变身部分，但实际上这种想要渲染魔法少女的美好与后面更是形成了一种讽刺性的反差，充满了导演的恶意，所以实际上做的也不错。而且变身部分本身的布局和想法也都是相当有意思的。\n令我深感喜欢的角色是杏子。\n令我敬佩得五体投地的角色无疑是晓美焰。\n令我非常心疼的角色则是焰和小圆。\n虽然只是粗浅的一刷，但是小圆的制作优秀，加上其实验性质的演出和可以多加推敲的细节和剧情，作品本身可以算是相当优秀，属于非常值得一看的一列。\n之后有待多刷。\n","oriTitle":"魔法少女まどか☆マギカ","tags":["Anime"],"title":"魔法少女まどか☆マギカ","uri":"/posts/madoka-magica/"},{"categories":["solution"],"content":"喵。\nProblem 给出一张被划分出多个区域的平面图。区域染不同颜色会有不同的权值，如果相邻两区域颜色不同会产生额外费用。求最大贡献。\nSolution 前置知识比较多？\n极角排序和最左转线。极角排序可以用函数 atan2(y, x) 求出 $\\arctan \\frac{y}{x}$ ，返回 $[-\\pi, \\pi]$ 的结果。如果小于零就加上个 $2\\pi$ 吧，然后排序就行了。\n因为有可能被卡精度，你也可以用象限排序。如果同一象限就叉积，否则比象限。太难打就没打了。\n然后最左转线用于求这种带坐标的平面图和对偶图转化。具体请参见 miskcoo\u0026rsquo;s Blog ，这里讲得比较好，代码也写得很好。\n就是细节不少。\n然后我们发现题面的意思其实只需要我们求一种匹配方案使得 W 和 B 还有相邻产生的总贡献量最小，然后用 W 和 B 的总值减去这个值即可。\n网络流嘛。随便跑跑。\nCode // Code by ajcxsu // Problem: everfeel #define _USE_MATH_DEFINES #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=4e4+10, M=4e5+10; struct P { int x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } double ang() { double ang=atan2(y, x); if(ang\u0026lt;0) ang+=2.0*M_PI; return ang;} } p[N]; struct Edge { int w, u, v; double ang; } e[M]; vector\u0026lt;int\u0026gt; to[N]; int tp[N]; int ridx, mp; int a[N], b[N], rk[M], bel[M]; int A[M], B[M], tot; void ins(int a, int b, int w) { e[mp++]={w, a, b, (p[b]-p[a]).ang()}; } namespace NS { const int s=N-1, t=N-2; int h[N], to[M], nexp[M], W[M], p=2; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } #define sins(x, y, z) ins(x, y, z), ins(y, x, 0) int fl[N]; bool bfs() { queue\u0026lt;int\u0026gt; qu; qu.push(s); memset(fl, 0, sizeof(fl)); fl[s]=1; while(!qu.empty()) { int na=qu.front(); qu.pop(); for(int u=h[na];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; !fl[to[u]]) fl[to[u]]=fl[na]+1, qu.push(to[u]); } return fl[t]; } #define INF (0x3f3f3f3f) int dfs(int x, int op) { if(x==t) return op; int flow=0; for(int u=h[x];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; fl[to[u]]==fl[x]+1) { int d=dfs(to[u], min(op-flow, W[u])); W[u]-=d, W[u^1]+=d, flow+=d; if(flow==op) break; } if(!flow) fl[x]=0; return flow; } void work() { for(int i=0; i\u0026lt;mp; i+=2) ins(bel[i], bel[i+1], e[i].w), ins(bel[i+1], bel[i], e[i].w); for(int i=1; i\u0026lt;=ridx; i++) sins(s, i, A[i]), sins(i, t, B[i]), tot+=A[i]+B[i]; int flow=0; while(bfs()) flow+=dfs(s, INF); printf(\u0026quot;%d\\n\u0026quot;, tot-flow); } } bool vis[N]; void findreg(int x, int eid) { if(vis[eid]) return; ++ridx; while(!vis[eid]) { vis[eid]=1; bel[eid]=ridx, x=e[eid].v; A[ridx]+=a[x], B[ridx]+=b[x]; if(!rk[eid^1]) eid=to[x].back(); else eid=to[x][rk[eid^1]-1]; } } int main() { #ifndef LOCAL freopen(\u0026quot;everfeel.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;everfeel.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif int num; gn(num); int n, m; gn(n), gn(m); int u, v, w; for(int i=1; i\u0026lt;=n; i++) gn(u), gn(v), p[i]={u, v}, gn(a[i]), gn(b[i]); vector\u0026lt;pair\u0026lt;double, int\u0026gt; \u0026gt; tmp; for(int i=1; i\u0026lt;=m; i++) { gn(u), gn(v), gn(w); ins(u, v, w); ins(v, u, w); } for(int i=0; i\u0026lt;mp; i++) tmp.push_back(make_pair(e[i].ang, i)); sort(tmp.begin(), tmp.end()); for(int i=0; i\u0026lt;mp; i++) { int eid=tmp[i].second; rk[eid]=to[e[eid].u].size(); to[e[eid].u].push_back(eid); } for(int i=1; i\u0026lt;=n; i++) for(int j=0; j\u0026lt;to[i].size(); j++) findreg(i, to[i][j]); NS::work(); return 0; } ","oriTitle":"JZOJ6092 附耳而至","tags":["计算几何","网络流"],"title":"JZOJ6092 附耳而至","uri":"/posts/sol-jzoj-6092/"},{"categories":["solution"],"content":"转化比较巧妙，考场上想傻逼了的题目。很好打。\nProblem 给定一棵只有一个点的树，1e5次操作，每次加一个点后问至多交换一次两棵子树后的最大直径长度。强制在线。\nSolution 考虑事实上就是把直径上的链剖出然后询问最长支链的长度 $lp$ ，答案就是 $d+max(lp-1, 0)$ 。\n那么考虑每次加入一个点之后直径和最长支链的变化。如果直径变化，考虑另一条被换下来的支链一定是这条原支链的现长度-1。那么如果原支链的原长度就是最长支链，就直接考虑另一条被换下来的支链更新最长支链即可。如果不是最长支链，那么理论上最长支链是不会变化的，但是为了避免奇怪的错误我们还是要更新一下最长支链的点。\n如果直径不变化，那么直接用新加的点更新最长支链即可。\n倍增维护。\nCode // Code by ajcxsu // Problem: forest #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10, OP=19; int gup[OP][N], dep[N]; void add(int x, int fa) { gup[0][x]=fa, dep[x]=dep[fa]+1; for(int j=1; j\u0026lt;OP; j++) gup[j][x]=gup[j-1][gup[j-1][x]]; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } int dis(int s, int t) { return dep[s]+dep[t]-2*dep[lca(s, t)]; } int u=1, v=1, p=1, fa, len, lp, lst; int cac(int x) { return dis(x, u)+dis(x, v)-len\u0026gt;\u0026gt;1; } int main() { #ifndef LOCAL freopen(\u0026quot;forest.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;forest.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif dep[1]=1; int n, tod; gn(n), gn(n); int tmp; for(int i=2; i\u0026lt;=n; i++) { gn(fa), fa^=lst; add(i, fa); int la=dis(u, i), lb=dis(v, i); if(la\u0026gt;len || lb\u0026gt;len) { if(la\u0026gt;lb) tod=v, v=i, len=la; else tod=u, u=i, len=lb; if((tmp=cac(tod))\u0026gt;lp) lp=tmp, p=tod; } else if(((la+lb-len)\u0026gt;\u0026gt;1)\u0026gt;lp) lp=(la+lb-len)\u0026gt;\u0026gt;1, p=i; printf(\u0026quot;%d\\n\u0026quot;, lst=len+max(lp-1, 0)); } return 0; } ","oriTitle":"JZOJ6096 森林","tags":["倍增","树的直径"],"title":"JZOJ6096 森林","uri":"/posts/sol-jzoj-6096/"},{"categories":["solution"],"content":"调调改改了一晚上才过掉。总而言之还是自己对题目理解太不深刻了。基本上是对着抄但是又抄得很无奈。\nSolution 不考虑区间限制的话，则 $S, T$ 同时匹配。如果 $S$ 向 $c$ 边转移出现了不匹配，那么将 $S$ 向上跳到匹配为止，同时 $T$ 也应该向上跳使得 $len$ 与现处的状态相符。\n考虑区间限制的话，我们使用线段树合并维护树的 $endpos$ 集合。那么对于已经固定了的字符串长度 $l\u0026rsquo;$ ，需要加上字符 $c$ ，要求 $S$ 转移后所处状态的 $endpos$ 存在于 $[l+l\u0026rsquo;, r]$ 。否则我们需要将 $l\u0026rsquo;$ 一步步减小 来查看是否匹配。当 $l\u0026rsquo;=len[fa[p]]$ 时需要将 $p$ 向上转移。\n我们同时需要意识到我们可以在 $S$ 的 parent 树上直接转移，且转移到的节点的 $len$ 是符合假想区间 parent 树构造的（或者略大，但如果向上跳一定符合），因为我们转移到的状态一定在区间 parent 树上存在。这部分我觉得我可能还需要再加深理解。\n口胡一下：对于SAM，如果从状态 $A$ 转移到状态 $B$ ，你需要保证如下条件：$endpos$ 集合存在，且 $len\u0026rsquo;$ 属于结点所属 $len$ 区间。由于 $len\u0026rsquo;=len+1$ ，所以只需要保证 $endpos$ 合法即可。\nCode // Code by ajcxsu // Problem: yourname. #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=3e6+10, M=5e7+10; struct Node { int ch[26]; int len, fa; void clr() { len=fa=0; memset(ch, 0, sizeof(ch)); } } ; struct Tree *nil; struct Tree { int v, t; Tree *ls, *rs; } po[M], *pp=po; void ini() { nil=pp++; nil-\u0026gt;ls=nil-\u0026gt;rs=nil; } Tree* newn() { assert(pp!=po+M), *pp=*nil; return pp++; } void updata(Tree *\u0026amp;x, int l, int r, int d) { if(x==nil) x=newn(); x-\u0026gt;v=max(x-\u0026gt;v, d); if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d); else updata(x-\u0026gt;rs, mid+1, r, d); } Tree* Merge(Tree *x, Tree *y) { Tree *o=newn(); if(x==nil || y==nil) return x==nil?y:x; o-\u0026gt;v=max(x-\u0026gt;v, y-\u0026gt;v); o-\u0026gt;ls=Merge(x-\u0026gt;ls, y-\u0026gt;ls), o-\u0026gt;rs=Merge(x-\u0026gt;rs, y-\u0026gt;rs); return o; } int query(Tree *x, int l, int r, int xr) { if(r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=query(x-\u0026gt;ls, l, mid, xr); if(xr\u0026gt;mid) ret=max(ret, query(x-\u0026gt;rs, mid+1, r, xr)); return ret; } typedef long long ll; struct SAM { Node nd[N]; int idx=1, lst=1; int g[N]; Tree *tr[N]; void add(int c, int mode) { int p=lst, np=lst=++idx; nd[np].clr(), nd[np].len=nd[p].len+1; if(mode) updata(tr[idx], 0, N, nd[np].len); for(; p \u0026amp;\u0026amp; !nd[p].ch[c]; p=nd[p].fa) nd[p].ch[c]=np; if(!p) nd[np].fa=1; else { int q=nd[p].ch[c]; if(nd[q].len==nd[p].len+1) nd[np].fa=q; else { int nq=++idx; nd[nq]=nd[q]; nd[nq].len=nd[p].len+1, nd[q].fa=nd[np].fa=nq; for(; p \u0026amp;\u0026amp; nd[p].ch[c]==q; p=nd[p].fa) nd[p].ch[c]=nq; } } } int id[N], bu[N]; void sort() { fill(bu, bu+idx+1, 0); // !! for(int i=1; i\u0026lt;=idx; i++) bu[nd[i].len]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[nd[i].len]--]=i; } ll ftot; void ini1() { for(int i=idx; i\u0026gt;=2; i--) ftot+=nd[i].len-nd[nd[i].fa].len; } void ini2() { for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; tr[nd[tmp].fa]=Merge(tr[nd[tmp].fa], tr[tmp]); } } char str[N]; int n; void ini(int mode=0) { idx=lst=1; ftot=0; n=strlen(str); if(mode) fill(tr, tr+N, nil); nd[1].clr(); for(int i=0; i\u0026lt;n; i++) add(str[i]-'a', mode); sort(); fill(g, g+idx+1, 0); if(!mode) ini1(); else ini2(); } ll deal() { ll cnt=0; for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; g[tmp]=min(g[tmp], nd[tmp].len); g[nd[tmp].fa]=max(g[nd[tmp].fa], g[tmp]); cnt+=max(g[tmp]-nd[nd[tmp].fa].len, 0); // 忘取max了... } return ftot-cnt; } inline int mov(int x, char ch) { return nd[x].ch[ch-'a']; } } s, t; int main() { ini(); scanf(\u0026quot;%s\u0026quot;, s.str); s.ini(1); int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int l, r; while(T--) { scanf(\u0026quot;%s%d%d\u0026quot;, t.str, \u0026amp;l, \u0026amp;r); t.ini(); int na=1, nb=1, len=0, to; bool chg; for(int i=0; i\u0026lt;t.n; i++) { to=s.mov(na, t.str[i]); nb=t.mov(nb, t.str[i]); chg=0; while(na \u0026amp;\u0026amp; (!to || query(s.tr[to], 0, N, r)\u0026lt;l+len)) { if(!len) { na=0; break; } len--; if(len==s.nd[s.nd[na].fa].len) na=s.nd[na].fa, to=s.mov(na, t.str[i]); } if(!na) na=1, len=0; else na=to, len++; while(nb \u0026amp;\u0026amp; t.nd[t.nd[nb].fa].len\u0026gt;=len) nb=t.nd[nb].fa; nb+=!nb; t.g[nb]=max(t.g[nb], len); } printf(\u0026quot;%lld\\n\u0026quot;, t.deal()); } return 0; } ","oriTitle":"NOI2018 你的名字","tags":["SAM","线段树合并"],"title":"NOI2018 你的名字","uri":"/posts/sol-your-name/"},{"categories":["solution"],"content":"常数制造机\u0026hellip;\nSolution 考虑不重复的计算质因数。令 ${p_i}^{k_i}$ 形式的质因数成为一种颜色，贡献为 $p$ ，则最多可分割出 $n\\log V$ 种颜色，现在要做的是对限定深度不重复计算颜色的贡献。\n那么对深度设主席树（每一层的话是动态开点），然后对每个颜色计算树上差分进行贡献。同时对于每个颜色记录一个 set 来维护已出现 dfn 序，如果新加入了一个颜色在树上计算与 dfs 序相邻的已出现的点的贡献的变化量。查询的时候直接在主席树上查询即可。\n复杂度大概是 $\\log^2$ 级别？空间复杂度是玄学\u0026hellip;\nCode // Code by ajcxsu // Problem: half #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int K=1e7+10, N=1e5+10, OP=19; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } typedef pair\u0026lt;int, int\u0026gt; mpa; int dep[N], dl[N], dr[N], dd[N], idx; int gup[OP][N]; void dfs(int x, int k) { dep[x]=k, dl[x]=++idx, dd[idx]=x; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { dfs(to[u], k+1); gup[0][to[u]]=x; } dr[x]=idx; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } struct Dot { int x, k, i; } ; bool cmp(const Dot \u0026amp;a, const Dot \u0026amp;b) { return dep[a.x]\u0026lt;dep[b.x]; } vector\u0026lt;Dot\u0026gt; dot; vector\u0026lt;mpa\u0026gt; lis; int val[N]; int pri[K], pre[K], inv[K], pp; bool npri[K]; void di(int x, int y) { int k=0, rua=0; while(x\u0026gt;1) { if(rua!=pre[x]) rua=pre[x], k=0; k++; lis.push_back(mpa(rua, k)); dot.push_back({y, rua, k}); x/=rua; } } struct Node *nil; struct Node { Node *ls=nil, *rs=nil; int v=1, t=0; } ; Node *nd[N]; void ini() { nil=new Node, nil-\u0026gt;ls=nil-\u0026gt;rs=nil; nd[0]=nil; } void updata(Node *\u0026amp;x, int l, int r, int d, int v, int nt) { if(x-\u0026gt;t!=nt) { Node *nd=new Node; *nd=*x, x=nd; x-\u0026gt;t=nt; } x-\u0026gt;v=1ll*x-\u0026gt;v*v%MOD; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d, v, nt); else updata(x-\u0026gt;rs, mid+1, r, d, v, nt); } int query(Node *x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=1; if(xl\u0026lt;=mid) ret=1ll*ret*query(x-\u0026gt;ls, l, mid, xl, xr)%MOD; if(xr\u0026gt;mid) ret=1ll*ret*query(x-\u0026gt;rs, mid+1, r, xl, xr)%MOD; return ret; } set\u0026lt;int\u0026gt; s[N*25]; int main() { #ifndef LOCAL freopen(\u0026quot;half.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;half.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif ini(); ios::sync_with_stdio(false), cin.tie(0); /* pri inv */ inv[1]=1; for(int i=2; i\u0026lt;K; i++) inv[i]=(MOD-1ll*MOD/i*inv[MOD%i]%MOD); npri[1]=1; for(int i=2; i\u0026lt;K; i++) { if(!npri[i]) pri[pp++]=i, pre[i]=i; for(int j=0; j\u0026lt;pp \u0026amp;\u0026amp; i*pri[j]\u0026lt;K; j++) { npri[i*pri[j]]=1, pre[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; } } /* input */ int k, n; gn(k), gn(n); int na; for(int i=1; i\u0026lt;=n; i++) { gn(na); di(na, i); } int u, v; for(int i=1; i\u0026lt;n; i++) gn(u), gn(v), ins(u, v), ins(v, u); /* up */ dfs(1, 1); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; /* lis */ sort(lis.begin(), lis.end()); int tk=unique(lis.begin(), lis.end())-lis.begin(); for(int i=0; i\u0026lt;tk; i++) val[i]=lis[i].first; for(Dot \u0026amp;x:dot) x.k=lower_bound(lis.begin(), lis.begin()+tk, mpa(x.k, x.i))-lis.begin(); sort(dot.begin(), dot.end(), cmp); /* add */ int j=0; int nx, nc, mdep=dep[dot.rbegin()-\u0026gt;x]; for(int i=1; i\u0026lt;=mdep; i++) { nd[i]=nd[i-1]; while(j\u0026lt;dot.size() \u0026amp;\u0026amp; dep[dot[j].x]\u0026lt;=i) { nx=dot[j].x, nc=dot[j].k; auto it=s[nc].lower_bound(dl[nx]); int rx=(it==s[nc].end()?-1:dd[*it]); int lx=(it==s[nc].begin()?-1:dd[*(--it)]); updata(nd[i], 1, n, dl[nx], val[nc], i); if(rx!=-1 \u0026amp;\u0026amp; lx!=-1) updata(nd[i], 1, n, dl[lca(lx, rx)], val[nc], i); if(lx!=-1) updata(nd[i], 1, n, dl[lca(lx, nx)], inv[val[nc]], i); if(rx!=-1) updata(nd[i], 1, n, dl[lca(nx, rx)], inv[val[nc]], i); s[nc].insert(dl[nx]); j++; } } /* query */ int q, lstans=0; gn(q); while(q--) { gn(u), gn(v), u=u^(k*lstans), v=v^(k*lstans); printf(\u0026quot;%d\\n\u0026quot;, lstans=query(nd[min(dep[u]+v, mdep)], 1, n, dl[u], dr[u])); } return 0; } ","oriTitle":"JZOJ6086 动态半平面交","tags":["STL","主席树"],"title":"JZOJ6086 动态半平面交","uri":"/posts/sol-jzoj-6086/"},{"categories":["algorithm"],"content":"qia ke 还是 ka qiao ？\n凸包 对向量 $\\vec{a} \\times \\vec{b}$ 的运算的正负值由 $\\vec{a}$ 旋转到 $\\vec{b}$ 的角度的 $\\cos$ 决定（含正负号）。因此如果 $\\vec{a}$ 到 $\\vec{b}$ 是逆时针旋转它们的叉积就是正数，否则反之。\n那么 $x$ 排序后左右顺序扫一遍上下凸包。对于按顺序构成凸包的向量，一定是顺时针旋转，否则便不符合凸包的定义。因此使用栈来维护，如果出现了逆时针旋转则退栈。\n被称作 Graham Scan 算法。\n注意一些重复点的细节。\n旋转卡壳 用于计算凸包点对的最长距离。考虑枚举一条边，再考虑该边的对踵点（距离该边距离最大点），枚举这样所有的点边对即可获取最长距离。可以 $O(n)$ 扫过，而且误差较小。\n注意一些细节，同时特判凸包大小为 $3$ 的情况，这意味着所有点都处于同一直线上。\nCode - Beauty Contest // Code by ajcxsu // Problem: xuan zhuan qia qiao #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5e4+10; typedef long long ll; struct P { ll x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } ll norm() { return x*x+y*y; } double dis() { return sqrt(norm()); } } p[N], con[N]; ll cross(P a, P b) { return a.x*b.y-a.y*b.x; } bool cmp(const P \u0026amp;a, const P \u0026amp;b) { return a.x==b.x?a.y\u0026lt;b.y:a.x\u0026lt;b.x; } inline ll dpow(ll x) { return x*x; } double dis(P a, P b, P x) { return (double)abs(cross(a-x, b-x))/(a-b).dis(); } int t; int main() { ios::sync_with_stdio(false), cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;p[i].x\u0026gt;\u0026gt;p[i].y; sort(p+1, p+1+n, cmp); for(int i=1; i\u0026lt;=n; i++) { while(t\u0026gt;=2 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } int t2=t; for(int i=n-1; i\u0026gt;=1; i--) { while(t\u0026gt;=t2+1 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } if(t==3) cout\u0026lt;\u0026lt;(con[1]-con[2]).norm()\u0026lt;\u0026lt;endl, exit(0); int nt=1; ll ans=0; for(int i=1; i\u0026lt;t; i++) { while(dis(con[i], con[i+1], con[nt])\u0026lt;=dis(con[i], con[i+1], con[nt+1])) nt=nt%(t-1)+1; ans=max({ans, (con[i]-con[nt]).norm(), (con[i+1]-con[nt]).norm()}); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"凸包与旋转卡壳","tags":["计算几何","凸包","旋转卡壳"],"title":"凸包与旋转卡壳","uri":"/posts/convex-hull-and-qia-qiao/"},{"categories":["solution"],"content":"Problem 给定 $n$ ，求有多少个 $1\\to n$ 的排列可以分割成三个上升子序列。$n \\leq 500$。\nSolution 假设给定一个排列，那么我们贪心的从前往后选，维护三个上升序列，每扫到一个数字添加到能放的上升序列且保证原上升序列的最大值尽量大。这样一定能构造出一种合法方案（如果有）且分割方案唯一。\n考虑三个序列的最大值设计状态。由于不清楚插入的数具体是什么，我们令其为相对大小： $f_{i, j, k}$ ，且令 $i\u0026gt;j\u0026gt;k\\geq 0$ 。同时存在 $j=k=0$ 的情况。\n那么我们插入一个新的相对大小为 $l \\in [1, i+1]$ 的值。那么原相对大小处于 $[l, i]$ 区间的值都会被往后顶成 $[l+1, i+1]$ 。则我们分情况讨论 $l$ 的转移：\n$$ f_{i, j, k} \\rightarrow \\begin{cases} f_{i+1, j+1, l} \u0026amp; \\text{for } k\u0026lt;l\\leq j\\\\ f_{i+1, l, k} \u0026amp; \\text{for }j\u0026lt;l \\leq i\\\\ f_{i+1, j, k} \u0026amp; \\text{for }l=i+1 \\end{cases} $$\n差分即可优化到 $O(n^3)$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=501; int f[2][N][N], g[2][N][N]; int u, v=1; int n, P; int add(int \u0026amp;x, int y) { x+=y; if(x\u0026gt;=P) x-=P; return x; } int main() { freopen(\u0026quot;yuan.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;yuan.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); ios::sync_with_stdio(false), cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;P; f[v][0][0]=1; int ans=0; for(int i=1; i\u0026lt;=n; i++) { u^=1, v^=1; for(int j=0; j\u0026lt;i-1;j++) for(int k=0; k\u0026lt;=j; k++) f[v][j][k]=g[v][j][k]=0; for(int j=0; j\u0026lt;i-1; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j+1][k+1],f[u][j][k]), add(f[v][j+1][j+1],-f[u][j][k]), add(g[v][j+1][k],f[u][j][k]), add(g[v][i][k],-f[u][j][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j][k],f[v][j][k-1]), add(g[v][j][k],g[v][j-1][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) { add(f[v][j][k],add(g[v][j][k],f[u][j][k])); if(i==n) add(ans, f[v][j][k]); } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"JZOJ2090 圆","tags":["DP"],"title":"JZOJ2090 圆","uri":"/posts/sol-jzoj-2090/"},{"categories":["solution"],"content":"好题好做法\u0026hellip;\n感谢 gjx 的讲解。\nSolution 要用到的结论： $\\frac{1}{a}\\frac{1}{b}=(\\frac{1}{a}-\\frac{1}{b})\\frac{1}{b-a}$ 。\n我们要求的就是下面这个生成函数的第 $n$ 项： $$\\prod \\limits_{i=1}^{m} \\frac{1}{1-(ui+v)x}$$\n上面这个生成函数可以化为这样的形式： $$(\\frac{1}{ux})^{m-1} \\sum \\limits_{i=1}^m \\frac{a_i}{1-(ui-v)x}$$\n其中 $a_i$ 是该项的不定系数。\n至于为什么是这样，我们下面继续。\n令 $p_i=1-(ui+v)x$ 。我们从 $1\\to m$ 处理这个生成函数，即假设我们已经求出了 $1\\to m$ 的生成函数，然后我们要把这个函数乘上一个 $\\frac{1}{p_{m+1}}$ 来推出 $1\\to m+1$ 的生成函数。\n那我们考虑对于第二种形式的生成函数的每个 $i$ ，乘上这个之后的变化。\n即： $$\\frac{a_i}{p_i}\\frac{1}{p_{m+1}} = a_i(\\frac{1}{p_i}-\\frac{1}{p_{m+1}})\\frac{1}{u(i-m-1)x}$$\n此时我们发现对于每一项都会多乘上一个 $\\frac{1}{ux}$ ，因此我们可以将其整体提出，变成上面生成函数的形式。\n我们考虑第一次插入 $\\frac{1}{p_{i}}$ 这一项之后，令它的系数为 $f_i$ 。那么在插入 $i+1$ 项时，$f_i$ 会乘上一个 $\\frac{1}{ux(-1)}$ ，插入第 $i+2$ 项时会乘上一个 $\\frac{1}{ux(-2)}$ 。我们惊讶的发现有： $$a_i=(\\frac{1}{ux})^{m-i}(-1)^{m-i}\\frac{1}{(m-i)!}f_i$$\n再考虑 $f_{m+1}$ 的值： $$f_{m+1}=\\sum \\limits_{i=1}^{m} (-1)^{m-i}\\frac{1}{(m+1-i)!}f_i$$\n我们考虑 $f_i$ 的生成函数为 $F$ ，则有： $$F=F*(-e^{-x}+1)+x \\Rightarrow F=xe^x$$\n则我们可以得到最终生成函数的每一部分的第 $n$ 项的和： $$\\sum \\limits_{i=1}^{m} (ui+v)^{n+m-1} u^{-m+1} (-1)^{m-i} \\frac{1}{(m-i)!} f_i$$\n复杂度 $O(m\\log n)$ 。\nCode // Code by ajcxsu // Problem: IOer #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353ll) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10; typedef long long ll; ll finv[N], f[N]; ll qpow(ll x, ll y) { ll ret=1; while(y) { if(y\u0026amp;1) ret=ret*x%MOD; x=x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } ll n, m, u, v; ll pl[]={1, -1}; int solve() { int ans=0; ll invu=qpow(u, (MOD-2)*(m-1)); for(int i=1; i\u0026lt;=m; i++) ans=(ans+qpow((u*i+v)%MOD, n+m-1)*invu%MOD*f[i]%MOD*pl[(m-i)\u0026amp;1]*finv[m-i]%MOD+MOD)%MOD; return ans; } int main() { finv[0]=finv[1]=1; for(int i=2; i\u0026lt;N; i++) finv[i]=MOD-1ll*MOD/i*finv[MOD%i]%MOD; for(int i=2; i\u0026lt;N; i++) finv[i]=finv[i]*finv[i-1]%MOD; for(int i=0; i\u0026lt;N-1; i++) f[i+1]=finv[i]; int T; gn(T); while(T--) { gn(n), gn(m), gn(u), gn(v); printf(\u0026quot;%d\\n\u0026quot;, solve()); } return 0; } ","oriTitle":"JZOJ6080 IOer","tags":["数学","生成函数"],"title":"JZOJ6080 IOer","uri":"/posts/sol-jzoj-6080/"},{"categories":["solution"],"content":"⭐\nProblem 一个博弈游戏：给定一棵有根树，放一个石子在根节点，轮流执手，每次往任意叶子节点方向移一步，不能移则为输。\n现在给你 $n$ 个点，生成任意一棵有根树，问先手获胜的概率。有 $q$ 次询问。\n$n,q \\leq 10^5$\nSolution 令 $f(x), g(x)$ 分别为后手和先手必胜的 EGF ，则 $f(x)+g(x)=\\sum \\frac{(i-1)!}{i!}x^i$ 。所以有 $g(x)=-ln(1-x)-f(x)$ 。其中 $(i-1)!$ 为无标号有根树的方案数，$\\sum \\frac{(-1)^{i+1}}{i}x^i$ 为 $ln(x+1)$ 的麦克劳林级数。\n根据SG函数，因为后手必胜的子树皆为先手必胜，那么有 $xe^{g(x)}=f(x)$ 。解方程得 $f(x)=ln(1-ln(1-x))$ 。并不知道过程。\n所以可以得到最终的概率：$\\frac{(n-1)!-n!f_n}{(n-1)!}=1-nf_n$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; const int N=4e5+10; int f[N], g[N], h[N], r[N], n; void gen(int m) { int l=0; for(n=1; n\u0026lt;=m; n\u0026lt;\u0026lt;=1) l++; for(int i=1; i\u0026lt;n; i++) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); } int qpow(int x, int y) { assert(y\u0026gt;=0); int ret=1; while(y) { if(y\u0026amp;1) ret=1ll*ret*x%MOD; x=1ll*x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } void dft(int x[], int d) { for(int i=1; i\u0026lt;n; i++) if(r[i]\u0026gt;i) swap(x[i], x[r[i]]); int t, w, o; for(int i=1; i\u0026lt;n; i\u0026lt;\u0026lt;=1) { o=qpow(3, d*(MOD-1)/(i\u0026lt;\u0026lt;1)+MOD-1); for(int j=0; j\u0026lt;n; j+=(i\u0026lt;\u0026lt;1)) { w=1; for(int k=0; k\u0026lt;i; k++, w=1ll*w*o%MOD) t=1ll*x[i+j+k]*w%MOD, x[i+j+k]=(x[j+k]-t+MOD)%MOD, (x[j+k]+=t)%=MOD; } } } void mul(int x[], int y[], int z[], int m, int mode=0) { gen(m\u0026lt;\u0026lt;1); int a[N]={0}, b[N]={0}; copy(x, x+m, a), copy(y, y+m, b); dft(a, 1), dft(b, 1); for(int i=0; i\u0026lt;n; i++) if(!mode) a[i]=1ll*a[i]*b[i]%MOD; else a[i]=(2ll*b[i]-1ll*a[i]*b[i]%MOD*b[i]%MOD+MOD)%MOD; dft(a, -1); int inv=qpow(n, MOD-2); for(int i=0; i\u0026lt;m; i++) z[i]=1ll*a[i]*inv%MOD; } void inv(int a[], int f[], int deg) { assert(deg\u0026gt;0); if(deg==1) { f[0]=qpow(a[0]%MOD, MOD-2); return; } inv(a, f, (deg+1)\u0026gt;\u0026gt;1); mul(a, f, f, deg, 1); } void deri(int x[], int n) { for(int i=0; i\u0026lt;n; i++) x[i]=1ll*(i+1)*x[i+1]%MOD; x[n-1]=0; } void inte(int x[], int n) { for(int i=n-1; i\u0026gt;0; i--) x[i]=1ll*x[i-1]*qpow(i, MOD-2)%MOD; x[0]=0; } void pln(int x[], int y[], int n) { int a[N]={0}, b[N]={0}; copy(x, x+n, a); inv(a, b, n); deri(a, n); mul(a, b, a, n); inte(a, n); for(int i=0; i\u0026lt;n; i++) y[i]=a[i]; } int main() { ios::sync_with_stdio(false), cin.tie(0); int n=1e5+10; f[0]=1, f[1]=MOD-1; pln(f, g, n); for(int i=0; i\u0026lt;n; i++) g[i]=(MOD-g[i])%MOD; g[0]++; pln(g, h, n); int q; cin\u0026gt;\u0026gt;q; while(q--) { int na; cin\u0026gt;\u0026gt;na; cout\u0026lt;\u0026lt;(1-1ll*na*h[na]%MOD+MOD)%MOD\u0026lt;\u0026lt;'\\n'; } return 0; } ","oriTitle":"JZOJ6077 K君的游戏","tags":["数学","生成函数","多项式"],"title":"JZOJ6077 K君的游戏","uri":"/posts/sol-jzoj-6077/"},{"categories":["solution"],"content":"浪费了我一晚上的生命\u0026hellip;\nSolution 关于本题有两种做法，我一开始写的第一种：建立广义SAM，统计parent树上的endpos集合是否可以包含所有的字符串，如果可以就用len更新ans。可以状压。\n做法我拍了一下，大概是没问题的。但是这沙雕题卡常200ms我硬是给卡了一晚上😂然后发现一些神奇的问题。比如广义SAM是没法用基数排序来确定树上拓扑序的，所以得队列硬上，可惜不管怎么写都卡不过200ms。\n另一种做法就是神奇的转移：先建一个串，然后对于后加入的每个串计算一下状态匹配的最大值（可以通过后缀链接上传），然后再对于每个串取个最小值，最后总体取个最大值。这样的做法基本上是常数很小的 $O(n)$ ，或者是我常数制造机了\u0026hellip;\nCode - 80ms // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26]; int lst=1, idx=1; inline void add(int c) { int p=lst, np=lst=++idx; len[np]=len[p]+1; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int bu[N], id[N]; int su[N], f[N]; void solve() { int x=1, l=0; memset(su, 0, sizeof(su)); for(char *p=str; *p; p++) { if(ch[x][*p-'a']) l++, x=ch[x][*p-'a']; else { while(x \u0026amp;\u0026amp; !ch[x][*p-'a']) x=fa[x]; if(!x) l=0, x=1; else l=len[x]+1, x=ch[x][*p-'a']; } su[x]=max(su[x], l); } for(int i=idx; i\u0026gt;=1; i--) su[fa[id[i]]]=max(su[fa[id[i]]], su[id[i]]); for(int i=1; i\u0026lt;=idx; i++) len[i]=min(len[i], su[i]); } int main() { scanf(\u0026quot;%s\u0026quot;, str); for(char *p=str; *p; p++) add(*p-'a'); for(int i=1; i\u0026lt;=idx; i++) bu[len[i]]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[len[i]]--]=i; while(scanf(\u0026quot;%s\u0026quot;, str)==1) solve(); int ans=0; for(int i=1; i\u0026lt;=idx; i++) ans=max(ans, len[i]); printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  Code - TLE // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26], in[N]; int f[N], lst=1, idx=1; inline void add(int c, int val) { int p=lst, np=lst=++idx; len[np]=len[p]+1; f[np]=1\u0026lt;\u0026lt;val; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q], f[nq]=f[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int main() { int nidx=0; while(scanf(\u0026quot;%s\u0026quot;, str)==1) { lst=1; for(char *p=str; *p; p++) add(*p-'a', nidx); ++nidx; } nidx=(1\u0026lt;\u0026lt;nidx)-1; int ans=0, na, nf; for(int i=1; i\u0026lt;=idx; i++) in[fa[i]]++; for(int i=1; i\u0026lt;=idx; i++) if(!in[i]) qu[t++]=i; while(h!=t) { na=qu[h++], nf=fa[na]; if(f[na]==nidx \u0026amp;\u0026amp; len[na]\u0026gt;ans) ans=len[na]; f[nf]|=f[na], in[nf]--; if(!in[nf]) qu[t++]=nf; } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"SPOJ1812 LCS2","tags":["SAM"],"title":"SPOJ1812 LCS2","uri":"/posts/sol-spoj-1812/"},{"categories":["solution"],"content":"做法很巧妙。\nProblem 给你一棵树，和数条铁路的起点和终点，求有多少个火车会在路上相遇。\n每个火车的速度相同，起终点也算相遇，但经过终点后火车消失。\nSolution 首先如果在边上相遇一定是在中点，所以可以给每条边单独开一个点转化问题。\n然后将路径分为上行和下行，lca算在上行，求上下相交和上上相交即可。\n上上相交可以线段树合并，上下相交可以对每条重链分别处理，以重链的深度为 $x$ 轴，离起点的距离为 $y$ 轴，得到每条路径在每个重链的函数和值域，那么问题转化成求 $k=1/-1$ 的直线的交点数，可以直接离散到 $y$ 轴后扫描线求交点个数。\n注意上上相交的起点重合不要漏算。\nCode // Code by ajcxsu // Problem: correction #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(); x=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=2e5+10; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], fa[N], top[N], son[N], dep[N], dfn[N], len[N], idx; int bot[N]; void dfs1(int x, int k) { dep[x]=k, siz[x]=1; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { fa[to[u]]=x, dfs1(to[u], k+1), siz[x]+=siz[to[u]]; if(siz[son[x]]\u0026lt;siz[to[u]]) son[x]=to[u]; } } void dfs2(int x, int t) { top[x]=t, dfn[x]=++idx; len[t]++; if(son[x]) dfs2(son[x], t); else bot[t]=x; for(int u=h[x];u;u=nexp[u]) if(!dfn[to[u]]) dfs2(to[u], to[u]); } int lca(int s, int t, int mode=0) { while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); if(mode \u0026amp;\u0026amp; fa[top[s]]==t) return top[s]; s=fa[top[s]]; } if(mode) return dep[s]\u0026lt;dep[t]?son[s]:son[t]; return dep[s]\u0026lt;dep[t]?s:t; } struct Seg { int k, b, l, r; } ; vector\u0026lt;Seg\u0026gt; td[N]; struct Node *nil; struct Node { int v, t; Node *ls, *rs; Node () { v=t=0; ls=rs=nil; } } *nd[N], *nd2[N]; void ini() { nil=new Node(), nil-\u0026gt;ls=nil-\u0026gt;rs=nil, fill(nd, nd+N, nil), fill(nd2, nd2+N, nil); } ll updata(Node *\u0026amp;x, int l, int r, int d, int v) { if(x==nil) x=new Node(); x-\u0026gt;v+=v; int mid=(l+r)\u0026gt;\u0026gt;1; if(l==r) { x-\u0026gt;t=l; return x-\u0026gt;v-v; } if(d\u0026lt;=mid) return updata(x-\u0026gt;ls, l, mid, d, v); else return updata(x-\u0026gt;rs, mid+1, r, d, v); } void Merge(Node *\u0026amp;x, Node *a, Node *b, ll \u0026amp;cnt, int mode=0) { if(a==nil) { x=b; return; } if(b==nil) { x=a; return; } if(x==nil) x=new Node(); if(!mode \u0026amp;\u0026amp; a-\u0026gt;t) cnt+=1ll*a-\u0026gt;v*b-\u0026gt;v; x-\u0026gt;v=a-\u0026gt;v+b-\u0026gt;v; Merge(x-\u0026gt;ls, a-\u0026gt;ls, b-\u0026gt;ls, cnt, mode); Merge(x-\u0026gt;rs, a-\u0026gt;rs, b-\u0026gt;rs, cnt, mode); delete b; } int n; void modify(int x, int k, int l, int r, int ry) { int b=ry-(r-dep[x])*k; td[x].push_back({k, b, l-dep[x], r-dep[x]}); } void modifyup(int s, int t, ll \u0026amp;ans) { if(dep[s]\u0026lt;dep[t]) swap(s, t); /* ↑ */ ans+=updata(nd[s], 1, n, dep[s], 1); updata(nd2[t], 1, n, dep[s], -1); int bg=dep[s]; /* ↓ */ while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], -1, dep[top[s]], dep[s], bg-dep[s]); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], -1, dep[s], dep[t], bg-dep[t]); } void modifydown(int s, int t, int rua) { int bg=min(dep[s], dep[t]); while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], 1, dep[top[s]], dep[s], dep[s]-bg+rua); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], 1, dep[s], dep[t], dep[t]-bg+rua); } void dfs(int x, ll \u0026amp;cnt) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa[x]) { dfs(to[u], cnt); Merge(nd[x], nd[x], nd[to[u]], cnt); } Merge(nd[x], nd[x], nd2[x], cnt, 1); } #define lowbit(x) x\u0026amp;-x namespace BIT { const int V=N\u0026lt;\u0026lt;2; int C[V], stk[V][2], t; void updata(int x, int v, int mode=0) { if(!mode) stk[++t][0]=x, stk[t][1]=v; while(x\u0026lt;V) C[x]+=v, x+=lowbit(x); } int query(int x) { int ret=0; while(x) ret+=C[x], x-=lowbit(x); return ret; } void clr() { while(t) updata(stk[t][0], -stk[t][1], 1), t--; } } struct Query { int t, v, x, l, r; } ; Query tmp[N\u0026lt;\u0026lt;1]; int t; bool cmp(const Query \u0026amp;a, const Query \u0026amp;b) { return a.x==b.x?a.t\u0026lt;b.t:a.x\u0026lt;b.x; } ll count(int x) { t=0; for(Seg y:td[x]) if(y.k==1) { tmp[++t]={0, 1, 2*y.l+y.b, y.b+(N\u0026lt;\u0026lt;1)}; tmp[++t]={2, -1, 2*y.r+y.b, y.b+(N\u0026lt;\u0026lt;1)}; } else { tmp[++t]={1, 0, y.b, y.b-2*y.l+(N\u0026lt;\u0026lt;1), y.b-2*y.r+(N\u0026lt;\u0026lt;1)}; } sort(tmp+1, tmp+1+t, cmp); ll ret=0; BIT::clr(); for(int i=1; i\u0026lt;=t; i++) if(tmp[i].t==1) ret+=BIT::query(tmp[i].l)-BIT::query(tmp[i].r-1); else BIT::updata(tmp[i].l, tmp[i].v); return ret; } int main() { int u, v; gn(n); for(int i=1; i\u0026lt;n; i++) { gn(u, v); ins(u, i+n), ins(i+n, u); ins(v, i+n), ins(i+n, v); } ini(); dfs1(1, 1), dfs2(1, 1); ll ans=0; int m; gn(m); for(int i=1; i\u0026lt;=m; i++) { gn(u, v); int l=lca(u, v); if(l==v) modifyup(u, v, ans); else { int l2=lca(l, v, 1); modifyup(u, l, ans); modifydown(v, l2, dep[u]-dep[l]+1); } } dfs(1, ans); for(int i=1; i\u0026lt;=2*n-1; i++) if(top[i]==i) ans+=count(i); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } ","oriTitle":"Railway","tags":["树链剖分","扫描线"],"title":"Railway","uri":"/posts/sol-jzoj-6074/"},{"categories":["solution"],"content":"有点难\u0026hellip;\nSolution 网上已经讲得很详细了吧？\n补充几个问题。一是可以直接 $f_{R}=\\sum \\limits_{j=L-1}^R f_j$ 进行转移。但是得注意先转移大区间再转移小区间（这属于被部分包含），否则的话你可能会丢失不选小区间的决策。\n第二个问题是若速度可以相等，那么需要将开始的排序进行一些小修改。考虑 $X_i$ 的左端比它大的最小的 $j$ ，若有数个 $V_k$ 等于 $V_j$ ，那么这些 $V_k$ 的点是肯定不能被染色的。右侧同理。\nCode // Code by ajcxsu #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (1000000007) using namespace std; const int N=5e5+10; int h[N], l[N], r[N]; vector\u0026lt;int\u0026gt; L[N]; int x[N], v[N], a[N]; bool cmp(const int \u0026amp;a, const int \u0026amp;b) { return v[a]\u0026lt;v[b] || (v[a]==v[b] \u0026amp;\u0026amp; x[a]\u0026lt;x[b]); } int f[N], S[N]; int main() { ios::sync_with_stdio(false), cin.tie(0); int n, m; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;v[i], a[i]=i; sort(a+1, a+1+n, cmp); int stk[N], p[N], t=0; for(int i=1; i\u0026lt;=n; i++) { if(!t || stk[t]\u0026lt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026lt;x[a[i]]) l=mid+1; else r=mid; } ::l[i]=p[r]; } t=0; for(int i=n; i\u0026gt;=1; i--) { if(!t || stk[t]\u0026gt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026gt;x[a[i]]) l=mid+1; else r=mid; } ::r[i]=p[r]; } for(int i=1; i\u0026lt;=n; i++) L[r[i]].push_back(l[i]); f[0]=S[0]=1; for(int i=1; i\u0026lt;=n; i++) { S[i]=S[i-1]; sort(L[i].begin(), L[i].end()); for(int j:L[i]) { f[i]=(1ll*f[i]+S[i]-(j-2\u0026gt;=0?S[j-2]:0)+MOD)%MOD; S[i]=(f[i]+S[i-1])%MOD; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC015E Mr.Aoki Incubator","tags":["单调栈","DP","二分"],"title":"AGC015E Mr.Aoki Incubator","uri":"/posts/sol-agc-015-e/"},{"categories":["solution"],"content":"有点神的构造，考场上想复杂了\u0026hellip;\nSolution 考虑因为变换 $2^n-1$ 次，那么 $A$ 跟 $B$ 的 $1$ 位数的奇偶性一定不同，用这个来判断是否有解。\n通过归纳可以知道如果不同是一定有解的。\n假设存在 $n=k$ 的构造方案，考虑如何构造 $k+1$ 位的构造方案。我们可以将 $A$ 和 $B$ 不同的一位（假设是第 $x$ 位）提取出来，剩下 $k$ 位数 $A\u0026rsquo;$ 和 $B\u0026rsquo;$ 。他们的位数奇偶性一定相同。那么我们再考虑一个一位与 $A\u0026rsquo;$ 不同的数 $c$ 。递归去构造一个 $A\u0026rsquo;\\rightarrow c \\rightarrow B\u0026rsquo;$ 的方案。其中前半部分的第 $x$ 位与 $A$ 相同，后半部分与 $B$ 相同。\n递归构造即可。\nCode // Code by ajcxsu // Problem: C #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef bitset\u0026lt;10\u0026gt; bs; void solve(int k, int a, int b, vector\u0026lt;int\u0026gt; \u0026amp;op) { if(k==1) { op.push_back(a), op.push_back(b); return; } int c=0; vector\u0026lt;int\u0026gt; L, R; for(; ((1\u0026lt;\u0026lt;c)\u0026amp;a)==((1\u0026lt;\u0026lt;c)\u0026amp;b); c++); int na=(a\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((a\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); int nb=(b\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((b\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); solve(k-1, na, na^1, L); solve(k-1, na^1, nb, R); for(int x:L) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;a)); for(int x:R) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;b)); } int main() { ios::sync_with_stdio(false), cin.tie(0); int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!((__builtin_popcount(a)+__builtin_popcount(b))\u0026amp;1)) cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;, exit(0); vector\u0026lt;int\u0026gt; ans; solve(n, a, b, ans); cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; for(int x:ans) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;' '; cout\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC032C Differ by 1 bit","tags":["构造"],"title":"AGC032C Differ by 1 bit","uri":"/posts/sol-agc-032-c/"},{"categories":["solution"],"content":"弄了一晚上，几篇博客交换看才看懂。\n可能也是因为分心了的缘故。\nSolution 将整棵树分为 $k+1$ 个联通块，对每个联通块找直径，然后直径端点连成一条链一定是最优解。\n考虑转化问题，求树上 $k+1$ 条不相交链的最大权和。\n设计状态。考虑一个点的度数只可能为 $0/1/2$ 。令 $f_{i, j, k}$ 为第 $i$ 个点，度数为 $j$ ，用了 $k$ 条链的子树最优解。\n再具体阐述状态。$f_{i, 0}$ 代表这个点度数为 $0$ ，即在最终的方案中它并不属于直径，因此不占用任何链的个数也不提供任何贡献。 $f_{i, 1}$ 的状态正常。 $f_{i, 2}$ 代表这个点的度数为 $2$ 。那么如果我们想要一个单点成为直径中的一条链，我们就假设是 $i$ 向自己连了自环，度数为 $2$ 且占用了一条链的数目。\n那么初始化也就呼之欲出了：$f_{i, 0, 0}=f_{i, 2, 1}=0$ ，其余置为 $-\\infty$ 。\n转移不难。\n通过观察（打表）发现对于使用链数为 $k$ 的最优解呈凸函数，使用 凸优化dp 来去除 $k$ 的限制。\n注意我们是对每条链产生的贡献减去斜率而不是对每条边。\n那么初始的dp去除第三维来做就行了。\n但是凸函数可能会出现你要找的点和前后两点处于同一直线。那么此时应当二分到该直线的斜率，并使用斜率和 $k$ 来直接求出 $k$ 的最优值。\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 林克卡特树","tags":["凸优化DP"],"title":"LP4383 林克卡特树","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"一道不错相对简单的题目。\nSolution 很大胆的想法。考虑以子树dp，然后一条链大力拉下来枚举链底部求贡献。\n那么对于每棵子树求最优的链底。\n用线段树维护。考虑点上移，链底贡献的变化量。\n重链贡献中有 $\\log$ 的存在，但我们发现每个链底及其每棵子树对重链贡献的变化次数不会超过 $\\log$ 次，因此复杂度是 $O(n\\log^2 n)$ 的。\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 新年的小黄鸭","tags":["线段树","树形dp"],"title":"UOJ462 新年的小黄鸭","uri":"/posts/sol-uoj-462/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"CLOUD DRIVE SHARE ID: 18shvmR8qqAhD2OlZjs3eo1ddXM3EPJVa\n 主题由 Kevin Tan 制作，并在 Margatroid 的修改版本上加以改动。\n ","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]