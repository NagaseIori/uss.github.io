[{"categories":["others"],"content":"è®°å½•ä¸€ä¸‹æˆ‘ä½œä¸º OIER æ—¶æˆ‘æŠ˜è…¾è¿‡çš„äº‹æƒ…ã€‚\nå¹¶å¿ å‘Šå„ä½ OIERï¼Œå› ä¸ºæˆ‘æŠ˜è…¾è¿‡äº†è¿™äº›äº‹æƒ…ï¼ˆå¹¶ä¸”æˆ‘æœ€ç»ˆå¾ˆæƒ¨åœ°é€€å½¹äº†ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä¸å»ºè®®æ‰€æœ‰æœªé€€å½¹ OIER æŠ˜è…¾è¿™äº›äº‹æƒ…ï¼ˆé™¤éä½ æ˜¯ç¥ä»™åˆå¾ˆé—²ï¼‰ã€‚\nBLOG åšå®¢äº‹ä¸ªå¤§å‘ã€‚æˆ‘ç¬¬ä¸€æ¬¡å¯è¿½æº¯çš„åšå®¢å¯ä»¥åˆ°æˆ‘åœ¨æˆ‘å®¶ç”µè„‘ä¸Šç”¨çš„ä¸€å°å°ç ´ æ ‘è“æ´¾ + WORDPRESS ï¼Œç”±äºæ— å…¬ç½‘ IP äºæ˜¯åˆç”¨äº† OICP çš„è¾£é¸¡åŸŸåï¼Œè¾£é¸¡ç«¯å£å’Œè¾£é¸¡å†…ç½‘ç©¿é€æ–¹æ¡ˆã€‚å› æ­¤æˆ‘è¿˜ä¹°äº†èŠ±ç”Ÿå£³çš„é…ä»¶ã€‚\nè¿™é‡Œæä¾›ä¸¤ç§æ­å»ºå±äºè‡ªå·±çš„ BLOG çš„æ€è·¯ã€‚\nPlan A - ä½¿ç”¨ç°æˆçš„åšå®¢æ¨¡æ¿/ç½‘ç«™ è¿™é‡Œä»‹ç»ä¸‰ç§æˆ‘çŸ¥é“çš„ï¼Œå…¶å®ƒçš„ç”±äº OIER ç”¨çš„è¾ƒå°‘æˆ–è€…æˆ‘ä¸çŸ¥é“æ‰€ä»¥æ²¡æœ‰æ¨èã€‚\nåšå®¢å›­ è¿™æ˜¯ OIER æœ€å¸¸ç”¨çš„åšå®¢ç½‘ç«™ã€‚åŒæ—¶ä½ å¯ä»¥ä¿®æ”¹è‡ªå·±çš„ CSS æ¨¡æ¿ï¼Œæˆ–è€…ç”³è¯· JS è„šæœ¬çš„æƒé™æ¥è®©åšå®¢å›­å˜å¾—å¥½çœ‹ã€‚\nåšå®¢å›­é™¤äº†æœ€åº•ä¸‹çš„å¹¿å‘Šä»¥å¤–ï¼Œç®€æ´ï¼Œå¥½ç”¨ï¼Œç”šè‡³ä¸éœ€è¦ä½ å†å»å…¶ä»–åœ°æ–¹å¯»æ‰¾å›¾åºŠã€‚å¹¶ä¸”èƒ½å¤Ÿè¾¾åˆ°ä¸€å®šé«˜åº¦çš„è‡ªå®šä¹‰ç¨‹åº¦ï¼ˆç®€å•æ¥è¯´å°±æ˜¯æ”¹ä¸»é¢˜ï¼‰ï¼ŒåŒæ—¶ä¿è¯äº†åšå®¢æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼ˆåˆ†ç±»ã€æ–‡ç« ã€è¯„è®ºï¼‰ï¼Œä¹Ÿå¯ä»¥å¾ˆæ¸…æ¥šçš„çœ‹åˆ°é˜…è¯»æ•°ï¼Œå¹¶è·å¾—ç›¸å¯¹è¾ƒé«˜çš„æ›å…‰åº¦å’Œç‚¹å‡»é‡ã€‚\nå¦‚æœä½ ä¸æ˜¯å¾ˆæƒ³æŠ˜è…¾ï¼Œæˆ‘å»ºè®®ä½¿ç”¨åšå®¢å›­å°±å·²ç»è¶³å¤Ÿã€‚ä½¿ç”¨åšå®¢å›­çš„ OIER è¶³å¤Ÿå¤šï¼Œä¹Ÿä¸ç”¨æ‹…å¿ƒæƒ³è¦è‡ªå®šä¹‰æ—¶ç½‘ä¸Šæ²¡æœ‰æ•™ç¨‹ï¼ˆè™½ç„¶ç»å¤§å¤šæ•°æƒ…å†µä¸‹ä½ ä¹Ÿåªèƒ½ç”¨æ¨¡æ¿äº†ï¼‰ã€‚\næ•ˆæœå¯ä»¥å‚è€ƒæˆ‘çš„åšå®¢å›­ï¼šhttp://acxblog.cnblogs.com\nCSDN è¾£é¸¡ï¼Œä½“éªŒæå·®ï¼Œæˆ‘æ²¡ç”¨ã€‚\nWordpress å—¯ï¼Œwordpress ä¹Ÿæ˜¯æœ‰ç°æˆçš„å®˜æ–¹ç½‘ç«™å¯ä»¥ç›´æ¥ç”³è¯·ä½¿ç”¨çš„ã€‚ä½†ä¸€ä¸ªå¤§é—®é¢˜å°±æ˜¯å›½å¤–ç½‘ç«™ï¼ˆå¯èƒ½è¿˜ç”¨äº†ä¸€å † google çš„ä¸œè¥¿ï¼‰å¯¼è‡´è®¿é—®é€Ÿåº¦ææ…¢ï¼Œå¹¶ä¸”åœ¨å›½å†…çš„æ›å…‰åº¦ç›¸å¯¹è¾ƒä½ï¼Œå¯èƒ½è¿˜ä¼šå—åˆ°åƒåœ¾è¯„è®ºçš„å›°æ‰°\u0026hellip; æ‰€ä»¥è™½ç„¶æˆ‘æ²¡æ€ä¹ˆç”¨ï¼Œä½†ä¹Ÿè§‰å¾—ä¸æ˜¯å¾ˆé€‚åˆ OIER ä½¿ç”¨ã€‚\nPlan B - ä½¿ç”¨è‡ªå»ºçš„åšå®¢ å¦‚æœä½ æ˜¯ä¸€ä¸ªå–œæ¬¢æŠ˜è…¾çš„äººï¼Œé‚£æ¬¢è¿ï¼Œä½†ä¸å»ºè®®ï¼Œä½ èµ°å…¥è¿™ä¸ªå¤§å‘ã€‚\nä½¿ç”¨è‡ªå»ºåšå®¢å³æ˜¯ä½ éœ€è¦æ­å»ºä¸€ä¸ªè‡ªå·±çš„ç½‘ç«™ï¼Œè¿™é‡Œæœ‰ä¸¤ç§æ–¹æ³•ï¼Œå…¶ä¸­ä¸€ç§æ–¹æ³•ç›¸å¯¹æ¯”è¾ƒå¯è¡Œã€‚\né™æ€é¡µé¢ é™æ€é¡µé¢æˆ‘æ˜¯ä¹‹åæ‰å¼€å§‹ä½¿ç”¨çš„ã€‚ä¹Ÿå°±æ˜¯ä½ æ­£åœ¨çœ‹çš„è¿™ä¸ªåšå®¢ï¼Œå®é™…æ˜¯æˆ‘æ­å»ºçš„æœ€åä¸€ä¸ªåšå®¢ã€‚\næˆ‘ä½¿ç”¨çš„æ˜¯ HUGO+GITHUB PAGE ã€‚å…³äºå¦‚ä½•ä½¿ç”¨ GITHUB PAGE ç½‘ä¸Šåº”è¯¥æœ‰äº†è¯¦ç»†çš„æ•™ç¨‹ï¼Œä½†ç”¨ HUGO çš„äººæ¯”è¾ƒå°‘å§ï¼ˆå› ä¸ºæ•™ç¨‹æ¯”è¾ƒå°‘ï¼‰ã€‚\nä½¿ç”¨ GITHUB PAGE çš„è¯ä½ éœ€è¦é¡ºå¸¦å­¦ä¹  GIT çš„åŸºæœ¬ä½¿ç”¨æ–¹æ³•ï¼Œå¦‚æœå¯¹æ­¤å®Œå…¨ä¸€æ— æ‰€çŸ¥è¿˜æ˜¯ä¸å¤ªå¥½æŠ˜è…¾çš„ã€‚\næˆ‘è¿™ä¸ªåšå®¢ä¹Ÿæ˜¯å‹‰å‹‰å¼ºå¼ºç”¨ä¸Šçš„ï¼Œéƒ½æ˜¯çœ‹ç€å¼•å¯¼å’Œç¿»æ•™ç¨‹åšçš„ï¼Œæ‰€ä»¥ç”¨äº†å‡ ä¸ªå°æ—¶å¼„è¿™äº›ä¸œè¥¿\u0026hellip; å¦‚æœä½ è§è¿‡æˆ‘è¿™ä¸ªåšå®¢çš„åŸä¸»é¢˜ï¼Œä½ ä¼šå‘ç°æˆ‘æŠŠé¦–é¡µçš„åŠ¨ç”»æ•ˆæœæ¢äº†ï¼Œå¹¶æŠŠå³ä¾§çš„ TOC çš„ç–‘ä¼¼ BUG ç»™ä¿®å¤äº†ï¼ˆè‡³å°‘åŸæ¥é‚£ä¸ªçœ‹ä¸Šå»æ˜¯çœŸçš„ä¸‘ï¼‰ï¼Œä½†æˆ‘è¯´å®è¯å¯¹ css å’Œ html ä¸€æ— æ‰€çŸ¥ï¼Œå®Œå…¨æ˜¯é€šè¿‡ç½‘ä¸Šé›¶ç¢çš„æ•™ç¨‹å’Œå°è¯•çæŠ˜è…¾çš„ï¼Œå·¦ä¸‹çš„ CC åè®®ä¹Ÿæ˜¯å¤åˆ¶çš„æŸä½ OIER çš„ åšå®¢ çš„ï¼ˆåŒ…æ‹¬ä¸»é¢˜ä¹Ÿæ˜¯åŒæ¬¾ wï¼‰ï¼Œæ‰€ä»¥ä¹Ÿç®—æµªè´¹äº†å¾ˆå¤šæ—¶é—´å§\u0026hellip;\né™æ€é¡µé¢ +GITHUB PAGE æœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿå…è´¹ï¼Œæœ‰è¾ƒé«˜çš„å¯è‡ªå®šä¹‰æ€§ï¼ˆé™æ€ï¼‰ã€‚\næœ‰ä»€ä¹ˆåå¤„å‘¢ï¼Ÿç”±äºæ˜¯é™æ€é¡µé¢ï¼ŒåŒ…æ‹¬è¯„è®ºç­‰æ›´é«˜çº§çš„åŠŸèƒ½éƒ½éœ€è¦é€šè¿‡ js ç­‰æ¥å®ç°ï¼ˆä½†è¯´å®è¯åº”è¯¥ä¹Ÿæ²¡æœ‰è¿™ä¸ªéœ€æ±‚ï¼‰ã€‚åŒæ—¶åšå®¢çš„æ‰€æœ‰é¡µé¢çš„ html æºç åœ¨ GITHUB ä¸Šæ˜¯å®Œå…¨å…¬å¼€çš„ï¼Œå› æ­¤éšè—é¡µé¢æ˜¯åšä¸åˆ°çš„ï¼ˆä½†è¯´å®è¯åº”è¯¥ä¹Ÿæ²¡è¿™ä¸ªéœ€æ±‚ï¼‰ï¼ŒåŒæ—¶ä½ éœ€è¦éµå®ˆ GITHUB åè®®ï¼Œä¸èƒ½åšç±»ä¼¼äºæœ¬å­å‘å¸ƒæˆ–è€…æ¶©å›¾ç”»å¸ˆæ¨èä¹‹ç±»çš„æ–‡ç« ï¼ˆä½†è¯´å®è¯åº”è¯¥ä¹Ÿæ²¡è¿™ä¸ªéœ€æ±‚ï¼‰ã€‚\næ€»è€Œè¨€ä¹‹ä½ æ˜¯ä¸€ä¸ªæ²¡é’±çš„æŠ˜è…¾å…šçš„è¯è¿™ä¸ªåº”è¯¥å°±å¤Ÿä½ æŠ˜è…¾ä¸€é˜µå­çš„äº†ï¼ˆç¬‘ï¼‰\néé™æ€é¡µé¢ è¿™ä¸ªæ˜¯çœŸæ­£çš„å¤§å‘ï¼Œç”¨çš„äººä¹Ÿåº”è¯¥æœ€å°‘ï¼Œä½†ä¹Ÿè¿˜æ˜¯æœ‰ä¸å°‘äººåœ¨ç”¨ã€‚ä¾‹å¦‚ç›¸å½“ç²¾ç¾å’Œå®ç”¨çš„ MiNa!ï¼Œå’Œ ZJ ç¥ä»™ ZigZagK çš„å®Œå…¨è‡ªå»ºåšå®¢ï¼ˆä¸»é¢˜ä¹Ÿæ˜¯è‡ªå·±å†™çš„ï¼Œè€Œä¸”å¾ˆå¥½çœ‹ï¼ï¼‰ã€‚å¦‚æœä½ æƒ³è¦å®Œå…¨çš„è‡ªå®šä¹‰å¹¶ä¸”æ— é™çš„æŠ˜è…¾æ€§ï¼Œå¹¶æœ‰å……è¶³çš„èµ„é‡‘å’ŒæŠ€æœ¯æ¥æ”¯æ’‘ä½ çš„åšå®¢ï¼Œé‚£å°±\u0026hellip; çœŸä¸æ¨èå…¥å‘ï¼Œå› ä¸ºä½ ä¼šåœ¨ä¸Šé¢è€—è´¹å¾ˆå¤šå¾ˆå¤šæ—¶é—´ w ï¼ˆè‡³å°‘ä¸€å¤©ï¼Ÿï¼‰\nç”±äºæˆ‘æ²¡æœ‰ç²¾åŠ›å†™å®Œæ•´çš„æ•™ç¨‹ï¼Œæ‰€ä»¥åªä¼šæå‡ºä¸€äº›å»ºè®®ã€‚\né¦–å…ˆè¦æœ‰ç‹¬ç«‹çš„æœåŠ¡å™¨ã€‚æˆ‘æ­£åœ¨ç”¨çš„æ˜¯ CEFHOST çš„é¢æ¿ï¼Œè¿™å®¶å¹´ä»˜åœ¨ææ´»åŠ¨çš„æ—¶å€™æ¯”è¾ƒä¾¿å®œï¼Œå¤Ÿç”¨ï¼Œå¹¶ä¸”èƒ½å¤Ÿè¯·æ±‚ç®¡ç†å‘˜å¸®ä½ äº‹å…ˆè£…å¥½ä½ éœ€è¦çš„åšå®¢è½¯ä»¶ï¼ˆä¾‹å¦‚ Wordpress å’Œ Typechoï¼‰ï¼Œè€Œä¸”ç»­è´¹çš„æ—¶å€™æ˜¯èƒ½ä¿æŒå‰ä¸€å¹´çš„ä»·æ ¼çš„\u0026hellip; æ‰€ä»¥æˆ‘ä¸€ç›´åœ¨ç”¨è¿™å®¶çš„æœåŠ¡å™¨ã€‚åŒæ—¶é¢æ¿é…ç½® HTTPS ä»€ä¹ˆçš„ä¹Ÿå¾ˆæ–¹ä¾¿ã€‚å…³äº HTTPSï¼Œå¦‚æœä½ ç”¨é¢æ¿çš„è¯ç”¨é‡Œé¢ä¸€é”®é…ç½®çš„ Let\u0026rsquo;s Encrypt å°±è¡Œäº†ï¼Œå¦åˆ™ä½ è¿˜å¾—å»å„å¤§ç½‘ç«™ç¿»å“ªé‡Œæœ‰å…è´¹ HTTPS \u0026hellip; è¯ä¹¦å¾ˆè´µçš„ã€‚\nå…¶æ¬¡æ˜¯åŸŸåã€‚æˆ‘æ­£åœ¨ç”¨çš„æ˜¯ è¥¿éƒ¨æ•°ç  æ³¨å†Œçš„åŸŸåï¼Œåæ¥è½¬ç§»åˆ°äº† Cloudflare ã€‚Cloudflare æœ‰ä¸€äº›åŠŸèƒ½è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œåªæ˜¯ä»–ä»¬å®¶çš„ CDN æœ‰æ—¶å€™ä»å›½å†…è®¿é—®æ¯”è¾ƒæ…¢ã€‚åŸŸåæˆ‘ä¸ªäººè®¤ä¸ºæŒ‘ä¾¿å®œçš„å¤Ÿç”¨å°±è¡Œï¼Œæˆ‘è§‰å¾— .com å’Œ .moe éƒ½å¥½è´µ\u0026hellip;\næœ€åæ˜¯åšå®¢è½¯ä»¶ï¼Œä¹Ÿæ²¡å•¥å¥½æ¨èçš„ï¼Œå°±ä»‹ç»ä¸¤ç§å§ã€‚\nWordpress è€ç‰Œçš„åšå®¢è½¯ä»¶ã€‚åºå¤§ï¼Œå¤šåŠŸèƒ½ï¼Œé›†æˆæ€§å’ŒåŒ…è£…éƒ½éå¸¸æ¼‚äº®ã€‚æœ‰æˆç†Ÿçš„ä¸»é¢˜å’Œæ’ä»¶ç¯å¢ƒï¼Œå¯ä»¥è¿›è¡Œæ·±åº¦è‡ªå®šä¹‰å’Œå¼ºå¤§çš„åŠŸèƒ½æ‰©å±•ã€‚MiNa! çš„åšå®¢ï¼Œç”šè‡³ä¸€äº›è€ç‰Œç½‘ç«™ï¼ˆæŸç¥ç¤¾ã€åˆéŸ³ç¤¾ï¼‰éƒ½æ˜¯ä½¿ç”¨ Wordpress å»ºç«™çš„ã€‚\né™¤éä½ æ‹…å¿ƒä½ çš„æœåŠ¡å™¨é…ç½®ä¸å¤Ÿï¼Œé‚£å°±ç”¨ Wordpress å§ã€‚ä½† Wordpress ä¹Ÿä¼šè°ƒç”¨ Google é‡Œçš„ä¸€äº›èµ„æºæ‰€ä»¥æœ‰æ—¶ä¼šè®¿é—®æ¯”è¾ƒæ…¢ï¼Œä¸çŸ¥é“ç°åœ¨è§£å†³äº†æ²¡æœ‰ã€‚\nTypecho è½»é‡çº§çš„åšå®¢è½¯ä»¶ã€‚çœŸçš„å¾ˆè½»é‡ã€‚ç›¸åº”çš„åŠŸèƒ½è¾ƒå°‘ï¼Œæ’ä»¶ç¯å¢ƒè¾ƒå·®ï¼Œä¹Ÿç®—æ˜¯éå¸¸å°ä¼—çš„åšå®¢äº†ï¼Œä½†æˆ‘è¿˜æ˜¯æ­£åœ¨ä½¿ç”¨ Typecho ï¼Œç©¶å…¶åŸå› æ˜¯æˆ‘ä¸æƒ³æŠ˜è…¾ Wordpress äº†ã€‚\nä¼˜ç‚¹æ˜¯ä½ æƒ³æ”¹äº›ä»€ä¹ˆä¸œè¥¿ä¼šæ¯”è¾ƒæ–¹ä¾¿å§ï¼Œå› ä¸ºå¾ˆè½»é‡ï¼Œä½ å¯ä»¥ç›´æ¥åœ¨ typecho çš„ä¸»é¢˜æ¨¡æ¿ä¸Šè¿›è¡Œä¿®æ”¹ã€‚ä½†è¯´è€å®è¯ä¹Ÿæ˜¯æ— å…³ç—›ç—’çš„ä¼˜ç‚¹ã€‚\nå¹¶ä¸” Typecho å¹¶ä¸å¾ˆé€‚åˆæ™®é€šç”¨æˆ·ä½¿ç”¨ï¼Œå› ä¸ºå¾ˆè½»é‡ï¼Œæ‰€ä»¥åœ¨ç”¨æˆ·ä½“éªŒä¸Šåšçš„ä¹Ÿä¸æ˜¯å¾ˆå¥½ï¼Œä½ ä¼šç»å†ä¸€äº›ç›¸å¯¹å¤æ‚çš„é…ç½®ï¼Œä¸åƒ Wordpress é‚£æ ·ä¸€é”®åˆ°ä½ï¼ŒåŸºæœ¬ä¸éœ€è¦æ¥è§¦ä»£ç å±‚é¢çš„å†…å®¹ã€‚\nä¸è¿‡ Typecho çš„ä¸€äº›ç‰¹æ€§è®©æˆ‘æ•´ä¸€äº›æœ‰è¶£çš„å†…å®¹è¿˜æ˜¯æŒºä¸é”™çš„ï¼Ÿ\nå…³äºå›¾åºŠ å¦‚æœä½¿ç”¨è‡ªå»ºçš„åšå®¢ï¼Œå›¾åºŠæ˜¯ä¸ªæ¯”è¾ƒå¤§çš„é—®é¢˜ã€‚\næˆ‘æ¯”è¾ƒå–œæ¬¢ Upload.cc ï¼Œå…¶æ¬¡æ˜¯ sm.ms ï¼Œå®ƒä»¬å…è´¹ï¼Œè½»é‡ï¼Œè‰¯å¿ƒï¼Œé€Ÿåº¦ä¹Ÿè¿˜ç®—ä¸é”™ã€‚\nå…¶å®ƒçš„æˆ‘å°±ä¸æ¨èäº†ï¼Œå¥‡å¥‡æ€ªæ€ªçš„å›¾åºŠå›½å†…æœ‰ä¸å°‘ã€‚\nå¦‚ä½•æ‰“ä¸€ç›˜æµç•…ï¼Œå¿«é€Ÿè€Œå®Œç¾çš„ CF? å³ç§‘å­¦ä¸Šç½‘ã€‚\nè¿™æ˜¯ç»å¤§å¤šæ•° OIER æ„Ÿå…´è¶£çš„å†…å®¹ï¼Œæ˜¯ä¸€é¡¹å¿…å¤‡æŠ€èƒ½ï¼ˆæ— è®ºä½ æ˜¯è¦ä¸Š Googleï¼Œä¸Š P ç«™ï¼Œä¸Šæ¨ï¼Œä¸Šæ²¹ç®¡è¿˜æ˜¯æµç•…çš„æ‰“ä¸€æŠŠ CFï¼Œè€Œä¸”æˆ‘ä½œä¸º OIER åœ¨ Google ä¸Šèƒ½æœç´¢åˆ°ä¸€äº› baidu ä¸Šæœç´¢ä¸åˆ°çš„å­¦æœ¯ç›¸å…³èµ„æ–™ï¼Œä¹Ÿæ˜¯å¾ˆä¸é”™çš„ï¼‰ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªè¶…çº§å¤§å‘ã€‚æˆ‘ä¸å¸Œæœ›ä»»ä½•äººåœ¨è¿™ä¸Šé¢æŠ˜è…¾å¾ˆä¹…ï¼Œå› ä¸ºæŠ˜è…¾åˆ°æœ€åä½ ä¼šå‘ç°å‰©ä¸‹æ¥çš„ï¼Œå¤§æ¦‚åªä¼šæ˜¯ç©ºè™šã€‚\nä½ åœ¨ MiNa! ä¸Šå¤§æ¦‚ä¹Ÿä¼šçœ‹åˆ° ç›¸å…³å†…å®¹ï¼Œä½†æˆ‘å¿…é¡»è¦æŒ‡å‡ºå‡ å¤„é”™è¯¯é¿å…ä½ é•¿æ—¶é—´çš„æŠ˜è…¾ã€‚\næ¥ä¸‹æ¥çš„å†…å®¹æ¯”è¾ƒæµ…æ˜¾ä½†æ˜¯æˆ‘æŠ˜è…¾è¿™ä¹ˆä¹…ä»¥æ¥çš„ç»éªŒä¹‹è°ˆï¼Œæ¬¢è¿æŒ‡æ­£ã€‚\nVultr? å…³äº Vultr ï¼Œè¿™é‡Œæœ‰å‡ ç‚¹å¿…é¡»è¯´æ˜ã€‚\n ä¸€æ¬¡å……å€¼æœ€ä½é™é¢åç¾å…ƒï¼Œå¯ä»¥ä½¿ç”¨æ”¯ä»˜å®ã€‚ æœåŠ¡å™¨æŒ‰å°æ—¶è®¡è´¹ï¼Œæ³¨æ„ï¼Œå…³æœºä»ç„¶è®¡è´¹ï¼Œé™¤éå°†æ•´ä¸ªæœåŠ¡å™¨åˆ é™¤ï¼ˆè¿™æ„å‘³ç€æ‰€æœ‰æœåŠ¡å™¨å†…çš„æ•°æ®å’Œä½ è¢«åˆ†é…åˆ°çš„ IP éƒ½ä¼šä¸¢å¤±ï¼‰ï¼Œä¸¢å¤±æ•°æ®ä¸æ˜¯å¤§é—®é¢˜ï¼Œå› ä¸ºæœ‰ Snapshot çš„å­˜åœ¨ï¼Œä½†ä¸¢æ‰å¯ç”¨ IPæ˜¯ä¸ªå¤§é—®é¢˜ã€‚ ç”±äº Vultr ä½¿ç”¨äººæ•°è¾ƒå¤šå·²ç»æˆä¸ºäº†é˜²ç«å¢™çš„é‡ç‚¹å…³æ³¨å¯¹è±¡ï¼Œæ‰€ä»¥ä½ ä¼šå‘ç°å¤§éƒ¨åˆ†çš„ IP éƒ½æ— æ³•ä½¿ç”¨ï¼ˆè¡¨ç°ä¸ºæ— æ³• ping é€šï¼Œæ— æ³•è¿æ¥ SSH ç­‰ï¼‰ï¼Œè¿™å°±æ„å‘³ç€ä½ éœ€è¦åŒæ—¶ç”³è¯·å¤šä¸ªæœåŠ¡å™¨æ¥æ‰¾å¯ç”¨ IPï¼Œå¹¶ä¸”å¯èƒ½æ‰¾ä¸åˆ°ã€‚æ¯å¼€ä¸€ä¸ªæœåŠ¡å™¨æˆæœ¬æ˜¯ 0.01 åˆ€ï¼Œæ‰€ä»¥æˆæœ¬è¿˜æ˜¯æœ‰çš„ã€‚ è¯·ä¸è¦ä½¿ç”¨æ—¥æœ¬æœåŠ¡å™¨ã€‚å¯ä»¥å°è¯•æ¯”è¾ƒå°ä¼—åœ°åŒºçš„æœåŠ¡å™¨ï¼Œæˆ–è€…å®ƒä»¬æ–°å¼€çš„ High Frequency æœåŠ¡å™¨ï¼ˆ6 åˆ€/æœˆï¼Œæ¯”æ™®é€šçš„è´µ 1 åˆ€ï¼‰ã€‚  Vultr å…¶å®æˆ‘ç”¨äº†æŒºä¹…çš„ï¼Œä½“éªŒè¿˜å¯ä»¥ï¼Œä½†é«˜å³°æœŸï¼ˆå¤œæ™šï¼‰æ‰åŒ…ä¸¥é‡\u0026hellip; å¹¶ä¸”é«˜å³°æœŸé•¿æ—¶é—´çš„å¤§æµé‡ä¼ è¾“å¯èƒ½ä¼šä½¿ä½ è¢«è¿è¥å•†é™é€Ÿ\u0026hellip;\nç™½å¤©ä½“éªŒè¿˜æ˜¯å¾ˆä¸é”™çš„ï¼Œä½†è¯´ä¸ä¸Šå¿«ã€‚\nSS? SSR? V2Ray? å¯ä»¥è‚¯å®šçš„æ˜¯ç°åœ¨è¿™ä¸¤ä¸ªè½¯ä»¶å¾ˆå¤§å¯èƒ½è¢«ç‰¹å¾è¯†åˆ«äº†ã€‚æ‰€ä»¥æˆ‘ä»¬è¡·å¿ƒä¸å»ºè®®æ²¡æœ‰ä»»ä½•ä¿æŠ¤æªæ–½åœ°ä½¿ç”¨è¿™ä¸¤ä¸ªè½¯ä»¶ï¼ˆåè€…ç”¨ chacha20 ç­‰åŠ å¯†æ–¹å¼å¯èƒ½è¿˜ç¨å¥½ä¸€äº›ï¼‰ã€‚\nä½ å¯ä»¥å°è¯•ä½¿ç”¨ v2ray ï¼Œæ²¡æœ‰ç‰¹æ®Šéœ€æ±‚çš„è¯ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿™ä¸ªäººçš„ ä¸€é”®å®‰è£…è„šæœ¬ ï¼Œè™½ç„¶ä»–é»˜è®¤å±è”½ä¸€äº›ç½‘ç«™ã€‚\nv2ray æˆ‘ä»¬å»ºè®®ä½¿ç”¨ ws+tls çš„åè®®ï¼Œå¦‚æœä½ æœ‰ä¸ªåŸŸåçš„è¯å°±å¥½åŠå¤šäº†ã€‚tls è„šæœ¬ä¼šè‡ªåŠ¨å¸®ä½ é…ç½®å¥½çš„ã€‚\næœ¬æ–‡ç« ä¸è°ˆ VPN ï¼Œä½†å»ºè®®ä¸è¦ä½¿ç”¨å¸¦ VPN ä¸‰ä¸ªå­—çš„ä¸œè¥¿ï¼Œæ— è®ºæ˜¯ä»ç¨³å®šæ€§ï¼Œé€Ÿåº¦è¿˜æ˜¯å®‰å…¨æ€§çš„è§’åº¦ã€‚\nè‡³äº Wireguard, Trojan ç­‰æ›´åŠ å°ä¼—çš„è½¯ä»¶ï¼Œæˆ‘è§‰å¾—æ²¡å¿…è¦ï¼Œæ‰€ä»¥æˆ‘æ²¡æŠ˜è…¾ã€‚\nç°æˆçš„ç½‘ç«™? VPS? ç°æˆçš„ç½‘ç«™ï¼ŒåŸºæœ¬ä¸Šä¾¿å®œä¸å¥½ç”¨ï¼Œå¥½ç”¨ä¸ä¾¿å®œï¼Œå¥½ç”¨ä¾¿å®œæµé‡ä¸å¤Ÿï¼Œå…è´¹çš„åˆä¸å®‰å…¨ã€‚å¹¶ä¸”ä¸ç¨³å®šï¼Œå­˜åœ¨è€æ¿è·‘è·¯çš„å¯èƒ½æ€§ã€‚æ‰€ä»¥æœ‰æ˜¯æœ‰ï¼Œåªè¦èƒ½ä¸Š Google å¤§æ¦‚èƒ½æœåˆ°ä¸€å †ï¼Œä½†å‘æ¯”è¾ƒå¤šã€‚è™½è¯´å¦‚æ­¤ï¼ŒæŠ€æœ¯é—¨æ§›æ˜¯æœ€ä½çš„ï¼Œåªæ˜¯ä¸€ä¸ªé’±çš„é—®é¢˜ã€‚æ¯”å¦‚è¯´ä»€ä¹ˆè“å²¸å•Š\u0026hellip; æˆ‘æ­£åœ¨ç”¨çš„é‚£æ¬¾è€æ¿è·‘è·¯äº†ï¼Œä¸ç¨³å®šï¼Œå°±ä¸æ¨èäº†ã€‚\nVPS çš„è¯ï¼ŒåŸºæœ¬ä¸Šé™¤äº† Vultr éƒ½æ˜¯å¹´ä»˜ï¼Œç”¨ ws+tls èƒ½ä¸€ç›´ä¿æŒç¨³å®šã€‚ä½†ä¸€ä¸ªå¥½ç”¨åˆä¾¿å®œçš„ VPS å¯å°±å¾ˆéš¾æ‰¾äº†\u0026hellip; æ¬ç“¦å·¥æˆ‘ç”¨äº†ï¼ˆæ™®é€š CN2 æ¬¾ï¼‰ï¼Œè§‰å¾—åƒåœ¾ï¼Œé€€æ¬¾äº†ã€‚å¥½ç”¨çš„ä¹Ÿæ˜¯ä¸ä¾¿å®œï¼Œä½†æœ€åè¿˜æ˜¯ç»™æˆ‘æ‰¾åˆ°äº†\u0026hellip; æˆ‘æ­£åœ¨ä½¿ç”¨çš„æ˜¯ TripodCloud çš„ CN2 GIA çº¿è·¯æœåŠ¡å™¨æœ€ä¾¿å®œçš„ä¸€æ¬¾ï¼Œæ¯æœˆæµé‡ 500Gï¼ˆåŒå‘ï¼‰ï¼Œæ¯” Vultr ä¾¿å®œï¼Œé€Ÿåº¦è¿˜æ˜¯å¾ˆå¥½çš„ã€‚é«˜å³°æœŸä¹Ÿä¸æ€ä¹ˆæ‰åŒ…ï¼Œä¹Ÿä¸ä¼šå‡ºç°ç±»ä¼¼ Vultr çš„é™é€ŸçŠ¶å†µã€‚\næˆ‘åªæ˜¯æƒ³æ‰“ä¸ª CFï¼Œéœ€è¦æŠ˜è…¾åˆ°ä»€ä¹ˆç¨‹åº¦ï¼Ÿ å¦‚æœä½ åªæ˜¯æƒ³å¶å°”æ‰“ CF çš„è¯ï¼Œé‚£è¿˜æ˜¯åˆ«æŠ˜è…¾äº†å§ã€‚\næˆ–è€…æ‰¾ä¸ªç½‘ç«™ï¼ŒæŒ‰é‡ä»˜è´¹ã€‚\nå¦‚æœä½ ç»å¸¸ä¸Š Googleï¼Œç»å¸¸ä¸Š CFï¼ˆå¹¶ä¸”é¥±å— CF æ‰çº¿æŠ˜ç£¨ï¼‰ï¼Œæˆ–è€…ä½ æ˜¯ P ç«™ç”¨æˆ·ç»å¸¸æœå›¾ï¼Œæˆ–è€…ä½ å–œæ¬¢çœ‹æ²¹ç®¡ï¼ˆæˆ‘è§‰å¾—æ²¹ç®¡ä¹Ÿæ²¡æ¯” b ç«™å¥½åˆ°å“ªå»ï¼‰ï¼Œæ¯æœˆæœ‰ä¸€å®šä½¿ç”¨é‡ï¼Œé‚£ä½ å¯ä»¥è€ƒè™‘æŠ˜è…¾ä¸ª VPS ç©ç©ã€‚\nå½“ç„¶ï¼Œæƒ³è¦æ‰“ä¸€ç›˜å®Œç¾çš„ CFï¼Œé™¤äº†ç§‘å­¦ä¸Šç½‘ä»¥å¤–ï¼Œä½ è¿˜éœ€è¦æ˜¯ä¸€ä¸ªç¥ä»™ã€‚æ¯•ç«Ÿä¹° iPad Pro ä¸èƒ½è®©ä½ æˆä¸ºéŸ³æ¸¸ç¥ä»™ï¼Œä¹° Apple Pencil å¹¶ä¸èƒ½è®©ä½ æˆä¸ºä¼šç”»å¯çˆ±å¦¹å­çš„ç”»å®¶ï¼Œä¹°åˆ·æ–°ç‡ 144 Hz çš„å±å¹•ä¸èƒ½è®©ä½ æªæªçˆ†å¤´ï¼Œä¹°å¥³è£…ä¹Ÿå¹¶ä¸èƒ½è®©ä½ æˆä¸ºçœŸçš„å¯çˆ±å¦¹å­ï¼ˆï¼Ÿï¼‰ã€‚\nSwitchyOmega? Ubuntu? å¦‚æœä½ è®¨åŒå…¨å±€ä»£ç†ï¼Œä½ å¯èƒ½éœ€è¦è¿™ä¸ªæµè§ˆå™¨æ’ä»¶ã€‚å…³äºå®‰è£… SwitchyOmegaï¼Œä½ å¯ä»¥ç›´æ¥ç”¨ Firefoxï¼Œæˆ–è€…å…ˆå…¨å±€ä»£ç†å†è®¿é—® Chrome åº”ç”¨å•†åº—å®‰è£…ã€‚æœ€ååœ¨æƒ…æ™¯æ¨¡å¼ä¸‹è£…è½½ gfw åˆ—è¡¨çš„ åœ°å€ å°±è¡Œäº†ã€‚\nUbuntuï¼ŸæŠ±æ­‰æˆ‘é€€å½¹å¾ˆä¹…äº†ï¼Œå¿˜è®° Ubuntu çš„æ€ä¹ˆé…ç½®äº†ã€‚è‡ªå·±ä¸Šç½‘æœå§ã€‚\nVPS çš„å…¶å®ƒä½¿ç”¨å§¿åŠ¿ï¼Ÿ æ¯”å¦‚ï¼Œç”¨æ¥å»º MC æœåŠ¡å™¨å•Šï¼ˆä¸å¤ªå¥½ï¼Œä½†æˆ‘è¯•è¿‡ï¼‰ï¼Œç”¨æ¥è·‘ HAH æ¥èµš HATH å•Š (?)ï¼Œç”¨æ¥åšåä»£å•Šï¼ˆè™½ç„¶ä¸€èˆ¬æ˜¯ç”¨äºä¼ªè£…ï¼‰ï¼Œç”¨æ¥æ­åšå®¢å•Šï¼ˆé¡ºä¾¿ä½œä¸ºä¼ªè£…ï¼‰ï¼Œç”¨æ¥åšä¸ªå›¾ç«™å•Š\u0026hellip;\nåæ­£æ˜¯ä½ è‡ªå·±çš„æœåŠ¡å™¨å˜›æƒ³æ€ä¹ˆå¼„æ€ä¹ˆå¼„ã€‚æ‰€ä»¥æˆ‘è¯´å°‘æŠ˜è…¾å˜›ã€‚å¤šå†™é¢˜ã€‚\nè®©ä½ æˆä¸ºç¥ä»™çš„ OIER åˆ©å™¨ (?) ï¼ˆå¾…å¡«å‘ï¼‰\nOIER \u0026amp; IDE ï¼ˆå¾…å¡«å‘ï¼‰\nOIER çš„é«˜é›…è‰ºæœ¯ç”Ÿæ´» Music ï¼ˆå¾…å¡«å‘ï¼‰\nAnime ï¼ˆå¾…å¡«å‘ï¼‰\nGame ï¼ˆå¾…å¡«å‘ï¼‰\n","oriTitle":"æˆ‘ä½œä¸º OIER æ—¶æŠ˜è…¾äº†äº›å•¥ï¼Ÿ","tags":["OI","BLOG","ç§‘å­¦ä¸Šç½‘"],"title":"æˆ‘ä½œä¸º OIER æ—¶æŠ˜è…¾äº†äº›å•¥ï¼Ÿ","uri":"/posts/what_stuff_did_i_do_when_i_was_an_oier/"},{"categories":["solution"],"content":"å–µã€‚\nProblem ç»™å‡ºä¸€å¼ è¢«åˆ’åˆ†å‡ºå¤šä¸ªåŒºåŸŸçš„å¹³é¢å›¾ã€‚åŒºåŸŸæŸ“ä¸åŒé¢œè‰²ä¼šæœ‰ä¸åŒçš„æƒå€¼ï¼Œå¦‚æœç›¸é‚»ä¸¤åŒºåŸŸé¢œè‰²ä¸åŒä¼šäº§ç”Ÿé¢å¤–è´¹ç”¨ã€‚æ±‚æœ€å¤§è´¡çŒ®ã€‚\nSolution å‰ç½®çŸ¥è¯†æ¯”è¾ƒå¤šï¼Ÿ\næè§’æ’åºå’Œæœ€å·¦è½¬çº¿ã€‚æè§’æ’åºå¯ä»¥ç”¨å‡½æ•° atan2(y, x) æ±‚å‡º $\\arctan \\frac{y}{x}$ ï¼Œè¿”å› $[-\\pi, \\pi]$ çš„ç»“æœã€‚å¦‚æœå°äºé›¶å°±åŠ ä¸Šä¸ª $2\\pi$ å§ï¼Œç„¶åæ’åºå°±è¡Œäº†ã€‚\nå› ä¸ºæœ‰å¯èƒ½è¢«å¡ç²¾åº¦ï¼Œä½ ä¹Ÿå¯ä»¥ç”¨è±¡é™æ’åºã€‚å¦‚æœåŒä¸€è±¡é™å°±å‰ç§¯ï¼Œå¦åˆ™æ¯”è±¡é™ã€‚å¤ªéš¾æ‰“å°±æ²¡æ‰“äº†ã€‚\nç„¶åæœ€å·¦è½¬çº¿ç”¨äºæ±‚è¿™ç§å¸¦åæ ‡çš„å¹³é¢å›¾å’Œå¯¹å¶å›¾è½¬åŒ–ã€‚å…·ä½“è¯·å‚è§ miskcoo\u0026rsquo;s Blog ï¼Œè¿™é‡Œè®²å¾—æ¯”è¾ƒå¥½ï¼Œä»£ç ä¹Ÿå†™å¾—å¾ˆå¥½ã€‚\nå°±æ˜¯ç»†èŠ‚ä¸å°‘ã€‚\nç„¶åæˆ‘ä»¬å‘ç°é¢˜é¢çš„æ„æ€å…¶å®åªéœ€è¦æˆ‘ä»¬æ±‚ä¸€ç§åŒ¹é…æ–¹æ¡ˆä½¿å¾— W å’Œ B è¿˜æœ‰ç›¸é‚»äº§ç”Ÿçš„æ€»è´¡çŒ®é‡æœ€å°ï¼Œç„¶åç”¨ W å’Œ B çš„æ€»å€¼å‡å»è¿™ä¸ªå€¼å³å¯ã€‚\nç½‘ç»œæµå˜›ã€‚éšä¾¿è·‘è·‘ã€‚\nCode // Code by ajcxsu // Problem: everfeel #define _USE_MATH_DEFINES #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=4e4+10, M=4e5+10; struct P { int x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } double ang() { double ang=atan2(y, x); if(ang\u0026lt;0) ang+=2.0*M_PI; return ang;} } p[N]; struct Edge { int w, u, v; double ang; } e[M]; vector\u0026lt;int\u0026gt; to[N]; int tp[N]; int ridx, mp; int a[N], b[N], rk[M], bel[M]; int A[M], B[M], tot; void ins(int a, int b, int w) { e[mp++]={w, a, b, (p[b]-p[a]).ang()}; } namespace NS { const int s=N-1, t=N-2; int h[N], to[M], nexp[M], W[M], p=2; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } #define sins(x, y, z) ins(x, y, z), ins(y, x, 0) int fl[N]; bool bfs() { queue\u0026lt;int\u0026gt; qu; qu.push(s); memset(fl, 0, sizeof(fl)); fl[s]=1; while(!qu.empty()) { int na=qu.front(); qu.pop(); for(int u=h[na];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; !fl[to[u]]) fl[to[u]]=fl[na]+1, qu.push(to[u]); } return fl[t]; } #define INF (0x3f3f3f3f) int dfs(int x, int op) { if(x==t) return op; int flow=0; for(int u=h[x];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; fl[to[u]]==fl[x]+1) { int d=dfs(to[u], min(op-flow, W[u])); W[u]-=d, W[u^1]+=d, flow+=d; if(flow==op) break; } if(!flow) fl[x]=0; return flow; } void work() { for(int i=0; i\u0026lt;mp; i+=2) ins(bel[i], bel[i+1], e[i].w), ins(bel[i+1], bel[i], e[i].w); for(int i=1; i\u0026lt;=ridx; i++) sins(s, i, A[i]), sins(i, t, B[i]), tot+=A[i]+B[i]; int flow=0; while(bfs()) flow+=dfs(s, INF); printf(\u0026quot;%d\\n\u0026quot;, tot-flow); } } bool vis[N]; void findreg(int x, int eid) { if(vis[eid]) return; ++ridx; while(!vis[eid]) { vis[eid]=1; bel[eid]=ridx, x=e[eid].v; A[ridx]+=a[x], B[ridx]+=b[x]; if(!rk[eid^1]) eid=to[x].back(); else eid=to[x][rk[eid^1]-1]; } } int main() { #ifndef LOCAL freopen(\u0026quot;everfeel.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;everfeel.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif int num; gn(num); int n, m; gn(n), gn(m); int u, v, w; for(int i=1; i\u0026lt;=n; i++) gn(u), gn(v), p[i]={u, v}, gn(a[i]), gn(b[i]); vector\u0026lt;pair\u0026lt;double, int\u0026gt; \u0026gt; tmp; for(int i=1; i\u0026lt;=m; i++) { gn(u), gn(v), gn(w); ins(u, v, w); ins(v, u, w); } for(int i=0; i\u0026lt;mp; i++) tmp.push_back(make_pair(e[i].ang, i)); sort(tmp.begin(), tmp.end()); for(int i=0; i\u0026lt;mp; i++) { int eid=tmp[i].second; rk[eid]=to[e[eid].u].size(); to[e[eid].u].push_back(eid); } for(int i=1; i\u0026lt;=n; i++) for(int j=0; j\u0026lt;to[i].size(); j++) findreg(i, to[i][j]); NS::work(); return 0; } ","oriTitle":"JZOJ6092 é™„è€³è€Œè‡³","tags":["è®¡ç®—å‡ ä½•","ç½‘ç»œæµ"],"title":"JZOJ6092 é™„è€³è€Œè‡³","uri":"/posts/sol-jzoj-6092/"},{"categories":["solution"],"content":"è½¬åŒ–æ¯”è¾ƒå·§å¦™ï¼Œè€ƒåœºä¸Šæƒ³å‚»é€¼äº†çš„é¢˜ç›®ã€‚å¾ˆå¥½æ‰“ã€‚\nProblem ç»™å®šä¸€æ£µåªæœ‰ä¸€ä¸ªç‚¹çš„æ ‘ï¼Œ1e5æ¬¡æ“ä½œï¼Œæ¯æ¬¡åŠ ä¸€ä¸ªç‚¹åé—®è‡³å¤šäº¤æ¢ä¸€æ¬¡ä¸¤æ£µå­æ ‘åçš„æœ€å¤§ç›´å¾„é•¿åº¦ã€‚å¼ºåˆ¶åœ¨çº¿ã€‚\nSolution è€ƒè™‘äº‹å®ä¸Šå°±æ˜¯æŠŠç›´å¾„ä¸Šçš„é“¾å‰–å‡ºç„¶åè¯¢é—®æœ€é•¿æ”¯é“¾çš„é•¿åº¦ $lp$ ï¼Œç­”æ¡ˆå°±æ˜¯ $d+max(lp-1, 0)$ ã€‚\né‚£ä¹ˆè€ƒè™‘æ¯æ¬¡åŠ å…¥ä¸€ä¸ªç‚¹ä¹‹åç›´å¾„å’Œæœ€é•¿æ”¯é“¾çš„å˜åŒ–ã€‚å¦‚æœç›´å¾„å˜åŒ–ï¼Œè€ƒè™‘å¦ä¸€æ¡è¢«æ¢ä¸‹æ¥çš„æ”¯é“¾ä¸€å®šæ˜¯è¿™æ¡åŸæ”¯é“¾çš„ç°é•¿åº¦-1ã€‚é‚£ä¹ˆå¦‚æœåŸæ”¯é“¾çš„åŸé•¿åº¦å°±æ˜¯æœ€é•¿æ”¯é“¾ï¼Œå°±ç›´æ¥è€ƒè™‘å¦ä¸€æ¡è¢«æ¢ä¸‹æ¥çš„æ”¯é“¾æ›´æ–°æœ€é•¿æ”¯é“¾å³å¯ã€‚å¦‚æœä¸æ˜¯æœ€é•¿æ”¯é“¾ï¼Œé‚£ä¹ˆç†è®ºä¸Šæœ€é•¿æ”¯é“¾æ˜¯ä¸ä¼šå˜åŒ–çš„ï¼Œä½†æ˜¯ä¸ºäº†é¿å…å¥‡æ€ªçš„é”™è¯¯æˆ‘ä»¬è¿˜æ˜¯è¦æ›´æ–°ä¸€ä¸‹æœ€é•¿æ”¯é“¾çš„ç‚¹ã€‚\nå¦‚æœç›´å¾„ä¸å˜åŒ–ï¼Œé‚£ä¹ˆç›´æ¥ç”¨æ–°åŠ çš„ç‚¹æ›´æ–°æœ€é•¿æ”¯é“¾å³å¯ã€‚\nå€å¢ç»´æŠ¤ã€‚\nCode // Code by ajcxsu // Problem: forest #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10, OP=19; int gup[OP][N], dep[N]; void add(int x, int fa) { gup[0][x]=fa, dep[x]=dep[fa]+1; for(int j=1; j\u0026lt;OP; j++) gup[j][x]=gup[j-1][gup[j-1][x]]; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } int dis(int s, int t) { return dep[s]+dep[t]-2*dep[lca(s, t)]; } int u=1, v=1, p=1, fa, len, lp, lst; int cac(int x) { return dis(x, u)+dis(x, v)-len\u0026gt;\u0026gt;1; } int main() { #ifndef LOCAL freopen(\u0026quot;forest.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;forest.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif dep[1]=1; int n, tod; gn(n), gn(n); int tmp; for(int i=2; i\u0026lt;=n; i++) { gn(fa), fa^=lst; add(i, fa); int la=dis(u, i), lb=dis(v, i); if(la\u0026gt;len || lb\u0026gt;len) { if(la\u0026gt;lb) tod=v, v=i, len=la; else tod=u, u=i, len=lb; if((tmp=cac(tod))\u0026gt;lp) lp=tmp, p=tod; } else if(((la+lb-len)\u0026gt;\u0026gt;1)\u0026gt;lp) lp=(la+lb-len)\u0026gt;\u0026gt;1, p=i; printf(\u0026quot;%d\\n\u0026quot;, lst=len+max(lp-1, 0)); } return 0; } ","oriTitle":"JZOJ6096 æ£®æ—","tags":["å€å¢","æ ‘çš„ç›´å¾„"],"title":"JZOJ6096 æ£®æ—","uri":"/posts/sol-jzoj-6096/"},{"categories":["solution"],"content":"è°ƒè°ƒæ”¹æ”¹äº†ä¸€æ™šä¸Šæ‰è¿‡æ‰ã€‚æ€»è€Œè¨€ä¹‹è¿˜æ˜¯è‡ªå·±å¯¹é¢˜ç›®ç†è§£å¤ªä¸æ·±åˆ»äº†ã€‚åŸºæœ¬ä¸Šæ˜¯å¯¹ç€æŠ„ä½†æ˜¯åˆæŠ„å¾—å¾ˆæ— å¥ˆã€‚\nSolution ä¸è€ƒè™‘åŒºé—´é™åˆ¶çš„è¯ï¼Œåˆ™ $S, T$ åŒæ—¶åŒ¹é…ã€‚å¦‚æœ $S$ å‘ $c$ è¾¹è½¬ç§»å‡ºç°äº†ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°† $S$ å‘ä¸Šè·³åˆ°åŒ¹é…ä¸ºæ­¢ï¼ŒåŒæ—¶ $T$ ä¹Ÿåº”è¯¥å‘ä¸Šè·³ä½¿å¾— $len$ ä¸ç°å¤„çš„çŠ¶æ€ç›¸ç¬¦ã€‚\nè€ƒè™‘åŒºé—´é™åˆ¶çš„è¯ï¼Œæˆ‘ä»¬ä½¿ç”¨çº¿æ®µæ ‘åˆå¹¶ç»´æŠ¤æ ‘çš„ $endpos$ é›†åˆã€‚é‚£ä¹ˆå¯¹äºå·²ç»å›ºå®šäº†çš„å­—ç¬¦ä¸²é•¿åº¦ $l\u0026rsquo;$ ï¼Œéœ€è¦åŠ ä¸Šå­—ç¬¦ $c$ ï¼Œè¦æ±‚ $S$ è½¬ç§»åæ‰€å¤„çŠ¶æ€çš„ $endpos$ å­˜åœ¨äº $[l+l\u0026rsquo;, r]$ ã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦å°† $l\u0026rsquo;$ ä¸€æ­¥æ­¥å‡å° æ¥æŸ¥çœ‹æ˜¯å¦åŒ¹é…ã€‚å½“ $l\u0026rsquo;=len[fa[p]]$ æ—¶éœ€è¦å°† $p$ å‘ä¸Šè½¬ç§»ã€‚\næˆ‘ä»¬åŒæ—¶éœ€è¦æ„è¯†åˆ°æˆ‘ä»¬å¯ä»¥åœ¨ $S$ çš„ parent æ ‘ä¸Šç›´æ¥è½¬ç§»ï¼Œä¸”è½¬ç§»åˆ°çš„èŠ‚ç‚¹çš„ $len$ æ˜¯ç¬¦åˆå‡æƒ³åŒºé—´ parent æ ‘æ„é€ çš„ï¼ˆæˆ–è€…ç•¥å¤§ï¼Œä½†å¦‚æœå‘ä¸Šè·³ä¸€å®šç¬¦åˆï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬è½¬ç§»åˆ°çš„çŠ¶æ€ä¸€å®šåœ¨åŒºé—´ parent æ ‘ä¸Šå­˜åœ¨ã€‚è¿™éƒ¨åˆ†æˆ‘è§‰å¾—æˆ‘å¯èƒ½è¿˜éœ€è¦å†åŠ æ·±ç†è§£ã€‚\nå£èƒ¡ä¸€ä¸‹ï¼šå¯¹äºSAMï¼Œå¦‚æœä»çŠ¶æ€ $A$ è½¬ç§»åˆ°çŠ¶æ€ $B$ ï¼Œä½ éœ€è¦ä¿è¯å¦‚ä¸‹æ¡ä»¶ï¼š$endpos$ é›†åˆå­˜åœ¨ï¼Œä¸” $len\u0026rsquo;$ å±äºç»“ç‚¹æ‰€å± $len$ åŒºé—´ã€‚ç”±äº $len\u0026rsquo;=len+1$ ï¼Œæ‰€ä»¥åªéœ€è¦ä¿è¯ $endpos$ åˆæ³•å³å¯ã€‚\nCode // Code by ajcxsu // Problem: yourname. #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=3e6+10, M=5e7+10; struct Node { int ch[26]; int len, fa; void clr() { len=fa=0; memset(ch, 0, sizeof(ch)); } } ; struct Tree *nil; struct Tree { int v, t; Tree *ls, *rs; } po[M], *pp=po; void ini() { nil=pp++; nil-\u0026gt;ls=nil-\u0026gt;rs=nil; } Tree* newn() { assert(pp!=po+M), *pp=*nil; return pp++; } void updata(Tree *\u0026amp;x, int l, int r, int d) { if(x==nil) x=newn(); x-\u0026gt;v=max(x-\u0026gt;v, d); if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d); else updata(x-\u0026gt;rs, mid+1, r, d); } Tree* Merge(Tree *x, Tree *y) { Tree *o=newn(); if(x==nil || y==nil) return x==nil?y:x; o-\u0026gt;v=max(x-\u0026gt;v, y-\u0026gt;v); o-\u0026gt;ls=Merge(x-\u0026gt;ls, y-\u0026gt;ls), o-\u0026gt;rs=Merge(x-\u0026gt;rs, y-\u0026gt;rs); return o; } int query(Tree *x, int l, int r, int xr) { if(r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=query(x-\u0026gt;ls, l, mid, xr); if(xr\u0026gt;mid) ret=max(ret, query(x-\u0026gt;rs, mid+1, r, xr)); return ret; } typedef long long ll; struct SAM { Node nd[N]; int idx=1, lst=1; int g[N]; Tree *tr[N]; void add(int c, int mode) { int p=lst, np=lst=++idx; nd[np].clr(), nd[np].len=nd[p].len+1; if(mode) updata(tr[idx], 0, N, nd[np].len); for(; p \u0026amp;\u0026amp; !nd[p].ch[c]; p=nd[p].fa) nd[p].ch[c]=np; if(!p) nd[np].fa=1; else { int q=nd[p].ch[c]; if(nd[q].len==nd[p].len+1) nd[np].fa=q; else { int nq=++idx; nd[nq]=nd[q]; nd[nq].len=nd[p].len+1, nd[q].fa=nd[np].fa=nq; for(; p \u0026amp;\u0026amp; nd[p].ch[c]==q; p=nd[p].fa) nd[p].ch[c]=nq; } } } int id[N], bu[N]; void sort() { fill(bu, bu+idx+1, 0); // !! for(int i=1; i\u0026lt;=idx; i++) bu[nd[i].len]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[nd[i].len]--]=i; } ll ftot; void ini1() { for(int i=idx; i\u0026gt;=2; i--) ftot+=nd[i].len-nd[nd[i].fa].len; } void ini2() { for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; tr[nd[tmp].fa]=Merge(tr[nd[tmp].fa], tr[tmp]); } } char str[N]; int n; void ini(int mode=0) { idx=lst=1; ftot=0; n=strlen(str); if(mode) fill(tr, tr+N, nil); nd[1].clr(); for(int i=0; i\u0026lt;n; i++) add(str[i]-'a', mode); sort(); fill(g, g+idx+1, 0); if(!mode) ini1(); else ini2(); } ll deal() { ll cnt=0; for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; g[tmp]=min(g[tmp], nd[tmp].len); g[nd[tmp].fa]=max(g[nd[tmp].fa], g[tmp]); cnt+=max(g[tmp]-nd[nd[tmp].fa].len, 0); // å¿˜å–maxäº†... } return ftot-cnt; } inline int mov(int x, char ch) { return nd[x].ch[ch-'a']; } } s, t; int main() { ini(); scanf(\u0026quot;%s\u0026quot;, s.str); s.ini(1); int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int l, r; while(T--) { scanf(\u0026quot;%s%d%d\u0026quot;, t.str, \u0026amp;l, \u0026amp;r); t.ini(); int na=1, nb=1, len=0, to; bool chg; for(int i=0; i\u0026lt;t.n; i++) { to=s.mov(na, t.str[i]); nb=t.mov(nb, t.str[i]); chg=0; while(na \u0026amp;\u0026amp; (!to || query(s.tr[to], 0, N, r)\u0026lt;l+len)) { if(!len) { na=0; break; } len--; if(len==s.nd[s.nd[na].fa].len) na=s.nd[na].fa, to=s.mov(na, t.str[i]); } if(!na) na=1, len=0; else na=to, len++; while(nb \u0026amp;\u0026amp; t.nd[t.nd[nb].fa].len\u0026gt;=len) nb=t.nd[nb].fa; nb+=!nb; t.g[nb]=max(t.g[nb], len); } printf(\u0026quot;%lld\\n\u0026quot;, t.deal()); } return 0; } ","oriTitle":"NOI2018 ä½ çš„åå­—","tags":["SAM","çº¿æ®µæ ‘åˆå¹¶"],"title":"NOI2018 ä½ çš„åå­—","uri":"/posts/sol-your-name/"},{"categories":["solution"],"content":"å¸¸æ•°åˆ¶é€ æœº\u0026hellip;\nSolution è€ƒè™‘ä¸é‡å¤çš„è®¡ç®—è´¨å› æ•°ã€‚ä»¤ ${p_i}^{k_i}$ å½¢å¼çš„è´¨å› æ•°æˆä¸ºä¸€ç§é¢œè‰²ï¼Œè´¡çŒ®ä¸º $p$ ï¼Œåˆ™æœ€å¤šå¯åˆ†å‰²å‡º $n\\log V$ ç§é¢œè‰²ï¼Œç°åœ¨è¦åšçš„æ˜¯å¯¹é™å®šæ·±åº¦ä¸é‡å¤è®¡ç®—é¢œè‰²çš„è´¡çŒ®ã€‚\né‚£ä¹ˆå¯¹æ·±åº¦è®¾ä¸»å¸­æ ‘ï¼ˆæ¯ä¸€å±‚çš„è¯æ˜¯åŠ¨æ€å¼€ç‚¹ï¼‰ï¼Œç„¶åå¯¹æ¯ä¸ªé¢œè‰²è®¡ç®—æ ‘ä¸Šå·®åˆ†è¿›è¡Œè´¡çŒ®ã€‚åŒæ—¶å¯¹äºæ¯ä¸ªé¢œè‰²è®°å½•ä¸€ä¸ª set æ¥ç»´æŠ¤å·²å‡ºç° dfn åºï¼Œå¦‚æœæ–°åŠ å…¥äº†ä¸€ä¸ªé¢œè‰²åœ¨æ ‘ä¸Šè®¡ç®—ä¸ dfs åºç›¸é‚»çš„å·²å‡ºç°çš„ç‚¹çš„è´¡çŒ®çš„å˜åŒ–é‡ã€‚æŸ¥è¯¢çš„æ—¶å€™ç›´æ¥åœ¨ä¸»å¸­æ ‘ä¸ŠæŸ¥è¯¢å³å¯ã€‚\nå¤æ‚åº¦å¤§æ¦‚æ˜¯ $\\log^2$ çº§åˆ«ï¼Ÿç©ºé—´å¤æ‚åº¦æ˜¯ç„å­¦\u0026hellip;\nCode // Code by ajcxsu // Problem: half #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int K=1e7+10, N=1e5+10, OP=19; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } typedef pair\u0026lt;int, int\u0026gt; mpa; int dep[N], dl[N], dr[N], dd[N], idx; int gup[OP][N]; void dfs(int x, int k) { dep[x]=k, dl[x]=++idx, dd[idx]=x; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { dfs(to[u], k+1); gup[0][to[u]]=x; } dr[x]=idx; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } struct Dot { int x, k, i; } ; bool cmp(const Dot \u0026amp;a, const Dot \u0026amp;b) { return dep[a.x]\u0026lt;dep[b.x]; } vector\u0026lt;Dot\u0026gt; dot; vector\u0026lt;mpa\u0026gt; lis; int val[N]; int pri[K], pre[K], inv[K], pp; bool npri[K]; void di(int x, int y) { int k=0, rua=0; while(x\u0026gt;1) { if(rua!=pre[x]) rua=pre[x], k=0; k++; lis.push_back(mpa(rua, k)); dot.push_back({y, rua, k}); x/=rua; } } struct Node *nil; struct Node { Node *ls=nil, *rs=nil; int v=1, t=0; } ; Node *nd[N]; void ini() { nil=new Node, nil-\u0026gt;ls=nil-\u0026gt;rs=nil; nd[0]=nil; } void updata(Node *\u0026amp;x, int l, int r, int d, int v, int nt) { if(x-\u0026gt;t!=nt) { Node *nd=new Node; *nd=*x, x=nd; x-\u0026gt;t=nt; } x-\u0026gt;v=1ll*x-\u0026gt;v*v%MOD; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d, v, nt); else updata(x-\u0026gt;rs, mid+1, r, d, v, nt); } int query(Node *x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=1; if(xl\u0026lt;=mid) ret=1ll*ret*query(x-\u0026gt;ls, l, mid, xl, xr)%MOD; if(xr\u0026gt;mid) ret=1ll*ret*query(x-\u0026gt;rs, mid+1, r, xl, xr)%MOD; return ret; } set\u0026lt;int\u0026gt; s[N*25]; int main() { #ifndef LOCAL freopen(\u0026quot;half.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;half.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif ini(); ios::sync_with_stdio(false), cin.tie(0); /* pri inv */ inv[1]=1; for(int i=2; i\u0026lt;K; i++) inv[i]=(MOD-1ll*MOD/i*inv[MOD%i]%MOD); npri[1]=1; for(int i=2; i\u0026lt;K; i++) { if(!npri[i]) pri[pp++]=i, pre[i]=i; for(int j=0; j\u0026lt;pp \u0026amp;\u0026amp; i*pri[j]\u0026lt;K; j++) { npri[i*pri[j]]=1, pre[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; } } /* input */ int k, n; gn(k), gn(n); int na; for(int i=1; i\u0026lt;=n; i++) { gn(na); di(na, i); } int u, v; for(int i=1; i\u0026lt;n; i++) gn(u), gn(v), ins(u, v), ins(v, u); /* up */ dfs(1, 1); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; /* lis */ sort(lis.begin(), lis.end()); int tk=unique(lis.begin(), lis.end())-lis.begin(); for(int i=0; i\u0026lt;tk; i++) val[i]=lis[i].first; for(Dot \u0026amp;x:dot) x.k=lower_bound(lis.begin(), lis.begin()+tk, mpa(x.k, x.i))-lis.begin(); sort(dot.begin(), dot.end(), cmp); /* add */ int j=0; int nx, nc, mdep=dep[dot.rbegin()-\u0026gt;x]; for(int i=1; i\u0026lt;=mdep; i++) { nd[i]=nd[i-1]; while(j\u0026lt;dot.size() \u0026amp;\u0026amp; dep[dot[j].x]\u0026lt;=i) { nx=dot[j].x, nc=dot[j].k; auto it=s[nc].lower_bound(dl[nx]); int rx=(it==s[nc].end()?-1:dd[*it]); int lx=(it==s[nc].begin()?-1:dd[*(--it)]); updata(nd[i], 1, n, dl[nx], val[nc], i); if(rx!=-1 \u0026amp;\u0026amp; lx!=-1) updata(nd[i], 1, n, dl[lca(lx, rx)], val[nc], i); if(lx!=-1) updata(nd[i], 1, n, dl[lca(lx, nx)], inv[val[nc]], i); if(rx!=-1) updata(nd[i], 1, n, dl[lca(nx, rx)], inv[val[nc]], i); s[nc].insert(dl[nx]); j++; } } /* query */ int q, lstans=0; gn(q); while(q--) { gn(u), gn(v), u=u^(k*lstans), v=v^(k*lstans); printf(\u0026quot;%d\\n\u0026quot;, lstans=query(nd[min(dep[u]+v, mdep)], 1, n, dl[u], dr[u])); } return 0; } ","oriTitle":"JZOJ6086 åŠ¨æ€åŠå¹³é¢äº¤","tags":["STL","ä¸»å¸­æ ‘"],"title":"JZOJ6086 åŠ¨æ€åŠå¹³é¢äº¤","uri":"/posts/sol-jzoj-6086/"},{"categories":["algorithm"],"content":"qia ke è¿˜æ˜¯ ka qiao ï¼Ÿ\nå‡¸åŒ… å¯¹å‘é‡ $\\vec{a} \\times \\vec{b}$ çš„è¿ç®—çš„æ­£è´Ÿå€¼ç”± $\\vec{a}$ æ—‹è½¬åˆ° $\\vec{b}$ çš„è§’åº¦çš„ $\\cos$ å†³å®šï¼ˆå«æ­£è´Ÿå·ï¼‰ã€‚å› æ­¤å¦‚æœ $\\vec{a}$ åˆ° $\\vec{b}$ æ˜¯é€†æ—¶é’ˆæ—‹è½¬å®ƒä»¬çš„å‰ç§¯å°±æ˜¯æ­£æ•°ï¼Œå¦åˆ™åä¹‹ã€‚\né‚£ä¹ˆ $x$ æ’åºåå·¦å³é¡ºåºæ‰«ä¸€éä¸Šä¸‹å‡¸åŒ…ã€‚å¯¹äºæŒ‰é¡ºåºæ„æˆå‡¸åŒ…çš„å‘é‡ï¼Œä¸€å®šæ˜¯é¡ºæ—¶é’ˆæ—‹è½¬ï¼Œå¦åˆ™ä¾¿ä¸ç¬¦åˆå‡¸åŒ…çš„å®šä¹‰ã€‚å› æ­¤ä½¿ç”¨æ ˆæ¥ç»´æŠ¤ï¼Œå¦‚æœå‡ºç°äº†é€†æ—¶é’ˆæ—‹è½¬åˆ™é€€æ ˆã€‚\nè¢«ç§°ä½œ Graham Scan ç®—æ³•ã€‚\næ³¨æ„ä¸€äº›é‡å¤ç‚¹çš„ç»†èŠ‚ã€‚\næ—‹è½¬å¡å£³ ç”¨äºè®¡ç®—å‡¸åŒ…ç‚¹å¯¹çš„æœ€é•¿è·ç¦»ã€‚è€ƒè™‘æšä¸¾ä¸€æ¡è¾¹ï¼Œå†è€ƒè™‘è¯¥è¾¹çš„å¯¹è¸µç‚¹ï¼ˆè·ç¦»è¯¥è¾¹è·ç¦»æœ€å¤§ç‚¹ï¼‰ï¼Œæšä¸¾è¿™æ ·æ‰€æœ‰çš„ç‚¹è¾¹å¯¹å³å¯è·å–æœ€é•¿è·ç¦»ã€‚å¯ä»¥ $O(n)$ æ‰«è¿‡ï¼Œè€Œä¸”è¯¯å·®è¾ƒå°ã€‚\næ³¨æ„ä¸€äº›ç»†èŠ‚ï¼ŒåŒæ—¶ç‰¹åˆ¤å‡¸åŒ…å¤§å°ä¸º $3$ çš„æƒ…å†µï¼Œè¿™æ„å‘³ç€æ‰€æœ‰ç‚¹éƒ½å¤„äºåŒä¸€ç›´çº¿ä¸Šã€‚\nCode - Beauty Contest // Code by ajcxsu // Problem: xuan zhuan qia qiao #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5e4+10; typedef long long ll; struct P { ll x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } ll norm() { return x*x+y*y; } double dis() { return sqrt(norm()); } } p[N], con[N]; ll cross(P a, P b) { return a.x*b.y-a.y*b.x; } bool cmp(const P \u0026amp;a, const P \u0026amp;b) { return a.x==b.x?a.y\u0026lt;b.y:a.x\u0026lt;b.x; } inline ll dpow(ll x) { return x*x; } double dis(P a, P b, P x) { return (double)abs(cross(a-x, b-x))/(a-b).dis(); } int t; int main() { ios::sync_with_stdio(false), cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;p[i].x\u0026gt;\u0026gt;p[i].y; sort(p+1, p+1+n, cmp); for(int i=1; i\u0026lt;=n; i++) { while(t\u0026gt;=2 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } int t2=t; for(int i=n-1; i\u0026gt;=1; i--) { while(t\u0026gt;=t2+1 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } if(t==3) cout\u0026lt;\u0026lt;(con[1]-con[2]).norm()\u0026lt;\u0026lt;endl, exit(0); int nt=1; ll ans=0; for(int i=1; i\u0026lt;t; i++) { while(dis(con[i], con[i+1], con[nt])\u0026lt;=dis(con[i], con[i+1], con[nt+1])) nt=nt%(t-1)+1; ans=max({ans, (con[i]-con[nt]).norm(), (con[i+1]-con[nt]).norm()}); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"å‡¸åŒ…ä¸æ—‹è½¬å¡å£³","tags":["è®¡ç®—å‡ ä½•","å‡¸åŒ…","æ—‹è½¬å¡å£³"],"title":"å‡¸åŒ…ä¸æ—‹è½¬å¡å£³","uri":"/posts/convex-hull-and-qia-qiao/"},{"categories":["solution"],"content":"Problem ç»™å®š $n$ ï¼Œæ±‚æœ‰å¤šå°‘ä¸ª $1\\to n$ çš„æ’åˆ—å¯ä»¥åˆ†å‰²æˆä¸‰ä¸ªä¸Šå‡å­åºåˆ—ã€‚$n \\leq 500$ã€‚\nSolution å‡è®¾ç»™å®šä¸€ä¸ªæ’åˆ—ï¼Œé‚£ä¹ˆæˆ‘ä»¬è´ªå¿ƒçš„ä»å‰å¾€åé€‰ï¼Œç»´æŠ¤ä¸‰ä¸ªä¸Šå‡åºåˆ—ï¼Œæ¯æ‰«åˆ°ä¸€ä¸ªæ•°å­—æ·»åŠ åˆ°èƒ½æ”¾çš„ä¸Šå‡åºåˆ—ä¸”ä¿è¯åŸä¸Šå‡åºåˆ—çš„æœ€å¤§å€¼å°½é‡å¤§ã€‚è¿™æ ·ä¸€å®šèƒ½æ„é€ å‡ºä¸€ç§åˆæ³•æ–¹æ¡ˆï¼ˆå¦‚æœæœ‰ï¼‰ä¸”åˆ†å‰²æ–¹æ¡ˆå”¯ä¸€ã€‚\nè€ƒè™‘ä¸‰ä¸ªåºåˆ—çš„æœ€å¤§å€¼è®¾è®¡çŠ¶æ€ã€‚ç”±äºä¸æ¸…æ¥šæ’å…¥çš„æ•°å…·ä½“æ˜¯ä»€ä¹ˆï¼Œæˆ‘ä»¬ä»¤å…¶ä¸ºç›¸å¯¹å¤§å°ï¼š $f_{i, j, k}$ ï¼Œä¸”ä»¤ $i\u0026gt;j\u0026gt;k\\geq 0$ ã€‚åŒæ—¶å­˜åœ¨ $j=k=0$ çš„æƒ…å†µã€‚\né‚£ä¹ˆæˆ‘ä»¬æ’å…¥ä¸€ä¸ªæ–°çš„ç›¸å¯¹å¤§å°ä¸º $l \\in [1, i+1]$ çš„å€¼ã€‚é‚£ä¹ˆåŸç›¸å¯¹å¤§å°å¤„äº $[l, i]$ åŒºé—´çš„å€¼éƒ½ä¼šè¢«å¾€åé¡¶æˆ $[l+1, i+1]$ ã€‚åˆ™æˆ‘ä»¬åˆ†æƒ…å†µè®¨è®º $l$ çš„è½¬ç§»ï¼š\n$$ f_{i, j, k} \\rightarrow \\begin{cases} f_{i+1, j+1, l} \u0026amp; \\text{for } k\u0026lt;l\\leq j\\\\ f_{i+1, l, k} \u0026amp; \\text{for }j\u0026lt;l \\leq i\\\\ f_{i+1, j, k} \u0026amp; \\text{for }l=i+1 \\end{cases} $$\nå·®åˆ†å³å¯ä¼˜åŒ–åˆ° $O(n^3)$ ã€‚\nCode #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=501; int f[2][N][N], g[2][N][N]; int u, v=1; int n, P; int add(int \u0026amp;x, int y) { x+=y; if(x\u0026gt;=P) x-=P; return x; } int main() { freopen(\u0026quot;yuan.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;yuan.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); ios::sync_with_stdio(false), cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;P; f[v][0][0]=1; int ans=0; for(int i=1; i\u0026lt;=n; i++) { u^=1, v^=1; for(int j=0; j\u0026lt;i-1;j++) for(int k=0; k\u0026lt;=j; k++) f[v][j][k]=g[v][j][k]=0; for(int j=0; j\u0026lt;i-1; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j+1][k+1],f[u][j][k]), add(f[v][j+1][j+1],-f[u][j][k]), add(g[v][j+1][k],f[u][j][k]), add(g[v][i][k],-f[u][j][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j][k],f[v][j][k-1]), add(g[v][j][k],g[v][j-1][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) { add(f[v][j][k],add(g[v][j][k],f[u][j][k])); if(i==n) add(ans, f[v][j][k]); } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"JZOJ2090 åœ†","tags":["DP"],"title":"JZOJ2090 åœ†","uri":"/posts/sol-jzoj-2090/"},{"categories":["solution"],"content":"å¥½é¢˜å¥½åšæ³•\u0026hellip;\næ„Ÿè°¢ gjx çš„è®²è§£ã€‚\nSolution è¦ç”¨åˆ°çš„ç»“è®ºï¼š $\\frac{1}{a}\\frac{1}{b}=(\\frac{1}{a}-\\frac{1}{b})\\frac{1}{b-a}$ ã€‚\næˆ‘ä»¬è¦æ±‚çš„å°±æ˜¯ä¸‹é¢è¿™ä¸ªç”Ÿæˆå‡½æ•°çš„ç¬¬ $n$ é¡¹ï¼š $$\\prod \\limits_{i=1}^{m} \\frac{1}{1-(ui+v)x}$$\nä¸Šé¢è¿™ä¸ªç”Ÿæˆå‡½æ•°å¯ä»¥åŒ–ä¸ºè¿™æ ·çš„å½¢å¼ï¼š $$(\\frac{1}{ux})^{m-1} \\sum \\limits_{i=1}^m \\frac{a_i}{1-(ui-v)x}$$\nå…¶ä¸­ $a_i$ æ˜¯è¯¥é¡¹çš„ä¸å®šç³»æ•°ã€‚\nè‡³äºä¸ºä»€ä¹ˆæ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬ä¸‹é¢ç»§ç»­ã€‚\nä»¤ $p_i=1-(ui+v)x$ ã€‚æˆ‘ä»¬ä» $1\\to m$ å¤„ç†è¿™ä¸ªç”Ÿæˆå‡½æ•°ï¼Œå³å‡è®¾æˆ‘ä»¬å·²ç»æ±‚å‡ºäº† $1\\to m$ çš„ç”Ÿæˆå‡½æ•°ï¼Œç„¶åæˆ‘ä»¬è¦æŠŠè¿™ä¸ªå‡½æ•°ä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{p_{m+1}}$ æ¥æ¨å‡º $1\\to m+1$ çš„ç”Ÿæˆå‡½æ•°ã€‚\né‚£æˆ‘ä»¬è€ƒè™‘å¯¹äºç¬¬äºŒç§å½¢å¼çš„ç”Ÿæˆå‡½æ•°çš„æ¯ä¸ª $i$ ï¼Œä¹˜ä¸Šè¿™ä¸ªä¹‹åçš„å˜åŒ–ã€‚\nå³ï¼š $$\\frac{a_i}{p_i}\\frac{1}{p_{m+1}} = a_i(\\frac{1}{p_i}-\\frac{1}{p_{m+1}})\\frac{1}{u(i-m-1)x}$$\næ­¤æ—¶æˆ‘ä»¬å‘ç°å¯¹äºæ¯ä¸€é¡¹éƒ½ä¼šå¤šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux}$ ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å…¶æ•´ä½“æå‡ºï¼Œå˜æˆä¸Šé¢ç”Ÿæˆå‡½æ•°çš„å½¢å¼ã€‚\næˆ‘ä»¬è€ƒè™‘ç¬¬ä¸€æ¬¡æ’å…¥ $\\frac{1}{p_{i}}$ è¿™ä¸€é¡¹ä¹‹åï¼Œä»¤å®ƒçš„ç³»æ•°ä¸º $f_i$ ã€‚é‚£ä¹ˆåœ¨æ’å…¥ $i+1$ é¡¹æ—¶ï¼Œ$f_i$ ä¼šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux(-1)}$ ï¼Œæ’å…¥ç¬¬ $i+2$ é¡¹æ—¶ä¼šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux(-2)}$ ã€‚æˆ‘ä»¬æƒŠè®¶çš„å‘ç°æœ‰ï¼š $$a_i=(\\frac{1}{ux})^{m-i}(-1)^{m-i}\\frac{1}{(m-i)!}f_i$$\nå†è€ƒè™‘ $f_{m+1}$ çš„å€¼ï¼š $$f_{m+1}=\\sum \\limits_{i=1}^{m} (-1)^{m-i}\\frac{1}{(m+1-i)!}f_i$$\næˆ‘ä»¬è€ƒè™‘ $f_i$ çš„ç”Ÿæˆå‡½æ•°ä¸º $F$ ï¼Œåˆ™æœ‰ï¼š $$F=F*(-e^{-x}+1)+x \\Rightarrow F=xe^x$$\nåˆ™æˆ‘ä»¬å¯ä»¥å¾—åˆ°æœ€ç»ˆç”Ÿæˆå‡½æ•°çš„æ¯ä¸€éƒ¨åˆ†çš„ç¬¬ $n$ é¡¹çš„å’Œï¼š $$\\sum \\limits_{i=1}^{m} (ui+v)^{n+m-1} u^{-m+1} (-1)^{m-i} \\frac{1}{(m-i)!} f_i$$\nå¤æ‚åº¦ $O(m\\log n)$ ã€‚\nCode // Code by ajcxsu // Problem: IOer #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353ll) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10; typedef long long ll; ll finv[N], f[N]; ll qpow(ll x, ll y) { ll ret=1; while(y) { if(y\u0026amp;1) ret=ret*x%MOD; x=x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } ll n, m, u, v; ll pl[]={1, -1}; int solve() { int ans=0; ll invu=qpow(u, (MOD-2)*(m-1)); for(int i=1; i\u0026lt;=m; i++) ans=(ans+qpow((u*i+v)%MOD, n+m-1)*invu%MOD*f[i]%MOD*pl[(m-i)\u0026amp;1]*finv[m-i]%MOD+MOD)%MOD; return ans; } int main() { finv[0]=finv[1]=1; for(int i=2; i\u0026lt;N; i++) finv[i]=MOD-1ll*MOD/i*finv[MOD%i]%MOD; for(int i=2; i\u0026lt;N; i++) finv[i]=finv[i]*finv[i-1]%MOD; for(int i=0; i\u0026lt;N-1; i++) f[i+1]=finv[i]; int T; gn(T); while(T--) { gn(n), gn(m), gn(u), gn(v); printf(\u0026quot;%d\\n\u0026quot;, solve()); } return 0; } ","oriTitle":"JZOJ6080 IOer","tags":["æ•°å­¦","ç”Ÿæˆå‡½æ•°"],"title":"JZOJ6080 IOer","uri":"/posts/sol-jzoj-6080/"},{"categories":["solution"],"content":"â­\nProblem ä¸€ä¸ªåšå¼ˆæ¸¸æˆï¼šç»™å®šä¸€æ£µæœ‰æ ¹æ ‘ï¼Œæ”¾ä¸€ä¸ªçŸ³å­åœ¨æ ¹èŠ‚ç‚¹ï¼Œè½®æµæ‰§æ‰‹ï¼Œæ¯æ¬¡å¾€ä»»æ„å¶å­èŠ‚ç‚¹æ–¹å‘ç§»ä¸€æ­¥ï¼Œä¸èƒ½ç§»åˆ™ä¸ºè¾“ã€‚\nç°åœ¨ç»™ä½  $n$ ä¸ªç‚¹ï¼Œç”Ÿæˆä»»æ„ä¸€æ£µæœ‰æ ¹æ ‘ï¼Œé—®å…ˆæ‰‹è·èƒœçš„æ¦‚ç‡ã€‚æœ‰ $q$ æ¬¡è¯¢é—®ã€‚\n$n,q \\leq 10^5$\nSolution ä»¤ $f(x), g(x)$ åˆ†åˆ«ä¸ºåæ‰‹å’Œå…ˆæ‰‹å¿…èƒœçš„ EGF ï¼Œåˆ™ $f(x)+g(x)=\\sum \\frac{(i-1)!}{i!}x^i$ ã€‚æ‰€ä»¥æœ‰ $g(x)=-ln(1-x)-f(x)$ ã€‚å…¶ä¸­ $(i-1)!$ ä¸ºæ— æ ‡å·æœ‰æ ¹æ ‘çš„æ–¹æ¡ˆæ•°ï¼Œ$\\sum \\frac{(-1)^{i+1}}{i}x^i$ ä¸º $ln(x+1)$ çš„éº¦å…‹åŠ³æ—çº§æ•°ã€‚\næ ¹æ®SGå‡½æ•°ï¼Œå› ä¸ºåæ‰‹å¿…èƒœçš„å­æ ‘çš†ä¸ºå…ˆæ‰‹å¿…èƒœï¼Œé‚£ä¹ˆæœ‰ $xe^{g(x)}=f(x)$ ã€‚è§£æ–¹ç¨‹å¾— $f(x)=ln(1-ln(1-x))$ ã€‚å¹¶ä¸çŸ¥é“è¿‡ç¨‹ã€‚\næ‰€ä»¥å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„æ¦‚ç‡ï¼š$\\frac{(n-1)!-n!f_n}{(n-1)!}=1-nf_n$ ã€‚\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; const int N=4e5+10; int f[N], g[N], h[N], r[N], n; void gen(int m) { int l=0; for(n=1; n\u0026lt;=m; n\u0026lt;\u0026lt;=1) l++; for(int i=1; i\u0026lt;n; i++) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); } int qpow(int x, int y) { assert(y\u0026gt;=0); int ret=1; while(y) { if(y\u0026amp;1) ret=1ll*ret*x%MOD; x=1ll*x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } void dft(int x[], int d) { for(int i=1; i\u0026lt;n; i++) if(r[i]\u0026gt;i) swap(x[i], x[r[i]]); int t, w, o; for(int i=1; i\u0026lt;n; i\u0026lt;\u0026lt;=1) { o=qpow(3, d*(MOD-1)/(i\u0026lt;\u0026lt;1)+MOD-1); for(int j=0; j\u0026lt;n; j+=(i\u0026lt;\u0026lt;1)) { w=1; for(int k=0; k\u0026lt;i; k++, w=1ll*w*o%MOD) t=1ll*x[i+j+k]*w%MOD, x[i+j+k]=(x[j+k]-t+MOD)%MOD, (x[j+k]+=t)%=MOD; } } } void mul(int x[], int y[], int z[], int m, int mode=0) { gen(m\u0026lt;\u0026lt;1); int a[N]={0}, b[N]={0}; copy(x, x+m, a), copy(y, y+m, b); dft(a, 1), dft(b, 1); for(int i=0; i\u0026lt;n; i++) if(!mode) a[i]=1ll*a[i]*b[i]%MOD; else a[i]=(2ll*b[i]-1ll*a[i]*b[i]%MOD*b[i]%MOD+MOD)%MOD; dft(a, -1); int inv=qpow(n, MOD-2); for(int i=0; i\u0026lt;m; i++) z[i]=1ll*a[i]*inv%MOD; } void inv(int a[], int f[], int deg) { assert(deg\u0026gt;0); if(deg==1) { f[0]=qpow(a[0]%MOD, MOD-2); return; } inv(a, f, (deg+1)\u0026gt;\u0026gt;1); mul(a, f, f, deg, 1); } void deri(int x[], int n) { for(int i=0; i\u0026lt;n; i++) x[i]=1ll*(i+1)*x[i+1]%MOD; x[n-1]=0; } void inte(int x[], int n) { for(int i=n-1; i\u0026gt;0; i--) x[i]=1ll*x[i-1]*qpow(i, MOD-2)%MOD; x[0]=0; } void pln(int x[], int y[], int n) { int a[N]={0}, b[N]={0}; copy(x, x+n, a); inv(a, b, n); deri(a, n); mul(a, b, a, n); inte(a, n); for(int i=0; i\u0026lt;n; i++) y[i]=a[i]; } int main() { ios::sync_with_stdio(false), cin.tie(0); int n=1e5+10; f[0]=1, f[1]=MOD-1; pln(f, g, n); for(int i=0; i\u0026lt;n; i++) g[i]=(MOD-g[i])%MOD; g[0]++; pln(g, h, n); int q; cin\u0026gt;\u0026gt;q; while(q--) { int na; cin\u0026gt;\u0026gt;na; cout\u0026lt;\u0026lt;(1-1ll*na*h[na]%MOD+MOD)%MOD\u0026lt;\u0026lt;'\\n'; } return 0; } ","oriTitle":"JZOJ6077 Kå›çš„æ¸¸æˆ","tags":["æ•°å­¦","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"JZOJ6077 Kå›çš„æ¸¸æˆ","uri":"/posts/sol-jzoj-6077/"},{"categories":["solution"],"content":"æµªè´¹äº†æˆ‘ä¸€æ™šä¸Šçš„ç”Ÿå‘½\u0026hellip;\nSolution å…³äºæœ¬é¢˜æœ‰ä¸¤ç§åšæ³•ï¼Œæˆ‘ä¸€å¼€å§‹å†™çš„ç¬¬ä¸€ç§ï¼šå»ºç«‹å¹¿ä¹‰SAMï¼Œç»Ÿè®¡parentæ ‘ä¸Šçš„endposé›†åˆæ˜¯å¦å¯ä»¥åŒ…å«æ‰€æœ‰çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœå¯ä»¥å°±ç”¨lenæ›´æ–°ansã€‚å¯ä»¥çŠ¶å‹ã€‚\nåšæ³•æˆ‘æ‹äº†ä¸€ä¸‹ï¼Œå¤§æ¦‚æ˜¯æ²¡é—®é¢˜çš„ã€‚ä½†æ˜¯è¿™æ²™é›•é¢˜å¡å¸¸200msæˆ‘ç¡¬æ˜¯ç»™å¡äº†ä¸€æ™šä¸ŠğŸ˜‚ç„¶åå‘ç°ä¸€äº›ç¥å¥‡çš„é—®é¢˜ã€‚æ¯”å¦‚å¹¿ä¹‰SAMæ˜¯æ²¡æ³•ç”¨åŸºæ•°æ’åºæ¥ç¡®å®šæ ‘ä¸Šæ‹“æ‰‘åºçš„ï¼Œæ‰€ä»¥å¾—é˜Ÿåˆ—ç¡¬ä¸Šï¼Œå¯æƒœä¸ç®¡æ€ä¹ˆå†™éƒ½å¡ä¸è¿‡200msã€‚\nå¦ä¸€ç§åšæ³•å°±æ˜¯ç¥å¥‡çš„è½¬ç§»ï¼šå…ˆå»ºä¸€ä¸ªä¸²ï¼Œç„¶åå¯¹äºååŠ å…¥çš„æ¯ä¸ªä¸²è®¡ç®—ä¸€ä¸‹çŠ¶æ€åŒ¹é…çš„æœ€å¤§å€¼ï¼ˆå¯ä»¥é€šè¿‡åç¼€é“¾æ¥ä¸Šä¼ ï¼‰ï¼Œç„¶åå†å¯¹äºæ¯ä¸ªä¸²å–ä¸ªæœ€å°å€¼ï¼Œæœ€åæ€»ä½“å–ä¸ªæœ€å¤§å€¼ã€‚è¿™æ ·çš„åšæ³•åŸºæœ¬ä¸Šæ˜¯å¸¸æ•°å¾ˆå°çš„ $O(n)$ ï¼Œæˆ–è€…æ˜¯æˆ‘å¸¸æ•°åˆ¶é€ æœºäº†\u0026hellip;\nCode - 80ms // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26]; int lst=1, idx=1; inline void add(int c) { int p=lst, np=lst=++idx; len[np]=len[p]+1; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int bu[N], id[N]; int su[N], f[N]; void solve() { int x=1, l=0; memset(su, 0, sizeof(su)); for(char *p=str; *p; p++) { if(ch[x][*p-'a']) l++, x=ch[x][*p-'a']; else { while(x \u0026amp;\u0026amp; !ch[x][*p-'a']) x=fa[x]; if(!x) l=0, x=1; else l=len[x]+1, x=ch[x][*p-'a']; } su[x]=max(su[x], l); } for(int i=idx; i\u0026gt;=1; i--) su[fa[id[i]]]=max(su[fa[id[i]]], su[id[i]]); for(int i=1; i\u0026lt;=idx; i++) len[i]=min(len[i], su[i]); } int main() { scanf(\u0026quot;%s\u0026quot;, str); for(char *p=str; *p; p++) add(*p-'a'); for(int i=1; i\u0026lt;=idx; i++) bu[len[i]]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[len[i]]--]=i; while(scanf(\u0026quot;%s\u0026quot;, str)==1) solve(); int ans=0; for(int i=1; i\u0026lt;=idx; i++) ans=max(ans, len[i]); printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  Code - TLE // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26], in[N]; int f[N], lst=1, idx=1; inline void add(int c, int val) { int p=lst, np=lst=++idx; len[np]=len[p]+1; f[np]=1\u0026lt;\u0026lt;val; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q], f[nq]=f[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int main() { int nidx=0; while(scanf(\u0026quot;%s\u0026quot;, str)==1) { lst=1; for(char *p=str; *p; p++) add(*p-'a', nidx); ++nidx; } nidx=(1\u0026lt;\u0026lt;nidx)-1; int ans=0, na, nf; for(int i=1; i\u0026lt;=idx; i++) in[fa[i]]++; for(int i=1; i\u0026lt;=idx; i++) if(!in[i]) qu[t++]=i; while(h!=t) { na=qu[h++], nf=fa[na]; if(f[na]==nidx \u0026amp;\u0026amp; len[na]\u0026gt;ans) ans=len[na]; f[nf]|=f[na], in[nf]--; if(!in[nf]) qu[t++]=nf; } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"SPOJ1812 LCS2","tags":["SAM"],"title":"SPOJ1812 LCS2","uri":"/posts/sol-spoj-1812/"},{"categories":["solution"],"content":"åšæ³•å¾ˆå·§å¦™ã€‚\nProblem ç»™ä½ ä¸€æ£µæ ‘ï¼Œå’Œæ•°æ¡é“è·¯çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªç«è½¦ä¼šåœ¨è·¯ä¸Šç›¸é‡ã€‚\næ¯ä¸ªç«è½¦çš„é€Ÿåº¦ç›¸åŒï¼Œèµ·ç»ˆç‚¹ä¹Ÿç®—ç›¸é‡ï¼Œä½†ç»è¿‡ç»ˆç‚¹åç«è½¦æ¶ˆå¤±ã€‚\nSolution é¦–å…ˆå¦‚æœåœ¨è¾¹ä¸Šç›¸é‡ä¸€å®šæ˜¯åœ¨ä¸­ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥ç»™æ¯æ¡è¾¹å•ç‹¬å¼€ä¸€ä¸ªç‚¹è½¬åŒ–é—®é¢˜ã€‚\nç„¶åå°†è·¯å¾„åˆ†ä¸ºä¸Šè¡Œå’Œä¸‹è¡Œï¼Œlcaç®—åœ¨ä¸Šè¡Œï¼Œæ±‚ä¸Šä¸‹ç›¸äº¤å’Œä¸Šä¸Šç›¸äº¤å³å¯ã€‚\nä¸Šä¸Šç›¸äº¤å¯ä»¥çº¿æ®µæ ‘åˆå¹¶ï¼Œä¸Šä¸‹ç›¸äº¤å¯ä»¥å¯¹æ¯æ¡é‡é“¾åˆ†åˆ«å¤„ç†ï¼Œä»¥é‡é“¾çš„æ·±åº¦ä¸º $x$ è½´ï¼Œç¦»èµ·ç‚¹çš„è·ç¦»ä¸º $y$ è½´ï¼Œå¾—åˆ°æ¯æ¡è·¯å¾„åœ¨æ¯ä¸ªé‡é“¾çš„å‡½æ•°å’Œå€¼åŸŸï¼Œé‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆæ±‚ $k=1/-1$ çš„ç›´çº¿çš„äº¤ç‚¹æ•°ï¼Œå¯ä»¥ç›´æ¥ç¦»æ•£åˆ° $y$ è½´åæ‰«æçº¿æ±‚äº¤ç‚¹ä¸ªæ•°ã€‚\næ³¨æ„ä¸Šä¸Šç›¸äº¤çš„èµ·ç‚¹é‡åˆä¸è¦æ¼ç®—ã€‚\nCode // Code by ajcxsu // Problem: correction #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(); x=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=2e5+10; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], fa[N], top[N], son[N], dep[N], dfn[N], len[N], idx; int bot[N]; void dfs1(int x, int k) { dep[x]=k, siz[x]=1; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { fa[to[u]]=x, dfs1(to[u], k+1), siz[x]+=siz[to[u]]; if(siz[son[x]]\u0026lt;siz[to[u]]) son[x]=to[u]; } } void dfs2(int x, int t) { top[x]=t, dfn[x]=++idx; len[t]++; if(son[x]) dfs2(son[x], t); else bot[t]=x; for(int u=h[x];u;u=nexp[u]) if(!dfn[to[u]]) dfs2(to[u], to[u]); } int lca(int s, int t, int mode=0) { while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); if(mode \u0026amp;\u0026amp; fa[top[s]]==t) return top[s]; s=fa[top[s]]; } if(mode) return dep[s]\u0026lt;dep[t]?son[s]:son[t]; return dep[s]\u0026lt;dep[t]?s:t; } struct Seg { int k, b, l, r; } ; vector\u0026lt;Seg\u0026gt; td[N]; struct Node *nil; struct Node { int v, t; Node *ls, *rs; Node () { v=t=0; ls=rs=nil; } } *nd[N], *nd2[N]; void ini() { nil=new Node(), nil-\u0026gt;ls=nil-\u0026gt;rs=nil, fill(nd, nd+N, nil), fill(nd2, nd2+N, nil); } ll updata(Node *\u0026amp;x, int l, int r, int d, int v) { if(x==nil) x=new Node(); x-\u0026gt;v+=v; int mid=(l+r)\u0026gt;\u0026gt;1; if(l==r) { x-\u0026gt;t=l; return x-\u0026gt;v-v; } if(d\u0026lt;=mid) return updata(x-\u0026gt;ls, l, mid, d, v); else return updata(x-\u0026gt;rs, mid+1, r, d, v); } void Merge(Node *\u0026amp;x, Node *a, Node *b, ll \u0026amp;cnt, int mode=0) { if(a==nil) { x=b; return; } if(b==nil) { x=a; return; } if(x==nil) x=new Node(); if(!mode \u0026amp;\u0026amp; a-\u0026gt;t) cnt+=1ll*a-\u0026gt;v*b-\u0026gt;v; x-\u0026gt;v=a-\u0026gt;v+b-\u0026gt;v; Merge(x-\u0026gt;ls, a-\u0026gt;ls, b-\u0026gt;ls, cnt, mode); Merge(x-\u0026gt;rs, a-\u0026gt;rs, b-\u0026gt;rs, cnt, mode); delete b; } int n; void modify(int x, int k, int l, int r, int ry) { int b=ry-(r-dep[x])*k; td[x].push_back({k, b, l-dep[x], r-dep[x]}); } void modifyup(int s, int t, ll \u0026amp;ans) { if(dep[s]\u0026lt;dep[t]) swap(s, t); /* â†‘ */ ans+=updata(nd[s], 1, n, dep[s], 1); updata(nd2[t], 1, n, dep[s], -1); int bg=dep[s]; /* â†“ */ while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], -1, dep[top[s]], dep[s], bg-dep[s]); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], -1, dep[s], dep[t], bg-dep[t]); } void modifydown(int s, int t, int rua) { int bg=min(dep[s], dep[t]); while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], 1, dep[top[s]], dep[s], dep[s]-bg+rua); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], 1, dep[s], dep[t], dep[t]-bg+rua); } void dfs(int x, ll \u0026amp;cnt) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa[x]) { dfs(to[u], cnt); Merge(nd[x], nd[x], nd[to[u]], cnt); } Merge(nd[x], nd[x], nd2[x], cnt, 1); } #define lowbit(x) x\u0026amp;-x namespace BIT { const int V=N\u0026lt;\u0026lt;2; int C[V], stk[V][2], t; void updata(int x, int v, int mode=0) { if(!mode) stk[++t][0]=x, stk[t][1]=v; while(x\u0026lt;V) C[x]+=v, x+=lowbit(x); } int query(int x) { int ret=0; while(x) ret+=C[x], x-=lowbit(x); return ret; } void clr() { while(t) updata(stk[t][0], -stk[t][1], 1), t--; } } struct Query { int t, v, x, l, r; } ; Query tmp[N\u0026lt;\u0026lt;1]; int t; bool cmp(const Query \u0026amp;a, const Query \u0026amp;b) { return a.x==b.x?a.t\u0026lt;b.t:a.x\u0026lt;b.x; } ll count(int x) { t=0; for(Seg y:td[x]) if(y.k==1) { tmp[++t]={0, 1, 2*y.l+y.b, y.b+(N\u0026lt;\u0026lt;1)}; tmp[++t]={2, -1, 2*y.r+y.b, y.b+(N\u0026lt;\u0026lt;1)}; } else { tmp[++t]={1, 0, y.b, y.b-2*y.l+(N\u0026lt;\u0026lt;1), y.b-2*y.r+(N\u0026lt;\u0026lt;1)}; } sort(tmp+1, tmp+1+t, cmp); ll ret=0; BIT::clr(); for(int i=1; i\u0026lt;=t; i++) if(tmp[i].t==1) ret+=BIT::query(tmp[i].l)-BIT::query(tmp[i].r-1); else BIT::updata(tmp[i].l, tmp[i].v); return ret; } int main() { int u, v; gn(n); for(int i=1; i\u0026lt;n; i++) { gn(u, v); ins(u, i+n), ins(i+n, u); ins(v, i+n), ins(i+n, v); } ini(); dfs1(1, 1), dfs2(1, 1); ll ans=0; int m; gn(m); for(int i=1; i\u0026lt;=m; i++) { gn(u, v); int l=lca(u, v); if(l==v) modifyup(u, v, ans); else { int l2=lca(l, v, 1); modifyup(u, l, ans); modifydown(v, l2, dep[u]-dep[l]+1); } } dfs(1, ans); for(int i=1; i\u0026lt;=2*n-1; i++) if(top[i]==i) ans+=count(i); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } ","oriTitle":"Railway","tags":["æ ‘é“¾å‰–åˆ†","æ‰«æçº¿"],"title":"Railway","uri":"/posts/sol-jzoj-6074/"},{"categories":["solution"],"content":"æœ‰ç‚¹éš¾\u0026hellip;\nSolution ç½‘ä¸Šå·²ç»è®²å¾—å¾ˆè¯¦ç»†äº†å§ï¼Ÿ\nè¡¥å……å‡ ä¸ªé—®é¢˜ã€‚ä¸€æ˜¯å¯ä»¥ç›´æ¥ $f_{R}=\\sum \\limits_{j=L-1}^R f_j$ è¿›è¡Œè½¬ç§»ã€‚ä½†æ˜¯å¾—æ³¨æ„å…ˆè½¬ç§»å¤§åŒºé—´å†è½¬ç§»å°åŒºé—´ï¼ˆè¿™å±äºè¢«éƒ¨åˆ†åŒ…å«ï¼‰ï¼Œå¦åˆ™çš„è¯ä½ å¯èƒ½ä¼šä¸¢å¤±ä¸é€‰å°åŒºé—´çš„å†³ç­–ã€‚\nç¬¬äºŒä¸ªé—®é¢˜æ˜¯è‹¥é€Ÿåº¦å¯ä»¥ç›¸ç­‰ï¼Œé‚£ä¹ˆéœ€è¦å°†å¼€å§‹çš„æ’åºè¿›è¡Œä¸€äº›å°ä¿®æ”¹ã€‚è€ƒè™‘ $X_i$ çš„å·¦ç«¯æ¯”å®ƒå¤§çš„æœ€å°çš„ $j$ ï¼Œè‹¥æœ‰æ•°ä¸ª $V_k$ ç­‰äº $V_j$ ï¼Œé‚£ä¹ˆè¿™äº› $V_k$ çš„ç‚¹æ˜¯è‚¯å®šä¸èƒ½è¢«æŸ“è‰²çš„ã€‚å³ä¾§åŒç†ã€‚\nCode // Code by ajcxsu #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (1000000007) using namespace std; const int N=5e5+10; int h[N], l[N], r[N]; vector\u0026lt;int\u0026gt; L[N]; int x[N], v[N], a[N]; bool cmp(const int \u0026amp;a, const int \u0026amp;b) { return v[a]\u0026lt;v[b] || (v[a]==v[b] \u0026amp;\u0026amp; x[a]\u0026lt;x[b]); } int f[N], S[N]; int main() { ios::sync_with_stdio(false), cin.tie(0); int n, m; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;v[i], a[i]=i; sort(a+1, a+1+n, cmp); int stk[N], p[N], t=0; for(int i=1; i\u0026lt;=n; i++) { if(!t || stk[t]\u0026lt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026lt;x[a[i]]) l=mid+1; else r=mid; } ::l[i]=p[r]; } t=0; for(int i=n; i\u0026gt;=1; i--) { if(!t || stk[t]\u0026gt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026gt;x[a[i]]) l=mid+1; else r=mid; } ::r[i]=p[r]; } for(int i=1; i\u0026lt;=n; i++) L[r[i]].push_back(l[i]); f[0]=S[0]=1; for(int i=1; i\u0026lt;=n; i++) { S[i]=S[i-1]; sort(L[i].begin(), L[i].end()); for(int j:L[i]) { f[i]=(1ll*f[i]+S[i]-(j-2\u0026gt;=0?S[j-2]:0)+MOD)%MOD; S[i]=(f[i]+S[i-1])%MOD; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC015E Mr.Aoki Incubator","tags":["å•è°ƒæ ˆ","DP","äºŒåˆ†"],"title":"AGC015E Mr.Aoki Incubator","uri":"/posts/sol-agc-015-e/"},{"categories":["solution"],"content":"æœ‰ç‚¹ç¥çš„æ„é€ ï¼Œè€ƒåœºä¸Šæƒ³å¤æ‚äº†\u0026hellip;\nSolution è€ƒè™‘å› ä¸ºå˜æ¢ $2^n-1$ æ¬¡ï¼Œé‚£ä¹ˆ $A$ è·Ÿ $B$ çš„ $1$ ä½æ•°çš„å¥‡å¶æ€§ä¸€å®šä¸åŒï¼Œç”¨è¿™ä¸ªæ¥åˆ¤æ–­æ˜¯å¦æœ‰è§£ã€‚\né€šè¿‡å½’çº³å¯ä»¥çŸ¥é“å¦‚æœä¸åŒæ˜¯ä¸€å®šæœ‰è§£çš„ã€‚\nå‡è®¾å­˜åœ¨ $n=k$ çš„æ„é€ æ–¹æ¡ˆï¼Œè€ƒè™‘å¦‚ä½•æ„é€  $k+1$ ä½çš„æ„é€ æ–¹æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥å°† $A$ å’Œ $B$ ä¸åŒçš„ä¸€ä½ï¼ˆå‡è®¾æ˜¯ç¬¬ $x$ ä½ï¼‰æå–å‡ºæ¥ï¼Œå‰©ä¸‹ $k$ ä½æ•° $A\u0026rsquo;$ å’Œ $B\u0026rsquo;$ ã€‚ä»–ä»¬çš„ä½æ•°å¥‡å¶æ€§ä¸€å®šç›¸åŒã€‚é‚£ä¹ˆæˆ‘ä»¬å†è€ƒè™‘ä¸€ä¸ªä¸€ä½ä¸ $A\u0026rsquo;$ ä¸åŒçš„æ•° $c$ ã€‚é€’å½’å»æ„é€ ä¸€ä¸ª $A\u0026rsquo;\\rightarrow c \\rightarrow B\u0026rsquo;$ çš„æ–¹æ¡ˆã€‚å…¶ä¸­å‰åŠéƒ¨åˆ†çš„ç¬¬ $x$ ä½ä¸ $A$ ç›¸åŒï¼ŒååŠéƒ¨åˆ†ä¸ $B$ ç›¸åŒã€‚\né€’å½’æ„é€ å³å¯ã€‚\nCode // Code by ajcxsu // Problem: C #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef bitset\u0026lt;10\u0026gt; bs; void solve(int k, int a, int b, vector\u0026lt;int\u0026gt; \u0026amp;op) { if(k==1) { op.push_back(a), op.push_back(b); return; } int c=0; vector\u0026lt;int\u0026gt; L, R; for(; ((1\u0026lt;\u0026lt;c)\u0026amp;a)==((1\u0026lt;\u0026lt;c)\u0026amp;b); c++); int na=(a\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((a\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); int nb=(b\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((b\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); solve(k-1, na, na^1, L); solve(k-1, na^1, nb, R); for(int x:L) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;a)); for(int x:R) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;b)); } int main() { ios::sync_with_stdio(false), cin.tie(0); int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!((__builtin_popcount(a)+__builtin_popcount(b))\u0026amp;1)) cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;, exit(0); vector\u0026lt;int\u0026gt; ans; solve(n, a, b, ans); cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; for(int x:ans) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;' '; cout\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC032C Differ by 1 bit","tags":["æ„é€ "],"title":"AGC032C Differ by 1 bit","uri":"/posts/sol-agc-032-c/"},{"categories":["solution"],"content":"å¼„äº†ä¸€æ™šä¸Šï¼Œå‡ ç¯‡åšå®¢äº¤æ¢çœ‹æ‰çœ‹æ‡‚ã€‚\nå¯èƒ½ä¹Ÿæ˜¯å› ä¸ºåˆ†å¿ƒäº†çš„ç¼˜æ•…ã€‚\nSolution å°†æ•´æ£µæ ‘åˆ†ä¸º $k+1$ ä¸ªè”é€šå—ï¼Œå¯¹æ¯ä¸ªè”é€šå—æ‰¾ç›´å¾„ï¼Œç„¶åç›´å¾„ç«¯ç‚¹è¿æˆä¸€æ¡é“¾ä¸€å®šæ˜¯æœ€ä¼˜è§£ã€‚\nè€ƒè™‘è½¬åŒ–é—®é¢˜ï¼Œæ±‚æ ‘ä¸Š $k+1$ æ¡ä¸ç›¸äº¤é“¾çš„æœ€å¤§æƒå’Œã€‚\nè®¾è®¡çŠ¶æ€ã€‚è€ƒè™‘ä¸€ä¸ªç‚¹çš„åº¦æ•°åªå¯èƒ½ä¸º $0/1/2$ ã€‚ä»¤ $f_{i, j, k}$ ä¸ºç¬¬ $i$ ä¸ªç‚¹ï¼Œåº¦æ•°ä¸º $j$ ï¼Œç”¨äº† $k$ æ¡é“¾çš„å­æ ‘æœ€ä¼˜è§£ã€‚\nå†å…·ä½“é˜è¿°çŠ¶æ€ã€‚$f_{i, 0}$ ä»£è¡¨è¿™ä¸ªç‚¹åº¦æ•°ä¸º $0$ ï¼Œå³åœ¨æœ€ç»ˆçš„æ–¹æ¡ˆä¸­å®ƒå¹¶ä¸å±äºç›´å¾„ï¼Œå› æ­¤ä¸å ç”¨ä»»ä½•é“¾çš„ä¸ªæ•°ä¹Ÿä¸æä¾›ä»»ä½•è´¡çŒ®ã€‚ $f_{i, 1}$ çš„çŠ¶æ€æ­£å¸¸ã€‚ $f_{i, 2}$ ä»£è¡¨è¿™ä¸ªç‚¹çš„åº¦æ•°ä¸º $2$ ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ç‚¹æˆä¸ºç›´å¾„ä¸­çš„ä¸€æ¡é“¾ï¼Œæˆ‘ä»¬å°±å‡è®¾æ˜¯ $i$ å‘è‡ªå·±è¿äº†è‡ªç¯ï¼Œåº¦æ•°ä¸º $2$ ä¸”å ç”¨äº†ä¸€æ¡é“¾çš„æ•°ç›®ã€‚\né‚£ä¹ˆåˆå§‹åŒ–ä¹Ÿå°±å‘¼ä¹‹æ¬²å‡ºäº†ï¼š$f_{i, 0, 0}=f_{i, 2, 1}=0$ ï¼Œå…¶ä½™ç½®ä¸º $-\\infty$ ã€‚\nè½¬ç§»ä¸éš¾ã€‚\né€šè¿‡è§‚å¯Ÿï¼ˆæ‰“è¡¨ï¼‰å‘ç°å¯¹äºä½¿ç”¨é“¾æ•°ä¸º $k$ çš„æœ€ä¼˜è§£å‘ˆå‡¸å‡½æ•°ï¼Œä½¿ç”¨ å‡¸ä¼˜åŒ–dp æ¥å»é™¤ $k$ çš„é™åˆ¶ã€‚\næ³¨æ„æˆ‘ä»¬æ˜¯å¯¹æ¯æ¡é“¾äº§ç”Ÿçš„è´¡çŒ®å‡å»æ–œç‡è€Œä¸æ˜¯å¯¹æ¯æ¡è¾¹ã€‚\né‚£ä¹ˆåˆå§‹çš„dpå»é™¤ç¬¬ä¸‰ç»´æ¥åšå°±è¡Œäº†ã€‚\nä½†æ˜¯å‡¸å‡½æ•°å¯èƒ½ä¼šå‡ºç°ä½ è¦æ‰¾çš„ç‚¹å’Œå‰åä¸¤ç‚¹å¤„äºåŒä¸€ç›´çº¿ã€‚é‚£ä¹ˆæ­¤æ—¶åº”å½“äºŒåˆ†åˆ°è¯¥ç›´çº¿çš„æ–œç‡ï¼Œå¹¶ä½¿ç”¨æ–œç‡å’Œ $k$ æ¥ç›´æ¥æ±‚å‡º $k$ çš„æœ€ä¼˜å€¼ã€‚\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 æ—å…‹å¡ç‰¹æ ‘","tags":["å‡¸ä¼˜åŒ–DP"],"title":"LP4383 æ—å…‹å¡ç‰¹æ ‘","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"ä¸€é“ä¸é”™ç›¸å¯¹ç®€å•çš„é¢˜ç›®ã€‚\nSolution å¾ˆå¤§èƒ†çš„æƒ³æ³•ã€‚è€ƒè™‘ä»¥å­æ ‘dpï¼Œç„¶åä¸€æ¡é“¾å¤§åŠ›æ‹‰ä¸‹æ¥æšä¸¾é“¾åº•éƒ¨æ±‚è´¡çŒ®ã€‚\né‚£ä¹ˆå¯¹äºæ¯æ£µå­æ ‘æ±‚æœ€ä¼˜çš„é“¾åº•ã€‚\nç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚è€ƒè™‘ç‚¹ä¸Šç§»ï¼Œé“¾åº•è´¡çŒ®çš„å˜åŒ–é‡ã€‚\né‡é“¾è´¡çŒ®ä¸­æœ‰ $\\log$ çš„å­˜åœ¨ï¼Œä½†æˆ‘ä»¬å‘ç°æ¯ä¸ªé“¾åº•åŠå…¶æ¯æ£µå­æ ‘å¯¹é‡é“¾è´¡çŒ®çš„å˜åŒ–æ¬¡æ•°ä¸ä¼šè¶…è¿‡ $\\log$ æ¬¡ï¼Œå› æ­¤å¤æ‚åº¦æ˜¯ $O(n\\log^2 n)$ çš„ã€‚\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 æ–°å¹´çš„å°é»„é¸­","tags":["çº¿æ®µæ ‘","æ ‘å½¢dp"],"title":"UOJ462 æ–°å¹´çš„å°é»„é¸­","uri":"/posts/sol-uoj-462/"},{"categories":["others"],"content":"$\\text{Hello world!}$ è¿™â†‘é‡Œâ†“å°±æ˜¯é‡Œç«™äº†ã€‚æ¬¢è¿ã€‚\n","oriTitle":"Inside Space","tags":["none"],"title":"Inside Space","uri":"/posts/my-first-post/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"CLOUD DRIVE SHARE ID: 18shvmR8qqAhD2OlZjs3eo1ddXM3EPJVa\n","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]