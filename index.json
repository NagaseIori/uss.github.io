[{"categories":["solution"],"content":"一道不错相对简单的题目。\nSolution 很大胆的想法。考虑以子树dp，然后一条链大力拉下来枚举链底部求贡献。\n那么对于每棵子树求最优的链底。\n用线段树维护。考虑点上移，链底贡献的变化量。\n重链贡献中有 $\\log$ 的存在，但我们发现每个链底及其每棵子树对重链贡献的变化次数不会超过 $\\log$ 次，因此复杂度是 $O(n\\log^2 n)$ 的。\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 新年的小黄鸭","tags":["线段树","树形dp"],"title":"UOJ462 新年的小黄鸭","uri":"https://i.acxblog.site/posts/sol-uoj-462/"},{"categories":["others"],"content":"$\\text{Hello world!}$ Here. 如果你找到这里了\u0026hellip;\n让我猜猜？\n你是看了我的github还是查了我的子域名？\nNext. 那么这里就是Inside Space。\n平常可能会在这里记录一些OI以外的内容。\n包括游戏、音乐、动画、漫画、小说、开发。\n而以上所提到的，我也在努力的进修中。\n关于Hugo和Canoe的这个主题，是受到了 margatroid 的影响。因为觉得这个很好看。所以也顺势弄了个Github Page，成就了我一向想要做里站的愿望。虽然是里站，但是还是不能放一些不可描述的H的东西呢（笑）\n以上。\nSomething left. 由于一些不可描述的技术原因，中文搜索功能暂不能使用。\n","oriTitle":"Inside Space","tags":["none"],"title":"Inside Space","uri":"https://i.acxblog.site/posts/my-first-post/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"https://i.acxblog.site/archive/"},{"categories":null,"content":"没有什么好说的。\n有人可能已经注意到了我的头像。\n主页的一个，或许还有gravatar的那一个。\n使用这两个头像的原因是因为我认为这些表情太可爱了x\n原图的话可能只有经常在p站翻奇怪东西的人才能找出来吧？\n博客标题并不是指某飞机型号\n","oriTitle":"About Me","tags":null,"title":"About Me","uri":"https://i.acxblog.site/about/"}]