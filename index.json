[{"categories":["others"],"content":"å¿ƒè¡€æ¥æ½®çªç„¶æƒ³æ•´è¿™ä¹ˆä¸€ä¸‹æ¥æ¢ç´¢ä¸€ä¸‹éšæœºå‡ ä¸ªå…³é”®è¯è·³è½¬ç½‘ç«™éƒ½ä¼šè·³è½¬åˆ°å“ªäº›åœ°æ–¹ã€‚\nç”±äº .moe åŸŸåçš„ç‰¹æ®Šæ€§ï¼Œå‘½ä¸­ç‡çš„ç¡®ä¸ç®—ä½ã€‚\nä¸‹é¢ä»¥è¡¨æ ¼å½¢å¼å‘ˆç°æˆ‘éšæœºåˆ°çš„ä¸€äº›åŸŸåå’Œç½‘ç«™çš„å†…å®¹å§ã€‚åªè¦èƒ½è®¿é—®çš„æˆ‘éƒ½ä¼šæ”¾ä¸Šæ¥ã€‚\nè­¦å‘Šï¼šéƒ¨åˆ†ç½‘ç«™å« NSFW å†…å®¹ï¼ˆåŒ…æ‹¬è¡€è…¥/è‰²æƒ…/æš´åŠ›ç­‰R18/R18Gè¦ç´ ï¼‰ï¼Œéƒ¨åˆ†ç½‘ç«™å¯èƒ½è¢«å¢™ï¼Œè¯·è°¨æ…è®¿é—®\n ç›®å‰ç»Ÿè®¡ï¼š46ä¸ªå¯è®¿é—®ç½‘ç«™ã€‚\n    åŸŸå ç½‘ç«™æ ‡é¢˜ ç½‘ç«™å†…å®¹     rin.moe rin çš„å°çª æ˜¯åšå®¢   ecchi.moe  ç‰™ç™½çš„ä¸œè¥¿ (anime)(NSFW)   setsuna.moe Setsuna\u0026rsquo;s æ˜¯åšå®¢   miku.moe åˆéŸ³ãƒŸã‚¯ãƒ©ã‚¤ãƒ–é–¢é€£ã‚ªãƒ•ä¼šä¼ç”»ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚µã‚¤ãƒˆ    clock.moe clock.moe æœ‰å¤šç§å£å‘³å¯é€‰æ‹©çš„åœ¨çº¿é’Ÿè¡¨ç½‘ç«™ï¼ˆè¿˜æœ‰æˆå°±ï¼‰ï¼Ÿ   bilibili.moe Index of / ä¼¼ä¹æ˜¯æ´»çš„æœåŠ¡å™¨æ¬¸   sakura.moe  ä¸ªäººç½‘ç«™\u0026hellip; ç°åœ¨çš„å¹´è½»äººéƒ½å¥½å¼ºå•Šï¼Ÿ   akuma.moe abandon all hope ç‰™ç™½çš„ä¸œè¥¿ (doujinshi)(NSFW)   vtuber.moe Natsumi Moe è·³è½¬åˆ° https://www.youtube.com/user/TheOtakuMoe (www)   aqua.moe Aqua Aria æ˜¯åšå®¢   rinko.moe ã€Œãƒ©ãƒ–ãƒ—ãƒ©ã‚¹ EVERYã€ å…¬å¼ã‚µã‚¤ãƒˆ KONAMI æŸæ‰‹æ¸¸å®˜ç½‘ï¼Ÿ   gfw.moe hello world hello world   despair.moe [ ã‹ã‚ã„ã„ã®ãƒ«ãƒ¼ãƒˆ ] ç”»çš„å¾ˆå¥½çš„å¤–å›½ç”»å¸ˆçš„ä¸ªäººç«™ç‚¹   akarin.moe é˜¿å¡æ—æœåŠ¡å™¨ æ˜¯åšå®¢   pixiv.moe pixiv ã‚®ãƒ£ãƒ©ãƒªãƒ¼ pixiv çš„ä»£ç†ç«™ç‚¹ï¼Œå›½å†…æ— æ³•è®¿é—® 1   sensei.moe sensei.moe æ„ä¹‰ä¸æ˜ï¼Ÿ   lucy.moe asagi.moe è·³è½¬åˆ° https://asagi.moe/ ï¼Œæ˜¯ä½å¾·å›½æœ‹å‹çš„åšå®¢   umi.moe Noirsumi NAS äººå®¶çš„ NAS\u0026hellip; å¥½åƒæ‰“æ‰°åˆ°äº† ww   akame.moe Akame æ˜¯åšå®¢   mikumiku.moe MIKUMIKU.MOE miku çš„ç®€ç¬”ç”»å¤´åƒ   era.moe Moe Era è¥¿æ–¹å‹äººå¼€å‘çš„ gal æ¸¸æˆçš„å®˜ç½‘ï¼Œsteam æœ‰å”®ï¼Œç”»é£åƒ DDLCï¼Ÿ   waifu.moe Waifu! Aigis çš„ç²‰ä¸ç«™ç‚¹   kumo.moe äº‘èŒç½‘ç»œ è·³è½¬åˆ° https://www.cloudmoe.com/   yuki.moe Yukino\u0026rsquo;s Dev Blog å¤–å›½å¼€å‘è€…çš„åšå®¢ 2   osu.moe æ­¤ç½‘ç«™å·²è¢«ç»­ çœŸæ­£çš„ç²‰ä¸ç«™ (NSFW)   mea.moe å¹¸ã›ã¯ã—ã«ãŒã¿ã•ã‚“ãŒã‚ã„ã‚’ã‚ãŸã—ã«ã›ã‹ã™ã“ã¨ æ¢…å¨…Â·SÂ·è‰¾è²æ¢…æ‹‰å°”çš„ç²‰ä¸ç«™ç‚¹   kaguya.moe Kaguya.moe and Mokou.moe è¾‰å¤œå§¬ä¸å¦¹çº¢çš„ç²‰ä¸ç«™ï¼ˆä¼¼ä¹æœªå»ºæˆï¼‰   oier.moe ciwomuli æ˜¯åšå®¢å‘¢   kira.moe Sotr\u0026rsquo;s blog æ˜¯åšå®¢   rua.moe RUA! æ˜¯åšå®¢   watashi.moe  watashi çš„ç²‰ä¸ç«™ç‚¹ 3   chtholly.moe ä¸­å›½ç‚å­¦é™¢ ç‚æœµè‰çš„ç²‰ä¸ç«™ç‚¹   fly.moe Fly ã® å®…åŸºåœ° æ˜¯åšå®¢   mizu.moe  ICE ä»‹å…¥ï¼Ÿ   boku.moe Yooooooo! å±‘æ²¹ç®¡ç§»é™¤äº†ç»å…¸åä½œï¼ˆæ¼ï¼‰   kaguramea.moe  Kagura Mea çš„ç²‰ä¸ç«™ç‚¹   hub.moe  ä¸ªäººç«™ç‚¹ï¼Œç«™é•¿ä¹Ÿä¼šç”»ç”»   nika.moe We \u0026lt;3 Nika ç–‘ä¼¼ä¸ªäººç«™ç‚¹   ddlc.moe Doki Doki Literature Club! åŸæ¥å°±æ˜¯DDLCå®˜ç½‘å•Š   dot.moe çŒ«ã®å›½ æ‚å›¾ç«™   kiana.moe  éŸ©å›½å‹äººçš„åšå®¢   cow.moe é­¯ç‰›çª© ä¸ªäººç«™ç‚¹   steam.moe  ä¸ƒæ—¥æ€çš„æ¸¸æˆæœåŠ¡å™¨ï¼Ÿ   suicide.moe  ç–‘ä¼¼å¥‡æ€ªä¹é˜Ÿçš„ä¸»é¡µ   fufufu.moe /a/ - anime/random åŠ¨æ¼«ç»¼åˆç‰ˆçš„åŒ¿åè®ºå› (NSFW)   speed.moe YAIH æ™®é€šçš„å›¾åºŠ     ä½† æºç  ä¼¼ä¹å¼€æ”¾ w [return] æ ¹ç›®å½•æ˜¯ apache çš„é»˜è®¤ç•Œé¢ï¼Œä½†å‘ç°è¿™ä¸ªç½‘ç«™æ˜¯ä¸Šäº† Let\u0026rsquo;s Encrypt çš„ï¼Œéšæ‰‹å¾€åŸŸååé¢åŠ äº†ä¸ª /blog å±…ç„¶è¿›å»äº† w [return] å‡ºè‡ªåŠ¨ç”» äººç±»è¡°é€€ä¹‹å [return]  ","oriTitle":".moe ç½‘ç«™éšæœºè·³è½¬æ¢ç´¢å®å½•","tags":["æ—¥å¸¸"],"title":".moe ç½‘ç«™éšæœºè·³è½¬æ¢ç´¢å®å½•","uri":"/posts/moe-website/"},{"categories":["GUIDE"],"content":"æŠ€æœ¯æ€§æ¢è®¨ã€‚\nå®‰è£… èƒ½æ‰¾åˆ°çš„æœ€æ–¹ä¾¿çš„æ–¹æ³•æ˜¯ä½¿ç”¨ä»¥ä¸‹æŒ‡ä»¤ä»å®˜æ–¹å®‰è£…ï¼ˆä¼šè‡ªåŠ¨ç¼–è¯‘å®‰è£…æ‰€æœ‰ä¾èµ–åŒ…ï¼Œå¹¶åŒæ—¶å®‰è£… simple-obfs pluginï¼‰ï¼š\nmkdir ./build-area cd build-area wget https://github.com/shadowsocks/shadowsocks-libev/raw/master/scripts/build_deb.sh chmod +x build_deb.sh ./build_deb.sh all  é…ç½® æ–‡ä»¶ä½äº /etc/shadowsocks-libev/config.json ã€‚\n{ \u0026quot;server\u0026quot;:\u0026quot;example.com or X.X.X.X\u0026quot;, // è¿™ä¸€è¡Œå¯ä»¥ä¸å¡« \u0026quot;server_port\u0026quot;:443, // æˆ– 8443 \u0026quot;password\u0026quot;:\u0026quot;password\u0026quot;, \u0026quot;method\u0026quot;:\u0026quot;aes-128-gcm\u0026quot;, // æˆ– aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 \u0026quot;timeout\u0026quot;:60, // é€‚å½“æ›´æ”¹ \u0026quot;plugin\u0026quot;:\u0026quot;/usr/bin/obfs-server\u0026quot;, \u0026quot;plugin_opts\u0026quot;:\u0026quot;obfs=tls;failover=\u0026lt;åŸŸåæˆ– IP\u0026gt;\u0026quot; // failover åœ¨éæ­£å¸¸è¯·æ±‚ä¸‹ä¼šè·³è½¬åˆ°ä½ è®¾ç½®çš„åŸŸå/IP }  å®¢æˆ·ç«¯è¯·ä¸‹è½½ obfs-local å¹¶å°†æ–‡ä»¶ç½®äºå®¢æˆ·ç«¯æ ¹ç›®å½•ä¸‹ï¼Œå¡«å†™å‚æ•°å¦‚ä¸‹ï¼š\n   é€‰é¡¹ å‚æ•°     æ’ä»¶ç¨‹åº obfs-local.exe   æ’ä»¶é€‰é¡¹ obfs=tls;obfs-host=\u0026lt;åŸŸåæˆ– IP\u0026gt;    ä½ è¯·æ±‚çš„ç½‘å€ä¼šè¢«ä¼ªè£…æˆæ‰€è®¾ç½®çš„åŸŸåã€‚\né˜²ç«å¢™ æ‰§è¡Œå¦‚ä¸‹æŒ‡ä»¤ï¼š\nufw default allow outgoing ufw default deny incoming ufw allow 22 # å¦‚æœä½ æ›´æ”¹äº† SSH ç«¯å£ï¼Œè¿™é‡Œå°±å¡«å¯¹åº”çš„ SSH ç«¯å£ ufw allow 443 ufw enable  è¡¥å……å¯èƒ½ä¼šå‡ºç°çš„æ„å¤–æƒ…å½¢ï¼š é‡å¯ä¹‹åï¼Œ443(8443) ç«¯å£è¢«å°é—­ï¼Œéœ€è¦ä½¿ç”¨ufw reloadæ‰ä¼šæ‰“å¼€ã€‚æŸ¥çœ‹ ufw çš„ log å‘ç° ufw çš„ç¡® BLOCK äº†å¯¹åº”ç«¯å£çš„è¿æ¥ï¼Œä½†æ˜¯ufw statusæŸ¥çœ‹æ˜¾ç¤ºä¸€åˆ‡æ­£å¸¸ã€‚æˆ‘ä¹Ÿå¾ˆå¥‡æ€ªã€‚åŒæ—¶æˆ‘ä¹Ÿå‘ç°äº† ufw deny 80 ç«¯å£è¿™æ¡æŒ‡ä»¤å¹¶ä¸ç®¡ç”¨ï¼Œå„ç§æ¢æµ‹æ–¹æ³•éƒ½æ˜¾ç¤º 80 ç«¯å£æ‰“å¼€ï¼Œæˆ‘ä¹Ÿå¾ˆå¥‡æ€ªã€‚\næŸ¥äº†å¾ˆå¤šæ•™ç¨‹ï¼Œç›´æ¥è§£å†³çš„æ–¹æ³•å¹¶ä¸ç®¡ç”¨ã€‚ä¸€ç§æ›²çº¿æ•‘å›½çš„æ–¹å¼æ˜¯åœ¨ /etc/rc.local åŠ å…¥ä¸€è¡Œ /etc/init.d/ufw restart ï¼Œä½ å°±ä¸ç”¨æ¯æ¬¡é‡å¯éƒ½è¦è¾“å…¥ ufw reload äº†ã€‚\nè‡ªåŠ¨é‡å¯ é”®å…¥å‘½ä»¤ï¼šcrontab -eï¼Œéšä¾¿é€‰æ‹©ä¸€ç§ç¼–è¾‘å™¨ï¼ˆ nano å°±å¥½ï¼‰ï¼Œç„¶ååœ¨æœ€ä¸‹åŠ å…¥ä¸€è¡Œï¼š\n0 4 * * * /sbin/reboot\nåœ¨æ¯å¤©å‡Œæ™¨å››ç‚¹ä¸»æœºä¾¿ä¼šé‡å¯ã€‚\nnano çš„ä¿å­˜æ–¹å¼æ˜¯ Ctrl+O + Enter å Ctrl+X å³å¯ã€‚\nå¼•ç”¨ https://cokebar.info/archives/767\nhttps://linux.cn/article-8087-1.html\nhttps://stackoverflow.com/questions/41319291/ufw-blocks-most-ports-until-disabled-and-re-enabled-after-reboot\nhttps://www.linuxquestions.org/questions/linux-networking-3/need-to-reload-ufw-after-each-restart-to-apply-rules-4175629240/\n","oriTitle":"ubuntu 18.04 ss-libev éƒ¨ç½²è¸©å‘","tags":["NONE"],"title":"ubuntu 18.04 ss-libev éƒ¨ç½²è¸©å‘","uri":"/posts/ss-libev/"},{"categories":["others"],"content":"è¿ç€æŠŠä¸‰ç¯‡å‰§åœºç‰ˆçœ‹å®Œäº†ã€‚ç²—æµ…åœ°è°ˆè°ˆæ„Ÿæƒ³ã€‚\né‚£ä¹ˆå…ˆè¯´è¯´æœ¬ç¯‡ã€‚\næœ¬ç¯‡å‰æœŸç€é‡æå†™å››äººï¼šç„°ï¼Œå°åœ†ï¼Œæå­ï¼Œæ²™è€¶é¦™ã€‚å…¶ä¸­ä¸ªäººè®¤ä¸ºè¡¨ç°çš„æœ€å¥½ï¼Œæœ€æœ‰é­…åŠ›çš„ä¹Ÿå°±æ˜¯æå­ã€‚æå­çš„æ•…äº‹ï¼Œä»å•çº¯åˆ°å—ä¼¤åä¸å†ä¸ºä»–äººä½¿ç”¨è†œæ³•ï¼Œå†åˆ°å‘ç°é­”æ³•å°‘å¥³çš„çœŸç›¸ï¼Œæ¸…æ¥šçš„è®¤è¯†åˆ°â€œåŒä¼´â€è¿™ä¸€å­˜åœ¨è€Œè½¬å˜å¯¹æ²™è€¶é¦™çš„æ€åº¦ï¼Œä»¥è‡³äºæœ€åä¸ºæ²™è€¶é¦™å†’é™©è€Œç‰ºç‰²è‡ªæˆ‘ã€‚ä»å¤´åˆ°å°¾ï¼Œæå­çš„å¿ƒä¸­å…¶å®éƒ½ä¸€ç›´æ€€æœ‰ä¸€ç§ç†æƒ³çš„æ„¿æœ›ï¼Œè€Œè¿™ç§æ„¿æœ›æ˜¯çº¯ç²¹çš„ã€‚\nåæœŸç€é‡æå†™ç„°å’Œå°åœ†çš„è½®å›å’ŒçœŸç›¸ã€‚è¿™ä¸€éƒ¨åˆ†ç€é‡ä½“ç°å‡ºäº†å‰æœŸçš„ä¼ç¬”å’Œè±¡å¾éšå–»ï¼Œå¤§é‡å›æ”¶ä¼ç¬”å’Œè½®å›çš„å±•å¼€ï¼Œä»¥åŠä¸€äº›å®éªŒæ€§çš„è¡¨è¾¾éƒ½éå¸¸è¿‡ç˜¾ã€‚åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œå°åœ†ä¹è§‚è€Œæœæ–­çš„äººæ ¼é­…åŠ›ä½“ç°çš„æ— ä»¥å¤åŠ ï¼Œæ²¡æœ‰ä¸€èˆ¬å¡‘é€ çš„åœ£æ¯çš„é‚£ç§æ‰­æ‰­ææï¼Œç»å‰é¡¾åï¼Œè¯´æ•‘å°±å»æ•‘ï¼Œåˆ†å¾—æ¸…ï¼Œæ”¾å¾—ä¸‹ï¼Œæ— æ•°æ¬¡çš„è½®å›ä¸­éƒ½åšå¾—æ— æ¯”æ­£ç¡®ï¼Œä¸”æœ‰å¾ˆå¤§çš„æˆé•¿ï¼Œæœ‰å†³å¿ƒæœ‰æ¯…åŠ›æœ‰é­„åŠ›ï¼Œåœ†ç¥ç§°å·åå‰¯å…¶å®ã€‚\nå…¨ç¯‡æ˜¯å¦‚ä½•æå†™ç„°å‘¢ï¼Ÿä»æŸ”å¼±çš„å¥³å­©å­å†åˆ°åˆæ¬¡çš„å›¢ç­ï¼Œæ— æ„é—´è®¸ä¸‹çš„ç¾å¥½æ„¿æœ›å¼€å¯äº†æ— å°½çš„è½®å›ã€‚åœ¨ä¸€æ¬¡æ¬¡è½®å›ä¸­é€æ¸å˜å¾—åšå¼ºï¼Œç†æ€§ï¼Œå¤–è¡¨å˜å¾—å†·æ¼ ï¼Œè€Œé€æ¸ä»è½¯å¼±çš„åœ†å¨æˆé•¿ä¸ºæ‰­æ›²çš„åœ†å¨ï¼Œå¼€å§‹èµ°å‘ä¸€ä¸ªè‡ªæˆ‘æ‰¿æ‹…ä¸€åˆ‡çš„æç«¯ã€‚ä½†æœ€ç»ˆå°åœ†è¿˜æ˜¯æ‹¯æ•‘äº†ç„°ï¼Œå°åœ†é‡æ–°ä»ç„°æ‰‹ä¸­æ‹¿å›ä¸€åˆ‡ï¼Œé€‰æ‹©è‡ªæˆ‘æ‰¿æ‹…ï¼Œè€Œç„°å¯¹æ­¤æ€…ç„¶è‹¥å¤±â€”â€”å¥¹ä¼¼ä¹å¹¶ä¸æƒ³è¦åœ†ç¥å½“ç¥æ¥ç€ã€‚\nå¥¹ä¸ºä»€ä¹ˆæƒ³è¦è‡ªå·±æ‰¿æ‹…ä¸€åˆ‡ï¼Ÿå› ä¸ºå¥¹ä¸æƒ³è®©å°åœ†æˆä¸ºé­”æ³•å°‘å¥³ï¼Œå¥¹æƒ³è®©å°åœ†è¿‡ä¸Šä¸€ä¸ªæ™®é€šäººçš„ç”Ÿæ´»ã€‚\nè€Œå¥¹è‡ªå·±çš„å®é™…çš„å†…å¿ƒæƒ³æ³•æ˜¯ä»€ä¹ˆï¼Ÿæˆ–è®¸æ˜¯æƒ³å’Œå°åœ†æ°¸è¿œåœ¨ä¸€èµ·ï¼Œæ™®æ™®é€šé€šåœ°ä½œç€é­”æ³•å°‘å¥³çš„å·¥ä½œï¼Œç®€ç®€å•å•çš„æŠŠç”Ÿæ´»è¿‡ä¸‹å»ã€‚\nå¥¹èƒ½åšåˆ°å—ï¼Ÿå¥¹åšä¸åˆ°ã€‚å¥¹æ˜¯é­”æ³•å°‘å¥³ï¼Œè€Œä¸ºäº†é¿å…å°åœ†çš„æ‚²å‰§ï¼Œå¥¹ä¸èƒ½è®©å°åœ†æˆä¸ºé­”æ³•å°‘å¥³ã€‚é­”æ³•å°‘å¥³å°±æ˜¯é­”å¥³ï¼Œä½œä¸ºé­”å¥³çš„å¥¹æ˜¯æ— æ³•å®ç°è¿™ä¸ªæ„¿æœ›çš„ã€‚å› æ­¤å¥¹çš„ä¸€å¼€å§‹çš„æ‰§å¿µå°±æ˜¯å¥‰çŒ®è‡ªå·±ï¼Œå¥¹ä»è®¸ä¸‹æ„¿çš„ä¸€å¼€å§‹ä¾¿æ²¡æœ‰é€€è·¯å¯èµ°ï¼Œå¥¹ä¾¿æ˜¯ä¸€ä¸ªå½»å¤´å½»å°¾çš„æ‚²å‰§è§’è‰²ã€‚\né‚£æ˜¯ä¸ºäº†æ‹¯æ•‘ä¸€ä¸ªäººæ‰€è‡ªå·±ç§ä¸‹çš„æœ€æ·±çš„ç»æœ›ã€‚å› æ­¤æ–°ç¯‡é‡Œè¯´è¿™æ˜¯â€œçˆ±â€ï¼Œçš„ç¡®æ˜¯æ— å¯éè®®ã€‚\nå†æ¥è¯´è¯´æ–°ç¯‡ã€‚\næ–°ç¯‡å³ç„°ä¸ªäººç¯‡ã€‚å…¨ç¯‡ä»¥ç„°ä¸ºä¸­å¿ƒå±•å¼€ï¼Œç„°çš„æ¢¦å¢ƒï¼Œç„°çš„æ‰§å¿µï¼Œç„°çš„é€‰æ‹©ã€‚\næ¢¦å¢ƒä½“ç°å‡ºäº†ç„°çš„ç†æƒ³ã€‚å¥¹çœŸæ­£æƒ³è¦çš„æ˜¯ä»€ä¹ˆï¼Ÿæ˜¯æƒ³å’Œåœ†ç¥æ°¸è¿œåœ¨ä¸€èµ·ã€‚æ˜¯é­”æ³•å°‘å¥³ä¸å†æœ‰ç»æœ›ï¼Œä¸å†æœ‰ä¼¤å®³çš„ä¸–ç•Œã€‚åœ¨ç„°å’Œåœ†ç¥çš„å¯¹è¯ä¸­ï¼Œåœ†ç¥ä¸€ç•ªè¯ä½¿ç„°æ¸…é†’åœ°è®¤è¯†åˆ°äº†è‡ªå·±çš„æ¬²æœ›ã€‚æˆ‘æƒ³è®©ä½ å½“ç¥å—ï¼Ÿæˆ‘æƒ³è®©ä½ ç‰ºç‰²è‡ªæˆ‘å—ï¼Ÿä¸æƒ³ã€‚æˆ‘åªæ˜¯æƒ³è®©ä½ ç®€ç®€å•å•è¿‡ä¸Šæ„‰å¿«çš„ç”Ÿæ´»ï¼Œä¸å†ä¸è¿™äº›æ®‹é…·çš„ä¸œè¥¿æœ‰ä»»ä½•çº è‘›ï¼Œä¸å†æ‰¿æ‹…ä»»ä½•äº‹ç‰©ï¼Œå¯ä»¥çš„è¯ï¼Œæƒ³å’Œä½ æ°¸è¿œå¾…åœ¨ä¸€èµ·ï¼Œä¸è®ºæ˜¯ä»¥ä»€ä¹ˆæ ·çš„å½¢å¼ã€‚äºæ˜¯è¿™ç§æ¬²æœ›ç»ˆäºä½¿å¤©ä¸‹ç¬¬ä¸€åœ†å¨è¿›åŒ–æˆäº†æ‰­æ›²çš„ç»ˆæå½¢å¼â€”â€”é­”å¥³çš„åŠ›é‡æ˜¯æœ‰æé™çš„ï¼Œäºæ˜¯ç„°é€‰æ‹©ä¸åšé­”å¥³ã€‚\nç„°çš„æ‰§å¿µï¼Œç„°çš„æ‚²å“€ï¼Œç„°çš„ç»æœ›åœ¨æœ€åé¢å¯¹å°åœ†çš„é€‰æ‹©æ—¶ä½“ç°çš„æ·‹æ¼“å°½è‡´ï¼Œå¥¹å¤ºå–åœ†ç¯ä¹‹ç†ï¼Œå°†å°åœ†çš„äººæ ¼å‰¥ç¦»ï¼Œæ„é€ æ–°çš„å®‡å®™ï¼Œå¹¶å°†QBä¸¢åˆ°å®‡å®™é‡Œæ‰¿è½½è¯…å’’ï¼Œå¼ºè¡Œæ„å»ºå‡ºäº†æ‰€è°“çš„â€œå¤©å ‚â€ã€‚è¿™å³æ˜¯ç„°çš„æ¬²æœ›ï¼Œç„°çš„æ¨æ„ã€‚ç„°ä»æ¥éƒ½ä¸æ˜¯åœ£æ¯ï¼Œç„°çš„æ‰€ä½œæ‰€ä¸ºä¸æ±‚ä»»ä½•äººçš„ç†è§£ï¼Œå³ä½¿æ˜¯å°åœ†ã€‚å³åœ¨æœ€åçš„æœ€åï¼Œç„°ç»ˆäºä»ä¸€ä¸ªä¸‰æ— èŒå¦¹å˜æˆäº†ä¸€ä¸ªä¸ºçˆ±æ‰€å›°çš„ç–¯å­ï¼Œå°†ä¸€åˆ‡çš„ä¸€åˆ‡éƒ½çŒ®ç»™â€œå¤©ä¸‹ç¬¬ä¸€åœ†å¨â€çš„æ ‡ç­¾ï¼Œå®ä¸ºå¯è´µï¼Œå®ä¸ºå¯æ•¬ã€‚\nå…¶ä¸­ä¸å¾—ä¸è¯´è¯´æˆ‘è§‰å¾—æœ€è¿·çš„éƒ¨åˆ†ã€‚\nå°åœ†ä¸‹å‡¡ã€‚â€œç„°æˆ‘æ¥æ¥ä½ äº†â€ æˆ‘å¯»æ€ä½ æ€ä¹ˆä¸æ—©äº›æ¥æ¥ç„°ï¼Œä½ æ‡‚ä¸ªé”¤å­ç„°ï¼Ÿ\nç„°ä¹‹æ‚²å“€åœ¨æ­¤åˆ»è¾¾åˆ°å·…å³°ã€‚\næ€»è€Œè¨€ä¹‹å°åœ†ä¸‰ç¯‡çœ‹ä¸‹æ¥ï¼Œæœ€å‡ºå½©çš„æ˜¯å…¶ä¸°å¯Œçš„å®éªŒæ€§è´¨çš„è¡¨è¾¾æ–¹å¼ï¼Œä»¥åŠä¸€ç§æˆ‘èƒ½æ„Ÿå—åˆ°çš„ç±»æ•…éšœç¾æ„Ÿã€‚è¿˜æœ‰å‡ºè‰²çš„éŸ³ä¹æ­é…ï¼Œç²¾å½©çš„æ¼”å‡ºï¼Œä¼˜ç§€çš„æ‰“æ–—åˆ¶ä½œå’Œå¯ä»¥çœ‹å‡ºæ¥æƒ³è¦å¤šåº¦å›è½¬çš„ä¸€æ³¢ä¸‰æŠ˜çš„å‰§æƒ…ã€‚\nä»¤æˆ‘ç¨å¾®æ„Ÿåˆ°æœ‰äº›æ— åŠ›çš„åˆ™æ˜¯ä¸¤ä¸ªç¯‡ç« çš„ç»“å°¾ã€‚\nä»¤æˆ‘ç¨å¾®æ„Ÿåˆ°å°´å°¬çš„æ˜¯ç¬¬ä¸€æ¬¡çœ‹åˆ°æ–°ç¯‡çš„å˜èº«éƒ¨åˆ†ï¼Œä½†å®é™…ä¸Šè¿™ç§æƒ³è¦æ¸²æŸ“é­”æ³•å°‘å¥³çš„ç¾å¥½ä¸åé¢æ›´æ˜¯å½¢æˆäº†ä¸€ç§è®½åˆºæ€§çš„åå·®ï¼Œå……æ»¡äº†å¯¼æ¼”çš„æ¶æ„ï¼Œæ‰€ä»¥å®é™…ä¸Šåšçš„ä¹Ÿä¸é”™ã€‚è€Œä¸”å˜èº«éƒ¨åˆ†æœ¬èº«çš„å¸ƒå±€å’Œæƒ³æ³•ä¹Ÿéƒ½æ˜¯ç›¸å½“æœ‰æ„æ€çš„ã€‚\nä»¤æˆ‘æ·±æ„Ÿå–œæ¬¢çš„è§’è‰²æ˜¯æå­ã€‚\nä»¤æˆ‘æ•¬ä½©å¾—äº”ä½“æŠ•åœ°çš„è§’è‰²æ— ç–‘æ˜¯æ™“ç¾ç„°ã€‚\nä»¤æˆ‘éå¸¸å¿ƒç–¼çš„è§’è‰²åˆ™æ˜¯ç„°å’Œå°åœ†ã€‚\nè™½ç„¶åªæ˜¯ç²—æµ…çš„ä¸€åˆ·ï¼Œä½†æ˜¯å°åœ†çš„åˆ¶ä½œä¼˜ç§€ï¼ŒåŠ ä¸Šå…¶å®éªŒæ€§è´¨çš„æ¼”å‡ºå’Œå¯ä»¥å¤šåŠ æ¨æ•²çš„ç»†èŠ‚å’Œå‰§æƒ…ï¼Œä½œå“æœ¬èº«å¯ä»¥ç®—æ˜¯ç›¸å½“ä¼˜ç§€ï¼Œå±äºéå¸¸å€¼å¾—ä¸€çœ‹çš„ä¸€åˆ—ã€‚\nä¹‹åæœ‰å¾…å¤šåˆ·ã€‚\n","oriTitle":"é­”æ³•å°‘å¥³ã¾ã©ã‹â˜†ãƒã‚®ã‚«","tags":["Anime"],"title":"é­”æ³•å°‘å¥³ã¾ã©ã‹â˜†ãƒã‚®ã‚«","uri":"/posts/madoka-magica/"},{"categories":["solution"],"content":"å–µã€‚\nProblem ç»™å‡ºä¸€å¼ è¢«åˆ’åˆ†å‡ºå¤šä¸ªåŒºåŸŸçš„å¹³é¢å›¾ã€‚åŒºåŸŸæŸ“ä¸åŒé¢œè‰²ä¼šæœ‰ä¸åŒçš„æƒå€¼ï¼Œå¦‚æœç›¸é‚»ä¸¤åŒºåŸŸé¢œè‰²ä¸åŒä¼šäº§ç”Ÿé¢å¤–è´¹ç”¨ã€‚æ±‚æœ€å¤§è´¡çŒ®ã€‚\nSolution å‰ç½®çŸ¥è¯†æ¯”è¾ƒå¤šï¼Ÿ\næè§’æ’åºå’Œæœ€å·¦è½¬çº¿ã€‚æè§’æ’åºå¯ä»¥ç”¨å‡½æ•° atan2(y, x) æ±‚å‡º $\\arctan \\frac{y}{x}$ ï¼Œè¿”å› $[-\\pi, \\pi]$ çš„ç»“æœã€‚å¦‚æœå°äºé›¶å°±åŠ ä¸Šä¸ª $2\\pi$ å§ï¼Œç„¶åæ’åºå°±è¡Œäº†ã€‚\nå› ä¸ºæœ‰å¯èƒ½è¢«å¡ç²¾åº¦ï¼Œä½ ä¹Ÿå¯ä»¥ç”¨è±¡é™æ’åºã€‚å¦‚æœåŒä¸€è±¡é™å°±å‰ç§¯ï¼Œå¦åˆ™æ¯”è±¡é™ã€‚å¤ªéš¾æ‰“å°±æ²¡æ‰“äº†ã€‚\nç„¶åæœ€å·¦è½¬çº¿ç”¨äºæ±‚è¿™ç§å¸¦åæ ‡çš„å¹³é¢å›¾å’Œå¯¹å¶å›¾è½¬åŒ–ã€‚å…·ä½“è¯·å‚è§ miskcoo\u0026rsquo;s Blog ï¼Œè¿™é‡Œè®²å¾—æ¯”è¾ƒå¥½ï¼Œä»£ç ä¹Ÿå†™å¾—å¾ˆå¥½ã€‚\nå°±æ˜¯ç»†èŠ‚ä¸å°‘ã€‚\nç„¶åæˆ‘ä»¬å‘ç°é¢˜é¢çš„æ„æ€å…¶å®åªéœ€è¦æˆ‘ä»¬æ±‚ä¸€ç§åŒ¹é…æ–¹æ¡ˆä½¿å¾— W å’Œ B è¿˜æœ‰ç›¸é‚»äº§ç”Ÿçš„æ€»è´¡çŒ®é‡æœ€å°ï¼Œç„¶åç”¨ W å’Œ B çš„æ€»å€¼å‡å»è¿™ä¸ªå€¼å³å¯ã€‚\nç½‘ç»œæµå˜›ã€‚éšä¾¿è·‘è·‘ã€‚\nCode // Code by ajcxsu // Problem: everfeel #define _USE_MATH_DEFINES #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=4e4+10, M=4e5+10; struct P { int x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } double ang() { double ang=atan2(y, x); if(ang\u0026lt;0) ang+=2.0*M_PI; return ang;} } p[N]; struct Edge { int w, u, v; double ang; } e[M]; vector\u0026lt;int\u0026gt; to[N]; int tp[N]; int ridx, mp; int a[N], b[N], rk[M], bel[M]; int A[M], B[M], tot; void ins(int a, int b, int w) { e[mp++]={w, a, b, (p[b]-p[a]).ang()}; } namespace NS { const int s=N-1, t=N-2; int h[N], to[M], nexp[M], W[M], p=2; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } #define sins(x, y, z) ins(x, y, z), ins(y, x, 0) int fl[N]; bool bfs() { queue\u0026lt;int\u0026gt; qu; qu.push(s); memset(fl, 0, sizeof(fl)); fl[s]=1; while(!qu.empty()) { int na=qu.front(); qu.pop(); for(int u=h[na];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; !fl[to[u]]) fl[to[u]]=fl[na]+1, qu.push(to[u]); } return fl[t]; } #define INF (0x3f3f3f3f) int dfs(int x, int op) { if(x==t) return op; int flow=0; for(int u=h[x];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; fl[to[u]]==fl[x]+1) { int d=dfs(to[u], min(op-flow, W[u])); W[u]-=d, W[u^1]+=d, flow+=d; if(flow==op) break; } if(!flow) fl[x]=0; return flow; } void work() { for(int i=0; i\u0026lt;mp; i+=2) ins(bel[i], bel[i+1], e[i].w), ins(bel[i+1], bel[i], e[i].w); for(int i=1; i\u0026lt;=ridx; i++) sins(s, i, A[i]), sins(i, t, B[i]), tot+=A[i]+B[i]; int flow=0; while(bfs()) flow+=dfs(s, INF); printf(\u0026quot;%d\\n\u0026quot;, tot-flow); } } bool vis[N]; void findreg(int x, int eid) { if(vis[eid]) return; ++ridx; while(!vis[eid]) { vis[eid]=1; bel[eid]=ridx, x=e[eid].v; A[ridx]+=a[x], B[ridx]+=b[x]; if(!rk[eid^1]) eid=to[x].back(); else eid=to[x][rk[eid^1]-1]; } } int main() { #ifndef LOCAL freopen(\u0026quot;everfeel.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;everfeel.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif int num; gn(num); int n, m; gn(n), gn(m); int u, v, w; for(int i=1; i\u0026lt;=n; i++) gn(u), gn(v), p[i]={u, v}, gn(a[i]), gn(b[i]); vector\u0026lt;pair\u0026lt;double, int\u0026gt; \u0026gt; tmp; for(int i=1; i\u0026lt;=m; i++) { gn(u), gn(v), gn(w); ins(u, v, w); ins(v, u, w); } for(int i=0; i\u0026lt;mp; i++) tmp.push_back(make_pair(e[i].ang, i)); sort(tmp.begin(), tmp.end()); for(int i=0; i\u0026lt;mp; i++) { int eid=tmp[i].second; rk[eid]=to[e[eid].u].size(); to[e[eid].u].push_back(eid); } for(int i=1; i\u0026lt;=n; i++) for(int j=0; j\u0026lt;to[i].size(); j++) findreg(i, to[i][j]); NS::work(); return 0; } ","oriTitle":"JZOJ6092 é™„è€³è€Œè‡³","tags":["è®¡ç®—å‡ ä½•","ç½‘ç»œæµ"],"title":"JZOJ6092 é™„è€³è€Œè‡³","uri":"/posts/sol-jzoj-6092/"},{"categories":["solution"],"content":"è½¬åŒ–æ¯”è¾ƒå·§å¦™ï¼Œè€ƒåœºä¸Šæƒ³å‚»é€¼äº†çš„é¢˜ç›®ã€‚å¾ˆå¥½æ‰“ã€‚\nProblem ç»™å®šä¸€æ£µåªæœ‰ä¸€ä¸ªç‚¹çš„æ ‘ï¼Œ1e5æ¬¡æ“ä½œï¼Œæ¯æ¬¡åŠ ä¸€ä¸ªç‚¹åé—®è‡³å¤šäº¤æ¢ä¸€æ¬¡ä¸¤æ£µå­æ ‘åçš„æœ€å¤§ç›´å¾„é•¿åº¦ã€‚å¼ºåˆ¶åœ¨çº¿ã€‚\nSolution è€ƒè™‘äº‹å®ä¸Šå°±æ˜¯æŠŠç›´å¾„ä¸Šçš„é“¾å‰–å‡ºç„¶åè¯¢é—®æœ€é•¿æ”¯é“¾çš„é•¿åº¦ $lp$ ï¼Œç­”æ¡ˆå°±æ˜¯ $d+max(lp-1, 0)$ ã€‚\né‚£ä¹ˆè€ƒè™‘æ¯æ¬¡åŠ å…¥ä¸€ä¸ªç‚¹ä¹‹åç›´å¾„å’Œæœ€é•¿æ”¯é“¾çš„å˜åŒ–ã€‚å¦‚æœç›´å¾„å˜åŒ–ï¼Œè€ƒè™‘å¦ä¸€æ¡è¢«æ¢ä¸‹æ¥çš„æ”¯é“¾ä¸€å®šæ˜¯è¿™æ¡åŸæ”¯é“¾çš„ç°é•¿åº¦-1ã€‚é‚£ä¹ˆå¦‚æœåŸæ”¯é“¾çš„åŸé•¿åº¦å°±æ˜¯æœ€é•¿æ”¯é“¾ï¼Œå°±ç›´æ¥è€ƒè™‘å¦ä¸€æ¡è¢«æ¢ä¸‹æ¥çš„æ”¯é“¾æ›´æ–°æœ€é•¿æ”¯é“¾å³å¯ã€‚å¦‚æœä¸æ˜¯æœ€é•¿æ”¯é“¾ï¼Œé‚£ä¹ˆç†è®ºä¸Šæœ€é•¿æ”¯é“¾æ˜¯ä¸ä¼šå˜åŒ–çš„ï¼Œä½†æ˜¯ä¸ºäº†é¿å…å¥‡æ€ªçš„é”™è¯¯æˆ‘ä»¬è¿˜æ˜¯è¦æ›´æ–°ä¸€ä¸‹æœ€é•¿æ”¯é“¾çš„ç‚¹ã€‚\nå¦‚æœç›´å¾„ä¸å˜åŒ–ï¼Œé‚£ä¹ˆç›´æ¥ç”¨æ–°åŠ çš„ç‚¹æ›´æ–°æœ€é•¿æ”¯é“¾å³å¯ã€‚\nå€å¢ç»´æŠ¤ã€‚\nCode // Code by ajcxsu // Problem: forest #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10, OP=19; int gup[OP][N], dep[N]; void add(int x, int fa) { gup[0][x]=fa, dep[x]=dep[fa]+1; for(int j=1; j\u0026lt;OP; j++) gup[j][x]=gup[j-1][gup[j-1][x]]; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } int dis(int s, int t) { return dep[s]+dep[t]-2*dep[lca(s, t)]; } int u=1, v=1, p=1, fa, len, lp, lst; int cac(int x) { return dis(x, u)+dis(x, v)-len\u0026gt;\u0026gt;1; } int main() { #ifndef LOCAL freopen(\u0026quot;forest.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;forest.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif dep[1]=1; int n, tod; gn(n), gn(n); int tmp; for(int i=2; i\u0026lt;=n; i++) { gn(fa), fa^=lst; add(i, fa); int la=dis(u, i), lb=dis(v, i); if(la\u0026gt;len || lb\u0026gt;len) { if(la\u0026gt;lb) tod=v, v=i, len=la; else tod=u, u=i, len=lb; if((tmp=cac(tod))\u0026gt;lp) lp=tmp, p=tod; } else if(((la+lb-len)\u0026gt;\u0026gt;1)\u0026gt;lp) lp=(la+lb-len)\u0026gt;\u0026gt;1, p=i; printf(\u0026quot;%d\\n\u0026quot;, lst=len+max(lp-1, 0)); } return 0; } ","oriTitle":"JZOJ6096 æ£®æ—","tags":["å€å¢","æ ‘çš„ç›´å¾„"],"title":"JZOJ6096 æ£®æ—","uri":"/posts/sol-jzoj-6096/"},{"categories":["solution"],"content":"è°ƒè°ƒæ”¹æ”¹äº†ä¸€æ™šä¸Šæ‰è¿‡æ‰ã€‚æ€»è€Œè¨€ä¹‹è¿˜æ˜¯è‡ªå·±å¯¹é¢˜ç›®ç†è§£å¤ªä¸æ·±åˆ»äº†ã€‚åŸºæœ¬ä¸Šæ˜¯å¯¹ç€æŠ„ä½†æ˜¯åˆæŠ„å¾—å¾ˆæ— å¥ˆã€‚\nSolution ä¸è€ƒè™‘åŒºé—´é™åˆ¶çš„è¯ï¼Œåˆ™ $S, T$ åŒæ—¶åŒ¹é…ã€‚å¦‚æœ $S$ å‘ $c$ è¾¹è½¬ç§»å‡ºç°äº†ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°† $S$ å‘ä¸Šè·³åˆ°åŒ¹é…ä¸ºæ­¢ï¼ŒåŒæ—¶ $T$ ä¹Ÿåº”è¯¥å‘ä¸Šè·³ä½¿å¾— $len$ ä¸ç°å¤„çš„çŠ¶æ€ç›¸ç¬¦ã€‚\nè€ƒè™‘åŒºé—´é™åˆ¶çš„è¯ï¼Œæˆ‘ä»¬ä½¿ç”¨çº¿æ®µæ ‘åˆå¹¶ç»´æŠ¤æ ‘çš„ $endpos$ é›†åˆã€‚é‚£ä¹ˆå¯¹äºå·²ç»å›ºå®šäº†çš„å­—ç¬¦ä¸²é•¿åº¦ $l\u0026rsquo;$ ï¼Œéœ€è¦åŠ ä¸Šå­—ç¬¦ $c$ ï¼Œè¦æ±‚ $S$ è½¬ç§»åæ‰€å¤„çŠ¶æ€çš„ $endpos$ å­˜åœ¨äº $[l+l\u0026rsquo;, r]$ ã€‚å¦åˆ™æˆ‘ä»¬éœ€è¦å°† $l\u0026rsquo;$ ä¸€æ­¥æ­¥å‡å° æ¥æŸ¥çœ‹æ˜¯å¦åŒ¹é…ã€‚å½“ $l\u0026rsquo;=len[fa[p]]$ æ—¶éœ€è¦å°† $p$ å‘ä¸Šè½¬ç§»ã€‚\næˆ‘ä»¬åŒæ—¶éœ€è¦æ„è¯†åˆ°æˆ‘ä»¬å¯ä»¥åœ¨ $S$ çš„ parent æ ‘ä¸Šç›´æ¥è½¬ç§»ï¼Œä¸”è½¬ç§»åˆ°çš„èŠ‚ç‚¹çš„ $len$ æ˜¯ç¬¦åˆå‡æƒ³åŒºé—´ parent æ ‘æ„é€ çš„ï¼ˆæˆ–è€…ç•¥å¤§ï¼Œä½†å¦‚æœå‘ä¸Šè·³ä¸€å®šç¬¦åˆï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬è½¬ç§»åˆ°çš„çŠ¶æ€ä¸€å®šåœ¨åŒºé—´ parent æ ‘ä¸Šå­˜åœ¨ã€‚è¿™éƒ¨åˆ†æˆ‘è§‰å¾—æˆ‘å¯èƒ½è¿˜éœ€è¦å†åŠ æ·±ç†è§£ã€‚\nå£èƒ¡ä¸€ä¸‹ï¼šå¯¹äºSAMï¼Œå¦‚æœä»çŠ¶æ€ $A$ è½¬ç§»åˆ°çŠ¶æ€ $B$ ï¼Œä½ éœ€è¦ä¿è¯å¦‚ä¸‹æ¡ä»¶ï¼š$endpos$ é›†åˆå­˜åœ¨ï¼Œä¸” $len\u0026rsquo;$ å±äºç»“ç‚¹æ‰€å± $len$ åŒºé—´ã€‚ç”±äº $len\u0026rsquo;=len+1$ ï¼Œæ‰€ä»¥åªéœ€è¦ä¿è¯ $endpos$ åˆæ³•å³å¯ã€‚\nCode // Code by ajcxsu // Problem: yourname. #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=3e6+10, M=5e7+10; struct Node { int ch[26]; int len, fa; void clr() { len=fa=0; memset(ch, 0, sizeof(ch)); } } ; struct Tree *nil; struct Tree { int v, t; Tree *ls, *rs; } po[M], *pp=po; void ini() { nil=pp++; nil-\u0026gt;ls=nil-\u0026gt;rs=nil; } Tree* newn() { assert(pp!=po+M), *pp=*nil; return pp++; } void updata(Tree *\u0026amp;x, int l, int r, int d) { if(x==nil) x=newn(); x-\u0026gt;v=max(x-\u0026gt;v, d); if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d); else updata(x-\u0026gt;rs, mid+1, r, d); } Tree* Merge(Tree *x, Tree *y) { Tree *o=newn(); if(x==nil || y==nil) return x==nil?y:x; o-\u0026gt;v=max(x-\u0026gt;v, y-\u0026gt;v); o-\u0026gt;ls=Merge(x-\u0026gt;ls, y-\u0026gt;ls), o-\u0026gt;rs=Merge(x-\u0026gt;rs, y-\u0026gt;rs); return o; } int query(Tree *x, int l, int r, int xr) { if(r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=query(x-\u0026gt;ls, l, mid, xr); if(xr\u0026gt;mid) ret=max(ret, query(x-\u0026gt;rs, mid+1, r, xr)); return ret; } typedef long long ll; struct SAM { Node nd[N]; int idx=1, lst=1; int g[N]; Tree *tr[N]; void add(int c, int mode) { int p=lst, np=lst=++idx; nd[np].clr(), nd[np].len=nd[p].len+1; if(mode) updata(tr[idx], 0, N, nd[np].len); for(; p \u0026amp;\u0026amp; !nd[p].ch[c]; p=nd[p].fa) nd[p].ch[c]=np; if(!p) nd[np].fa=1; else { int q=nd[p].ch[c]; if(nd[q].len==nd[p].len+1) nd[np].fa=q; else { int nq=++idx; nd[nq]=nd[q]; nd[nq].len=nd[p].len+1, nd[q].fa=nd[np].fa=nq; for(; p \u0026amp;\u0026amp; nd[p].ch[c]==q; p=nd[p].fa) nd[p].ch[c]=nq; } } } int id[N], bu[N]; void sort() { fill(bu, bu+idx+1, 0); // !! for(int i=1; i\u0026lt;=idx; i++) bu[nd[i].len]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[nd[i].len]--]=i; } ll ftot; void ini1() { for(int i=idx; i\u0026gt;=2; i--) ftot+=nd[i].len-nd[nd[i].fa].len; } void ini2() { for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; tr[nd[tmp].fa]=Merge(tr[nd[tmp].fa], tr[tmp]); } } char str[N]; int n; void ini(int mode=0) { idx=lst=1; ftot=0; n=strlen(str); if(mode) fill(tr, tr+N, nil); nd[1].clr(); for(int i=0; i\u0026lt;n; i++) add(str[i]-'a', mode); sort(); fill(g, g+idx+1, 0); if(!mode) ini1(); else ini2(); } ll deal() { ll cnt=0; for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; g[tmp]=min(g[tmp], nd[tmp].len); g[nd[tmp].fa]=max(g[nd[tmp].fa], g[tmp]); cnt+=max(g[tmp]-nd[nd[tmp].fa].len, 0); // å¿˜å–maxäº†... } return ftot-cnt; } inline int mov(int x, char ch) { return nd[x].ch[ch-'a']; } } s, t; int main() { ini(); scanf(\u0026quot;%s\u0026quot;, s.str); s.ini(1); int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int l, r; while(T--) { scanf(\u0026quot;%s%d%d\u0026quot;, t.str, \u0026amp;l, \u0026amp;r); t.ini(); int na=1, nb=1, len=0, to; bool chg; for(int i=0; i\u0026lt;t.n; i++) { to=s.mov(na, t.str[i]); nb=t.mov(nb, t.str[i]); chg=0; while(na \u0026amp;\u0026amp; (!to || query(s.tr[to], 0, N, r)\u0026lt;l+len)) { if(!len) { na=0; break; } len--; if(len==s.nd[s.nd[na].fa].len) na=s.nd[na].fa, to=s.mov(na, t.str[i]); } if(!na) na=1, len=0; else na=to, len++; while(nb \u0026amp;\u0026amp; t.nd[t.nd[nb].fa].len\u0026gt;=len) nb=t.nd[nb].fa; nb+=!nb; t.g[nb]=max(t.g[nb], len); } printf(\u0026quot;%lld\\n\u0026quot;, t.deal()); } return 0; } ","oriTitle":"NOI2018 ä½ çš„åå­—","tags":["SAM","çº¿æ®µæ ‘åˆå¹¶"],"title":"NOI2018 ä½ çš„åå­—","uri":"/posts/sol-your-name/"},{"categories":["solution"],"content":"å¸¸æ•°åˆ¶é€ æœº\u0026hellip;\nSolution è€ƒè™‘ä¸é‡å¤çš„è®¡ç®—è´¨å› æ•°ã€‚ä»¤ ${p_i}^{k_i}$ å½¢å¼çš„è´¨å› æ•°æˆä¸ºä¸€ç§é¢œè‰²ï¼Œè´¡çŒ®ä¸º $p$ ï¼Œåˆ™æœ€å¤šå¯åˆ†å‰²å‡º $n\\log V$ ç§é¢œè‰²ï¼Œç°åœ¨è¦åšçš„æ˜¯å¯¹é™å®šæ·±åº¦ä¸é‡å¤è®¡ç®—é¢œè‰²çš„è´¡çŒ®ã€‚\né‚£ä¹ˆå¯¹æ·±åº¦è®¾ä¸»å¸­æ ‘ï¼ˆæ¯ä¸€å±‚çš„è¯æ˜¯åŠ¨æ€å¼€ç‚¹ï¼‰ï¼Œç„¶åå¯¹æ¯ä¸ªé¢œè‰²è®¡ç®—æ ‘ä¸Šå·®åˆ†è¿›è¡Œè´¡çŒ®ã€‚åŒæ—¶å¯¹äºæ¯ä¸ªé¢œè‰²è®°å½•ä¸€ä¸ª set æ¥ç»´æŠ¤å·²å‡ºç° dfn åºï¼Œå¦‚æœæ–°åŠ å…¥äº†ä¸€ä¸ªé¢œè‰²åœ¨æ ‘ä¸Šè®¡ç®—ä¸ dfs åºç›¸é‚»çš„å·²å‡ºç°çš„ç‚¹çš„è´¡çŒ®çš„å˜åŒ–é‡ã€‚æŸ¥è¯¢çš„æ—¶å€™ç›´æ¥åœ¨ä¸»å¸­æ ‘ä¸ŠæŸ¥è¯¢å³å¯ã€‚\nå¤æ‚åº¦å¤§æ¦‚æ˜¯ $\\log^2$ çº§åˆ«ï¼Ÿç©ºé—´å¤æ‚åº¦æ˜¯ç„å­¦\u0026hellip;\nCode // Code by ajcxsu // Problem: half #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int K=1e7+10, N=1e5+10, OP=19; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } typedef pair\u0026lt;int, int\u0026gt; mpa; int dep[N], dl[N], dr[N], dd[N], idx; int gup[OP][N]; void dfs(int x, int k) { dep[x]=k, dl[x]=++idx, dd[idx]=x; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { dfs(to[u], k+1); gup[0][to[u]]=x; } dr[x]=idx; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } struct Dot { int x, k, i; } ; bool cmp(const Dot \u0026amp;a, const Dot \u0026amp;b) { return dep[a.x]\u0026lt;dep[b.x]; } vector\u0026lt;Dot\u0026gt; dot; vector\u0026lt;mpa\u0026gt; lis; int val[N]; int pri[K], pre[K], inv[K], pp; bool npri[K]; void di(int x, int y) { int k=0, rua=0; while(x\u0026gt;1) { if(rua!=pre[x]) rua=pre[x], k=0; k++; lis.push_back(mpa(rua, k)); dot.push_back({y, rua, k}); x/=rua; } } struct Node *nil; struct Node { Node *ls=nil, *rs=nil; int v=1, t=0; } ; Node *nd[N]; void ini() { nil=new Node, nil-\u0026gt;ls=nil-\u0026gt;rs=nil; nd[0]=nil; } void updata(Node *\u0026amp;x, int l, int r, int d, int v, int nt) { if(x-\u0026gt;t!=nt) { Node *nd=new Node; *nd=*x, x=nd; x-\u0026gt;t=nt; } x-\u0026gt;v=1ll*x-\u0026gt;v*v%MOD; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d, v, nt); else updata(x-\u0026gt;rs, mid+1, r, d, v, nt); } int query(Node *x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=1; if(xl\u0026lt;=mid) ret=1ll*ret*query(x-\u0026gt;ls, l, mid, xl, xr)%MOD; if(xr\u0026gt;mid) ret=1ll*ret*query(x-\u0026gt;rs, mid+1, r, xl, xr)%MOD; return ret; } set\u0026lt;int\u0026gt; s[N*25]; int main() { #ifndef LOCAL freopen(\u0026quot;half.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;half.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif ini(); ios::sync_with_stdio(false), cin.tie(0); /* pri inv */ inv[1]=1; for(int i=2; i\u0026lt;K; i++) inv[i]=(MOD-1ll*MOD/i*inv[MOD%i]%MOD); npri[1]=1; for(int i=2; i\u0026lt;K; i++) { if(!npri[i]) pri[pp++]=i, pre[i]=i; for(int j=0; j\u0026lt;pp \u0026amp;\u0026amp; i*pri[j]\u0026lt;K; j++) { npri[i*pri[j]]=1, pre[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; } } /* input */ int k, n; gn(k), gn(n); int na; for(int i=1; i\u0026lt;=n; i++) { gn(na); di(na, i); } int u, v; for(int i=1; i\u0026lt;n; i++) gn(u), gn(v), ins(u, v), ins(v, u); /* up */ dfs(1, 1); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; /* lis */ sort(lis.begin(), lis.end()); int tk=unique(lis.begin(), lis.end())-lis.begin(); for(int i=0; i\u0026lt;tk; i++) val[i]=lis[i].first; for(Dot \u0026amp;x:dot) x.k=lower_bound(lis.begin(), lis.begin()+tk, mpa(x.k, x.i))-lis.begin(); sort(dot.begin(), dot.end(), cmp); /* add */ int j=0; int nx, nc, mdep=dep[dot.rbegin()-\u0026gt;x]; for(int i=1; i\u0026lt;=mdep; i++) { nd[i]=nd[i-1]; while(j\u0026lt;dot.size() \u0026amp;\u0026amp; dep[dot[j].x]\u0026lt;=i) { nx=dot[j].x, nc=dot[j].k; auto it=s[nc].lower_bound(dl[nx]); int rx=(it==s[nc].end()?-1:dd[*it]); int lx=(it==s[nc].begin()?-1:dd[*(--it)]); updata(nd[i], 1, n, dl[nx], val[nc], i); if(rx!=-1 \u0026amp;\u0026amp; lx!=-1) updata(nd[i], 1, n, dl[lca(lx, rx)], val[nc], i); if(lx!=-1) updata(nd[i], 1, n, dl[lca(lx, nx)], inv[val[nc]], i); if(rx!=-1) updata(nd[i], 1, n, dl[lca(nx, rx)], inv[val[nc]], i); s[nc].insert(dl[nx]); j++; } } /* query */ int q, lstans=0; gn(q); while(q--) { gn(u), gn(v), u=u^(k*lstans), v=v^(k*lstans); printf(\u0026quot;%d\\n\u0026quot;, lstans=query(nd[min(dep[u]+v, mdep)], 1, n, dl[u], dr[u])); } return 0; } ","oriTitle":"JZOJ6086 åŠ¨æ€åŠå¹³é¢äº¤","tags":["STL","ä¸»å¸­æ ‘"],"title":"JZOJ6086 åŠ¨æ€åŠå¹³é¢äº¤","uri":"/posts/sol-jzoj-6086/"},{"categories":["algorithm"],"content":"qia ke è¿˜æ˜¯ ka qiao ï¼Ÿ\nå‡¸åŒ… å¯¹å‘é‡ $\\vec{a} \\times \\vec{b}$ çš„è¿ç®—çš„æ­£è´Ÿå€¼ç”± $\\vec{a}$ æ—‹è½¬åˆ° $\\vec{b}$ çš„è§’åº¦çš„ $\\cos$ å†³å®šï¼ˆå«æ­£è´Ÿå·ï¼‰ã€‚å› æ­¤å¦‚æœ $\\vec{a}$ åˆ° $\\vec{b}$ æ˜¯é€†æ—¶é’ˆæ—‹è½¬å®ƒä»¬çš„å‰ç§¯å°±æ˜¯æ­£æ•°ï¼Œå¦åˆ™åä¹‹ã€‚\né‚£ä¹ˆ $x$ æ’åºåå·¦å³é¡ºåºæ‰«ä¸€éä¸Šä¸‹å‡¸åŒ…ã€‚å¯¹äºæŒ‰é¡ºåºæ„æˆå‡¸åŒ…çš„å‘é‡ï¼Œä¸€å®šæ˜¯é¡ºæ—¶é’ˆæ—‹è½¬ï¼Œå¦åˆ™ä¾¿ä¸ç¬¦åˆå‡¸åŒ…çš„å®šä¹‰ã€‚å› æ­¤ä½¿ç”¨æ ˆæ¥ç»´æŠ¤ï¼Œå¦‚æœå‡ºç°äº†é€†æ—¶é’ˆæ—‹è½¬åˆ™é€€æ ˆã€‚\nè¢«ç§°ä½œ Graham Scan ç®—æ³•ã€‚\næ³¨æ„ä¸€äº›é‡å¤ç‚¹çš„ç»†èŠ‚ã€‚\næ—‹è½¬å¡å£³ ç”¨äºè®¡ç®—å‡¸åŒ…ç‚¹å¯¹çš„æœ€é•¿è·ç¦»ã€‚è€ƒè™‘æšä¸¾ä¸€æ¡è¾¹ï¼Œå†è€ƒè™‘è¯¥è¾¹çš„å¯¹è¸µç‚¹ï¼ˆè·ç¦»è¯¥è¾¹è·ç¦»æœ€å¤§ç‚¹ï¼‰ï¼Œæšä¸¾è¿™æ ·æ‰€æœ‰çš„ç‚¹è¾¹å¯¹å³å¯è·å–æœ€é•¿è·ç¦»ã€‚å¯ä»¥ $O(n)$ æ‰«è¿‡ï¼Œè€Œä¸”è¯¯å·®è¾ƒå°ã€‚\næ³¨æ„ä¸€äº›ç»†èŠ‚ï¼ŒåŒæ—¶ç‰¹åˆ¤å‡¸åŒ…å¤§å°ä¸º $3$ çš„æƒ…å†µï¼Œè¿™æ„å‘³ç€æ‰€æœ‰ç‚¹éƒ½å¤„äºåŒä¸€ç›´çº¿ä¸Šã€‚\nCode - Beauty Contest // Code by ajcxsu // Problem: xuan zhuan qia qiao #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5e4+10; typedef long long ll; struct P { ll x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } ll norm() { return x*x+y*y; } double dis() { return sqrt(norm()); } } p[N], con[N]; ll cross(P a, P b) { return a.x*b.y-a.y*b.x; } bool cmp(const P \u0026amp;a, const P \u0026amp;b) { return a.x==b.x?a.y\u0026lt;b.y:a.x\u0026lt;b.x; } inline ll dpow(ll x) { return x*x; } double dis(P a, P b, P x) { return (double)abs(cross(a-x, b-x))/(a-b).dis(); } int t; int main() { ios::sync_with_stdio(false), cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;p[i].x\u0026gt;\u0026gt;p[i].y; sort(p+1, p+1+n, cmp); for(int i=1; i\u0026lt;=n; i++) { while(t\u0026gt;=2 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } int t2=t; for(int i=n-1; i\u0026gt;=1; i--) { while(t\u0026gt;=t2+1 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } if(t==3) cout\u0026lt;\u0026lt;(con[1]-con[2]).norm()\u0026lt;\u0026lt;endl, exit(0); int nt=1; ll ans=0; for(int i=1; i\u0026lt;t; i++) { while(dis(con[i], con[i+1], con[nt])\u0026lt;=dis(con[i], con[i+1], con[nt+1])) nt=nt%(t-1)+1; ans=max({ans, (con[i]-con[nt]).norm(), (con[i+1]-con[nt]).norm()}); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"å‡¸åŒ…ä¸æ—‹è½¬å¡å£³","tags":["è®¡ç®—å‡ ä½•","å‡¸åŒ…","æ—‹è½¬å¡å£³"],"title":"å‡¸åŒ…ä¸æ—‹è½¬å¡å£³","uri":"/posts/convex-hull-and-qia-qiao/"},{"categories":["solution"],"content":"Problem ç»™å®š $n$ ï¼Œæ±‚æœ‰å¤šå°‘ä¸ª $1\\to n$ çš„æ’åˆ—å¯ä»¥åˆ†å‰²æˆä¸‰ä¸ªä¸Šå‡å­åºåˆ—ã€‚$n \\leq 500$ã€‚\nSolution å‡è®¾ç»™å®šä¸€ä¸ªæ’åˆ—ï¼Œé‚£ä¹ˆæˆ‘ä»¬è´ªå¿ƒçš„ä»å‰å¾€åé€‰ï¼Œç»´æŠ¤ä¸‰ä¸ªä¸Šå‡åºåˆ—ï¼Œæ¯æ‰«åˆ°ä¸€ä¸ªæ•°å­—æ·»åŠ åˆ°èƒ½æ”¾çš„ä¸Šå‡åºåˆ—ä¸”ä¿è¯åŸä¸Šå‡åºåˆ—çš„æœ€å¤§å€¼å°½é‡å¤§ã€‚è¿™æ ·ä¸€å®šèƒ½æ„é€ å‡ºä¸€ç§åˆæ³•æ–¹æ¡ˆï¼ˆå¦‚æœæœ‰ï¼‰ä¸”åˆ†å‰²æ–¹æ¡ˆå”¯ä¸€ã€‚\nè€ƒè™‘ä¸‰ä¸ªåºåˆ—çš„æœ€å¤§å€¼è®¾è®¡çŠ¶æ€ã€‚ç”±äºä¸æ¸…æ¥šæ’å…¥çš„æ•°å…·ä½“æ˜¯ä»€ä¹ˆï¼Œæˆ‘ä»¬ä»¤å…¶ä¸ºç›¸å¯¹å¤§å°ï¼š $f_{i, j, k}$ ï¼Œä¸”ä»¤ $i\u0026gt;j\u0026gt;k\\geq 0$ ã€‚åŒæ—¶å­˜åœ¨ $j=k=0$ çš„æƒ…å†µã€‚\né‚£ä¹ˆæˆ‘ä»¬æ’å…¥ä¸€ä¸ªæ–°çš„ç›¸å¯¹å¤§å°ä¸º $l \\in [1, i+1]$ çš„å€¼ã€‚é‚£ä¹ˆåŸç›¸å¯¹å¤§å°å¤„äº $[l, i]$ åŒºé—´çš„å€¼éƒ½ä¼šè¢«å¾€åé¡¶æˆ $[l+1, i+1]$ ã€‚åˆ™æˆ‘ä»¬åˆ†æƒ…å†µè®¨è®º $l$ çš„è½¬ç§»ï¼š\n$$ f_{i, j, k} \\rightarrow \\begin{cases} f_{i+1, j+1, l} \u0026amp; \\text{for } k\u0026lt;l\\leq j\\\\ f_{i+1, l, k} \u0026amp; \\text{for }j\u0026lt;l \\leq i\\\\ f_{i+1, j, k} \u0026amp; \\text{for }l=i+1 \\end{cases} $$\nå·®åˆ†å³å¯ä¼˜åŒ–åˆ° $O(n^3)$ ã€‚\nCode #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=501; int f[2][N][N], g[2][N][N]; int u, v=1; int n, P; int add(int \u0026amp;x, int y) { x+=y; if(x\u0026gt;=P) x-=P; return x; } int main() { freopen(\u0026quot;yuan.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;yuan.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); ios::sync_with_stdio(false), cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;P; f[v][0][0]=1; int ans=0; for(int i=1; i\u0026lt;=n; i++) { u^=1, v^=1; for(int j=0; j\u0026lt;i-1;j++) for(int k=0; k\u0026lt;=j; k++) f[v][j][k]=g[v][j][k]=0; for(int j=0; j\u0026lt;i-1; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j+1][k+1],f[u][j][k]), add(f[v][j+1][j+1],-f[u][j][k]), add(g[v][j+1][k],f[u][j][k]), add(g[v][i][k],-f[u][j][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j][k],f[v][j][k-1]), add(g[v][j][k],g[v][j-1][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) { add(f[v][j][k],add(g[v][j][k],f[u][j][k])); if(i==n) add(ans, f[v][j][k]); } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"JZOJ2090 åœ†","tags":["DP"],"title":"JZOJ2090 åœ†","uri":"/posts/sol-jzoj-2090/"},{"categories":["solution"],"content":"å¥½é¢˜å¥½åšæ³•\u0026hellip;\næ„Ÿè°¢ gjx çš„è®²è§£ã€‚\nSolution è¦ç”¨åˆ°çš„ç»“è®ºï¼š $\\frac{1}{a}\\frac{1}{b}=(\\frac{1}{a}-\\frac{1}{b})\\frac{1}{b-a}$ ã€‚\næˆ‘ä»¬è¦æ±‚çš„å°±æ˜¯ä¸‹é¢è¿™ä¸ªç”Ÿæˆå‡½æ•°çš„ç¬¬ $n$ é¡¹ï¼š $$\\prod \\limits_{i=1}^{m} \\frac{1}{1-(ui+v)x}$$\nä¸Šé¢è¿™ä¸ªç”Ÿæˆå‡½æ•°å¯ä»¥åŒ–ä¸ºè¿™æ ·çš„å½¢å¼ï¼š $$(\\frac{1}{ux})^{m-1} \\sum \\limits_{i=1}^m \\frac{a_i}{1-(ui-v)x}$$\nå…¶ä¸­ $a_i$ æ˜¯è¯¥é¡¹çš„ä¸å®šç³»æ•°ã€‚\nè‡³äºä¸ºä»€ä¹ˆæ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬ä¸‹é¢ç»§ç»­ã€‚\nä»¤ $p_i=1-(ui+v)x$ ã€‚æˆ‘ä»¬ä» $1\\to m$ å¤„ç†è¿™ä¸ªç”Ÿæˆå‡½æ•°ï¼Œå³å‡è®¾æˆ‘ä»¬å·²ç»æ±‚å‡ºäº† $1\\to m$ çš„ç”Ÿæˆå‡½æ•°ï¼Œç„¶åæˆ‘ä»¬è¦æŠŠè¿™ä¸ªå‡½æ•°ä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{p_{m+1}}$ æ¥æ¨å‡º $1\\to m+1$ çš„ç”Ÿæˆå‡½æ•°ã€‚\né‚£æˆ‘ä»¬è€ƒè™‘å¯¹äºç¬¬äºŒç§å½¢å¼çš„ç”Ÿæˆå‡½æ•°çš„æ¯ä¸ª $i$ ï¼Œä¹˜ä¸Šè¿™ä¸ªä¹‹åçš„å˜åŒ–ã€‚\nå³ï¼š $$\\frac{a_i}{p_i}\\frac{1}{p_{m+1}} = a_i(\\frac{1}{p_i}-\\frac{1}{p_{m+1}})\\frac{1}{u(i-m-1)x}$$\næ­¤æ—¶æˆ‘ä»¬å‘ç°å¯¹äºæ¯ä¸€é¡¹éƒ½ä¼šå¤šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux}$ ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å…¶æ•´ä½“æå‡ºï¼Œå˜æˆä¸Šé¢ç”Ÿæˆå‡½æ•°çš„å½¢å¼ã€‚\næˆ‘ä»¬è€ƒè™‘ç¬¬ä¸€æ¬¡æ’å…¥ $\\frac{1}{p_{i}}$ è¿™ä¸€é¡¹ä¹‹åï¼Œä»¤å®ƒçš„ç³»æ•°ä¸º $f_i$ ã€‚é‚£ä¹ˆåœ¨æ’å…¥ $i+1$ é¡¹æ—¶ï¼Œ$f_i$ ä¼šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux(-1)}$ ï¼Œæ’å…¥ç¬¬ $i+2$ é¡¹æ—¶ä¼šä¹˜ä¸Šä¸€ä¸ª $\\frac{1}{ux(-2)}$ ã€‚æˆ‘ä»¬æƒŠè®¶çš„å‘ç°æœ‰ï¼š $$a_i=(\\frac{1}{ux})^{m-i}(-1)^{m-i}\\frac{1}{(m-i)!}f_i$$\nå†è€ƒè™‘ $f_{m+1}$ çš„å€¼ï¼š $$f_{m+1}=\\sum \\limits_{i=1}^{m} (-1)^{m-i}\\frac{1}{(m+1-i)!}f_i$$\næˆ‘ä»¬è€ƒè™‘ $f_i$ çš„ç”Ÿæˆå‡½æ•°ä¸º $F$ ï¼Œåˆ™æœ‰ï¼š $$F=F*(-e^{-x}+1)+x \\Rightarrow F=xe^x$$\nåˆ™æˆ‘ä»¬å¯ä»¥å¾—åˆ°æœ€ç»ˆç”Ÿæˆå‡½æ•°çš„æ¯ä¸€éƒ¨åˆ†çš„ç¬¬ $n$ é¡¹çš„å’Œï¼š $$\\sum \\limits_{i=1}^{m} (ui+v)^{n+m-1} u^{-m+1} (-1)^{m-i} \\frac{1}{(m-i)!} f_i$$\nå¤æ‚åº¦ $O(m\\log n)$ ã€‚\nCode // Code by ajcxsu // Problem: IOer #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353ll) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10; typedef long long ll; ll finv[N], f[N]; ll qpow(ll x, ll y) { ll ret=1; while(y) { if(y\u0026amp;1) ret=ret*x%MOD; x=x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } ll n, m, u, v; ll pl[]={1, -1}; int solve() { int ans=0; ll invu=qpow(u, (MOD-2)*(m-1)); for(int i=1; i\u0026lt;=m; i++) ans=(ans+qpow((u*i+v)%MOD, n+m-1)*invu%MOD*f[i]%MOD*pl[(m-i)\u0026amp;1]*finv[m-i]%MOD+MOD)%MOD; return ans; } int main() { finv[0]=finv[1]=1; for(int i=2; i\u0026lt;N; i++) finv[i]=MOD-1ll*MOD/i*finv[MOD%i]%MOD; for(int i=2; i\u0026lt;N; i++) finv[i]=finv[i]*finv[i-1]%MOD; for(int i=0; i\u0026lt;N-1; i++) f[i+1]=finv[i]; int T; gn(T); while(T--) { gn(n), gn(m), gn(u), gn(v); printf(\u0026quot;%d\\n\u0026quot;, solve()); } return 0; } ","oriTitle":"JZOJ6080 IOer","tags":["æ•°å­¦","ç”Ÿæˆå‡½æ•°"],"title":"JZOJ6080 IOer","uri":"/posts/sol-jzoj-6080/"},{"categories":["solution"],"content":"â­\nProblem ä¸€ä¸ªåšå¼ˆæ¸¸æˆï¼šç»™å®šä¸€æ£µæœ‰æ ¹æ ‘ï¼Œæ”¾ä¸€ä¸ªçŸ³å­åœ¨æ ¹èŠ‚ç‚¹ï¼Œè½®æµæ‰§æ‰‹ï¼Œæ¯æ¬¡å¾€ä»»æ„å¶å­èŠ‚ç‚¹æ–¹å‘ç§»ä¸€æ­¥ï¼Œä¸èƒ½ç§»åˆ™ä¸ºè¾“ã€‚\nç°åœ¨ç»™ä½  $n$ ä¸ªç‚¹ï¼Œç”Ÿæˆä»»æ„ä¸€æ£µæœ‰æ ¹æ ‘ï¼Œé—®å…ˆæ‰‹è·èƒœçš„æ¦‚ç‡ã€‚æœ‰ $q$ æ¬¡è¯¢é—®ã€‚\n$n,q \\leq 10^5$\nSolution ä»¤ $f(x), g(x)$ åˆ†åˆ«ä¸ºåæ‰‹å’Œå…ˆæ‰‹å¿…èƒœçš„ EGF ï¼Œåˆ™ $f(x)+g(x)=\\sum \\frac{(i-1)!}{i!}x^i$ ã€‚æ‰€ä»¥æœ‰ $g(x)=-ln(1-x)-f(x)$ ã€‚å…¶ä¸­ $(i-1)!$ ä¸ºæ— æ ‡å·æœ‰æ ¹æ ‘çš„æ–¹æ¡ˆæ•°ï¼Œ$\\sum \\frac{(-1)^{i+1}}{i}x^i$ ä¸º $ln(x+1)$ çš„éº¦å…‹åŠ³æ—çº§æ•°ã€‚\næ ¹æ®SGå‡½æ•°ï¼Œå› ä¸ºåæ‰‹å¿…èƒœçš„å­æ ‘çš†ä¸ºå…ˆæ‰‹å¿…èƒœï¼Œé‚£ä¹ˆæœ‰ $xe^{g(x)}=f(x)$ ã€‚è§£æ–¹ç¨‹å¾— $f(x)=ln(1-ln(1-x))$ ã€‚å¹¶ä¸çŸ¥é“è¿‡ç¨‹ã€‚\næ‰€ä»¥å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„æ¦‚ç‡ï¼š$\\frac{(n-1)!-n!f_n}{(n-1)!}=1-nf_n$ ã€‚\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; const int N=4e5+10; int f[N], g[N], h[N], r[N], n; void gen(int m) { int l=0; for(n=1; n\u0026lt;=m; n\u0026lt;\u0026lt;=1) l++; for(int i=1; i\u0026lt;n; i++) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); } int qpow(int x, int y) { assert(y\u0026gt;=0); int ret=1; while(y) { if(y\u0026amp;1) ret=1ll*ret*x%MOD; x=1ll*x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } void dft(int x[], int d) { for(int i=1; i\u0026lt;n; i++) if(r[i]\u0026gt;i) swap(x[i], x[r[i]]); int t, w, o; for(int i=1; i\u0026lt;n; i\u0026lt;\u0026lt;=1) { o=qpow(3, d*(MOD-1)/(i\u0026lt;\u0026lt;1)+MOD-1); for(int j=0; j\u0026lt;n; j+=(i\u0026lt;\u0026lt;1)) { w=1; for(int k=0; k\u0026lt;i; k++, w=1ll*w*o%MOD) t=1ll*x[i+j+k]*w%MOD, x[i+j+k]=(x[j+k]-t+MOD)%MOD, (x[j+k]+=t)%=MOD; } } } void mul(int x[], int y[], int z[], int m, int mode=0) { gen(m\u0026lt;\u0026lt;1); int a[N]={0}, b[N]={0}; copy(x, x+m, a), copy(y, y+m, b); dft(a, 1), dft(b, 1); for(int i=0; i\u0026lt;n; i++) if(!mode) a[i]=1ll*a[i]*b[i]%MOD; else a[i]=(2ll*b[i]-1ll*a[i]*b[i]%MOD*b[i]%MOD+MOD)%MOD; dft(a, -1); int inv=qpow(n, MOD-2); for(int i=0; i\u0026lt;m; i++) z[i]=1ll*a[i]*inv%MOD; } void inv(int a[], int f[], int deg) { assert(deg\u0026gt;0); if(deg==1) { f[0]=qpow(a[0]%MOD, MOD-2); return; } inv(a, f, (deg+1)\u0026gt;\u0026gt;1); mul(a, f, f, deg, 1); } void deri(int x[], int n) { for(int i=0; i\u0026lt;n; i++) x[i]=1ll*(i+1)*x[i+1]%MOD; x[n-1]=0; } void inte(int x[], int n) { for(int i=n-1; i\u0026gt;0; i--) x[i]=1ll*x[i-1]*qpow(i, MOD-2)%MOD; x[0]=0; } void pln(int x[], int y[], int n) { int a[N]={0}, b[N]={0}; copy(x, x+n, a); inv(a, b, n); deri(a, n); mul(a, b, a, n); inte(a, n); for(int i=0; i\u0026lt;n; i++) y[i]=a[i]; } int main() { ios::sync_with_stdio(false), cin.tie(0); int n=1e5+10; f[0]=1, f[1]=MOD-1; pln(f, g, n); for(int i=0; i\u0026lt;n; i++) g[i]=(MOD-g[i])%MOD; g[0]++; pln(g, h, n); int q; cin\u0026gt;\u0026gt;q; while(q--) { int na; cin\u0026gt;\u0026gt;na; cout\u0026lt;\u0026lt;(1-1ll*na*h[na]%MOD+MOD)%MOD\u0026lt;\u0026lt;'\\n'; } return 0; } ","oriTitle":"JZOJ6077 Kå›çš„æ¸¸æˆ","tags":["æ•°å­¦","ç”Ÿæˆå‡½æ•°","å¤šé¡¹å¼"],"title":"JZOJ6077 Kå›çš„æ¸¸æˆ","uri":"/posts/sol-jzoj-6077/"},{"categories":["solution"],"content":"æµªè´¹äº†æˆ‘ä¸€æ™šä¸Šçš„ç”Ÿå‘½\u0026hellip;\nSolution å…³äºæœ¬é¢˜æœ‰ä¸¤ç§åšæ³•ï¼Œæˆ‘ä¸€å¼€å§‹å†™çš„ç¬¬ä¸€ç§ï¼šå»ºç«‹å¹¿ä¹‰SAMï¼Œç»Ÿè®¡parentæ ‘ä¸Šçš„endposé›†åˆæ˜¯å¦å¯ä»¥åŒ…å«æ‰€æœ‰çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœå¯ä»¥å°±ç”¨lenæ›´æ–°ansã€‚å¯ä»¥çŠ¶å‹ã€‚\nåšæ³•æˆ‘æ‹äº†ä¸€ä¸‹ï¼Œå¤§æ¦‚æ˜¯æ²¡é—®é¢˜çš„ã€‚ä½†æ˜¯è¿™æ²™é›•é¢˜å¡å¸¸200msæˆ‘ç¡¬æ˜¯ç»™å¡äº†ä¸€æ™šä¸ŠğŸ˜‚ç„¶åå‘ç°ä¸€äº›ç¥å¥‡çš„é—®é¢˜ã€‚æ¯”å¦‚å¹¿ä¹‰SAMæ˜¯æ²¡æ³•ç”¨åŸºæ•°æ’åºæ¥ç¡®å®šæ ‘ä¸Šæ‹“æ‰‘åºçš„ï¼Œæ‰€ä»¥å¾—é˜Ÿåˆ—ç¡¬ä¸Šï¼Œå¯æƒœä¸ç®¡æ€ä¹ˆå†™éƒ½å¡ä¸è¿‡200msã€‚\nå¦ä¸€ç§åšæ³•å°±æ˜¯ç¥å¥‡çš„è½¬ç§»ï¼šå…ˆå»ºä¸€ä¸ªä¸²ï¼Œç„¶åå¯¹äºååŠ å…¥çš„æ¯ä¸ªä¸²è®¡ç®—ä¸€ä¸‹çŠ¶æ€åŒ¹é…çš„æœ€å¤§å€¼ï¼ˆå¯ä»¥é€šè¿‡åç¼€é“¾æ¥ä¸Šä¼ ï¼‰ï¼Œç„¶åå†å¯¹äºæ¯ä¸ªä¸²å–ä¸ªæœ€å°å€¼ï¼Œæœ€åæ€»ä½“å–ä¸ªæœ€å¤§å€¼ã€‚è¿™æ ·çš„åšæ³•åŸºæœ¬ä¸Šæ˜¯å¸¸æ•°å¾ˆå°çš„ $O(n)$ ï¼Œæˆ–è€…æ˜¯æˆ‘å¸¸æ•°åˆ¶é€ æœºäº†\u0026hellip;\nCode - 80ms // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26]; int lst=1, idx=1; inline void add(int c) { int p=lst, np=lst=++idx; len[np]=len[p]+1; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int bu[N], id[N]; int su[N], f[N]; void solve() { int x=1, l=0; memset(su, 0, sizeof(su)); for(char *p=str; *p; p++) { if(ch[x][*p-'a']) l++, x=ch[x][*p-'a']; else { while(x \u0026amp;\u0026amp; !ch[x][*p-'a']) x=fa[x]; if(!x) l=0, x=1; else l=len[x]+1, x=ch[x][*p-'a']; } su[x]=max(su[x], l); } for(int i=idx; i\u0026gt;=1; i--) su[fa[id[i]]]=max(su[fa[id[i]]], su[id[i]]); for(int i=1; i\u0026lt;=idx; i++) len[i]=min(len[i], su[i]); } int main() { scanf(\u0026quot;%s\u0026quot;, str); for(char *p=str; *p; p++) add(*p-'a'); for(int i=1; i\u0026lt;=idx; i++) bu[len[i]]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[len[i]]--]=i; while(scanf(\u0026quot;%s\u0026quot;, str)==1) solve(); int ans=0; for(int i=1; i\u0026lt;=idx; i++) ans=max(ans, len[i]); printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  Code - TLE // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26], in[N]; int f[N], lst=1, idx=1; inline void add(int c, int val) { int p=lst, np=lst=++idx; len[np]=len[p]+1; f[np]=1\u0026lt;\u0026lt;val; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q], f[nq]=f[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int main() { int nidx=0; while(scanf(\u0026quot;%s\u0026quot;, str)==1) { lst=1; for(char *p=str; *p; p++) add(*p-'a', nidx); ++nidx; } nidx=(1\u0026lt;\u0026lt;nidx)-1; int ans=0, na, nf; for(int i=1; i\u0026lt;=idx; i++) in[fa[i]]++; for(int i=1; i\u0026lt;=idx; i++) if(!in[i]) qu[t++]=i; while(h!=t) { na=qu[h++], nf=fa[na]; if(f[na]==nidx \u0026amp;\u0026amp; len[na]\u0026gt;ans) ans=len[na]; f[nf]|=f[na], in[nf]--; if(!in[nf]) qu[t++]=nf; } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"SPOJ1812 LCS2","tags":["SAM"],"title":"SPOJ1812 LCS2","uri":"/posts/sol-spoj-1812/"},{"categories":["solution"],"content":"åšæ³•å¾ˆå·§å¦™ã€‚\nProblem ç»™ä½ ä¸€æ£µæ ‘ï¼Œå’Œæ•°æ¡é“è·¯çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œæ±‚æœ‰å¤šå°‘ä¸ªç«è½¦ä¼šåœ¨è·¯ä¸Šç›¸é‡ã€‚\næ¯ä¸ªç«è½¦çš„é€Ÿåº¦ç›¸åŒï¼Œèµ·ç»ˆç‚¹ä¹Ÿç®—ç›¸é‡ï¼Œä½†ç»è¿‡ç»ˆç‚¹åç«è½¦æ¶ˆå¤±ã€‚\nSolution é¦–å…ˆå¦‚æœåœ¨è¾¹ä¸Šç›¸é‡ä¸€å®šæ˜¯åœ¨ä¸­ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥ç»™æ¯æ¡è¾¹å•ç‹¬å¼€ä¸€ä¸ªç‚¹è½¬åŒ–é—®é¢˜ã€‚\nç„¶åå°†è·¯å¾„åˆ†ä¸ºä¸Šè¡Œå’Œä¸‹è¡Œï¼Œlcaç®—åœ¨ä¸Šè¡Œï¼Œæ±‚ä¸Šä¸‹ç›¸äº¤å’Œä¸Šä¸Šç›¸äº¤å³å¯ã€‚\nä¸Šä¸Šç›¸äº¤å¯ä»¥çº¿æ®µæ ‘åˆå¹¶ï¼Œä¸Šä¸‹ç›¸äº¤å¯ä»¥å¯¹æ¯æ¡é‡é“¾åˆ†åˆ«å¤„ç†ï¼Œä»¥é‡é“¾çš„æ·±åº¦ä¸º $x$ è½´ï¼Œç¦»èµ·ç‚¹çš„è·ç¦»ä¸º $y$ è½´ï¼Œå¾—åˆ°æ¯æ¡è·¯å¾„åœ¨æ¯ä¸ªé‡é“¾çš„å‡½æ•°å’Œå€¼åŸŸï¼Œé‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆæ±‚ $k=1/-1$ çš„ç›´çº¿çš„äº¤ç‚¹æ•°ï¼Œå¯ä»¥ç›´æ¥ç¦»æ•£åˆ° $y$ è½´åæ‰«æçº¿æ±‚äº¤ç‚¹ä¸ªæ•°ã€‚\næ³¨æ„ä¸Šä¸Šç›¸äº¤çš„èµ·ç‚¹é‡åˆä¸è¦æ¼ç®—ã€‚\nCode // Code by ajcxsu // Problem: correction #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(); x=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=2e5+10; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], fa[N], top[N], son[N], dep[N], dfn[N], len[N], idx; int bot[N]; void dfs1(int x, int k) { dep[x]=k, siz[x]=1; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { fa[to[u]]=x, dfs1(to[u], k+1), siz[x]+=siz[to[u]]; if(siz[son[x]]\u0026lt;siz[to[u]]) son[x]=to[u]; } } void dfs2(int x, int t) { top[x]=t, dfn[x]=++idx; len[t]++; if(son[x]) dfs2(son[x], t); else bot[t]=x; for(int u=h[x];u;u=nexp[u]) if(!dfn[to[u]]) dfs2(to[u], to[u]); } int lca(int s, int t, int mode=0) { while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); if(mode \u0026amp;\u0026amp; fa[top[s]]==t) return top[s]; s=fa[top[s]]; } if(mode) return dep[s]\u0026lt;dep[t]?son[s]:son[t]; return dep[s]\u0026lt;dep[t]?s:t; } struct Seg { int k, b, l, r; } ; vector\u0026lt;Seg\u0026gt; td[N]; struct Node *nil; struct Node { int v, t; Node *ls, *rs; Node () { v=t=0; ls=rs=nil; } } *nd[N], *nd2[N]; void ini() { nil=new Node(), nil-\u0026gt;ls=nil-\u0026gt;rs=nil, fill(nd, nd+N, nil), fill(nd2, nd2+N, nil); } ll updata(Node *\u0026amp;x, int l, int r, int d, int v) { if(x==nil) x=new Node(); x-\u0026gt;v+=v; int mid=(l+r)\u0026gt;\u0026gt;1; if(l==r) { x-\u0026gt;t=l; return x-\u0026gt;v-v; } if(d\u0026lt;=mid) return updata(x-\u0026gt;ls, l, mid, d, v); else return updata(x-\u0026gt;rs, mid+1, r, d, v); } void Merge(Node *\u0026amp;x, Node *a, Node *b, ll \u0026amp;cnt, int mode=0) { if(a==nil) { x=b; return; } if(b==nil) { x=a; return; } if(x==nil) x=new Node(); if(!mode \u0026amp;\u0026amp; a-\u0026gt;t) cnt+=1ll*a-\u0026gt;v*b-\u0026gt;v; x-\u0026gt;v=a-\u0026gt;v+b-\u0026gt;v; Merge(x-\u0026gt;ls, a-\u0026gt;ls, b-\u0026gt;ls, cnt, mode); Merge(x-\u0026gt;rs, a-\u0026gt;rs, b-\u0026gt;rs, cnt, mode); delete b; } int n; void modify(int x, int k, int l, int r, int ry) { int b=ry-(r-dep[x])*k; td[x].push_back({k, b, l-dep[x], r-dep[x]}); } void modifyup(int s, int t, ll \u0026amp;ans) { if(dep[s]\u0026lt;dep[t]) swap(s, t); /* â†‘ */ ans+=updata(nd[s], 1, n, dep[s], 1); updata(nd2[t], 1, n, dep[s], -1); int bg=dep[s]; /* â†“ */ while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], -1, dep[top[s]], dep[s], bg-dep[s]); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], -1, dep[s], dep[t], bg-dep[t]); } void modifydown(int s, int t, int rua) { int bg=min(dep[s], dep[t]); while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], 1, dep[top[s]], dep[s], dep[s]-bg+rua); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], 1, dep[s], dep[t], dep[t]-bg+rua); } void dfs(int x, ll \u0026amp;cnt) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa[x]) { dfs(to[u], cnt); Merge(nd[x], nd[x], nd[to[u]], cnt); } Merge(nd[x], nd[x], nd2[x], cnt, 1); } #define lowbit(x) x\u0026amp;-x namespace BIT { const int V=N\u0026lt;\u0026lt;2; int C[V], stk[V][2], t; void updata(int x, int v, int mode=0) { if(!mode) stk[++t][0]=x, stk[t][1]=v; while(x\u0026lt;V) C[x]+=v, x+=lowbit(x); } int query(int x) { int ret=0; while(x) ret+=C[x], x-=lowbit(x); return ret; } void clr() { while(t) updata(stk[t][0], -stk[t][1], 1), t--; } } struct Query { int t, v, x, l, r; } ; Query tmp[N\u0026lt;\u0026lt;1]; int t; bool cmp(const Query \u0026amp;a, const Query \u0026amp;b) { return a.x==b.x?a.t\u0026lt;b.t:a.x\u0026lt;b.x; } ll count(int x) { t=0; for(Seg y:td[x]) if(y.k==1) { tmp[++t]={0, 1, 2*y.l+y.b, y.b+(N\u0026lt;\u0026lt;1)}; tmp[++t]={2, -1, 2*y.r+y.b, y.b+(N\u0026lt;\u0026lt;1)}; } else { tmp[++t]={1, 0, y.b, y.b-2*y.l+(N\u0026lt;\u0026lt;1), y.b-2*y.r+(N\u0026lt;\u0026lt;1)}; } sort(tmp+1, tmp+1+t, cmp); ll ret=0; BIT::clr(); for(int i=1; i\u0026lt;=t; i++) if(tmp[i].t==1) ret+=BIT::query(tmp[i].l)-BIT::query(tmp[i].r-1); else BIT::updata(tmp[i].l, tmp[i].v); return ret; } int main() { int u, v; gn(n); for(int i=1; i\u0026lt;n; i++) { gn(u, v); ins(u, i+n), ins(i+n, u); ins(v, i+n), ins(i+n, v); } ini(); dfs1(1, 1), dfs2(1, 1); ll ans=0; int m; gn(m); for(int i=1; i\u0026lt;=m; i++) { gn(u, v); int l=lca(u, v); if(l==v) modifyup(u, v, ans); else { int l2=lca(l, v, 1); modifyup(u, l, ans); modifydown(v, l2, dep[u]-dep[l]+1); } } dfs(1, ans); for(int i=1; i\u0026lt;=2*n-1; i++) if(top[i]==i) ans+=count(i); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } ","oriTitle":"Railway","tags":["æ ‘é“¾å‰–åˆ†","æ‰«æçº¿"],"title":"Railway","uri":"/posts/sol-jzoj-6074/"},{"categories":["solution"],"content":"æœ‰ç‚¹éš¾\u0026hellip;\nSolution ç½‘ä¸Šå·²ç»è®²å¾—å¾ˆè¯¦ç»†äº†å§ï¼Ÿ\nè¡¥å……å‡ ä¸ªé—®é¢˜ã€‚ä¸€æ˜¯å¯ä»¥ç›´æ¥ $f_{R}=\\sum \\limits_{j=L-1}^R f_j$ è¿›è¡Œè½¬ç§»ã€‚ä½†æ˜¯å¾—æ³¨æ„å…ˆè½¬ç§»å¤§åŒºé—´å†è½¬ç§»å°åŒºé—´ï¼ˆè¿™å±äºè¢«éƒ¨åˆ†åŒ…å«ï¼‰ï¼Œå¦åˆ™çš„è¯ä½ å¯èƒ½ä¼šä¸¢å¤±ä¸é€‰å°åŒºé—´çš„å†³ç­–ã€‚\nç¬¬äºŒä¸ªé—®é¢˜æ˜¯è‹¥é€Ÿåº¦å¯ä»¥ç›¸ç­‰ï¼Œé‚£ä¹ˆéœ€è¦å°†å¼€å§‹çš„æ’åºè¿›è¡Œä¸€äº›å°ä¿®æ”¹ã€‚è€ƒè™‘ $X_i$ çš„å·¦ç«¯æ¯”å®ƒå¤§çš„æœ€å°çš„ $j$ ï¼Œè‹¥æœ‰æ•°ä¸ª $V_k$ ç­‰äº $V_j$ ï¼Œé‚£ä¹ˆè¿™äº› $V_k$ çš„ç‚¹æ˜¯è‚¯å®šä¸èƒ½è¢«æŸ“è‰²çš„ã€‚å³ä¾§åŒç†ã€‚\nCode // Code by ajcxsu #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (1000000007) using namespace std; const int N=5e5+10; int h[N], l[N], r[N]; vector\u0026lt;int\u0026gt; L[N]; int x[N], v[N], a[N]; bool cmp(const int \u0026amp;a, const int \u0026amp;b) { return v[a]\u0026lt;v[b] || (v[a]==v[b] \u0026amp;\u0026amp; x[a]\u0026lt;x[b]); } int f[N], S[N]; int main() { ios::sync_with_stdio(false), cin.tie(0); int n, m; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;v[i], a[i]=i; sort(a+1, a+1+n, cmp); int stk[N], p[N], t=0; for(int i=1; i\u0026lt;=n; i++) { if(!t || stk[t]\u0026lt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026lt;x[a[i]]) l=mid+1; else r=mid; } ::l[i]=p[r]; } t=0; for(int i=n; i\u0026gt;=1; i--) { if(!t || stk[t]\u0026gt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026gt;x[a[i]]) l=mid+1; else r=mid; } ::r[i]=p[r]; } for(int i=1; i\u0026lt;=n; i++) L[r[i]].push_back(l[i]); f[0]=S[0]=1; for(int i=1; i\u0026lt;=n; i++) { S[i]=S[i-1]; sort(L[i].begin(), L[i].end()); for(int j:L[i]) { f[i]=(1ll*f[i]+S[i]-(j-2\u0026gt;=0?S[j-2]:0)+MOD)%MOD; S[i]=(f[i]+S[i-1])%MOD; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC015E Mr.Aoki Incubator","tags":["å•è°ƒæ ˆ","DP","äºŒåˆ†"],"title":"AGC015E Mr.Aoki Incubator","uri":"/posts/sol-agc-015-e/"},{"categories":["solution"],"content":"æœ‰ç‚¹ç¥çš„æ„é€ ï¼Œè€ƒåœºä¸Šæƒ³å¤æ‚äº†\u0026hellip;\nSolution è€ƒè™‘å› ä¸ºå˜æ¢ $2^n-1$ æ¬¡ï¼Œé‚£ä¹ˆ $A$ è·Ÿ $B$ çš„ $1$ ä½æ•°çš„å¥‡å¶æ€§ä¸€å®šä¸åŒï¼Œç”¨è¿™ä¸ªæ¥åˆ¤æ–­æ˜¯å¦æœ‰è§£ã€‚\né€šè¿‡å½’çº³å¯ä»¥çŸ¥é“å¦‚æœä¸åŒæ˜¯ä¸€å®šæœ‰è§£çš„ã€‚\nå‡è®¾å­˜åœ¨ $n=k$ çš„æ„é€ æ–¹æ¡ˆï¼Œè€ƒè™‘å¦‚ä½•æ„é€  $k+1$ ä½çš„æ„é€ æ–¹æ¡ˆã€‚æˆ‘ä»¬å¯ä»¥å°† $A$ å’Œ $B$ ä¸åŒçš„ä¸€ä½ï¼ˆå‡è®¾æ˜¯ç¬¬ $x$ ä½ï¼‰æå–å‡ºæ¥ï¼Œå‰©ä¸‹ $k$ ä½æ•° $A\u0026rsquo;$ å’Œ $B\u0026rsquo;$ ã€‚ä»–ä»¬çš„ä½æ•°å¥‡å¶æ€§ä¸€å®šç›¸åŒã€‚é‚£ä¹ˆæˆ‘ä»¬å†è€ƒè™‘ä¸€ä¸ªä¸€ä½ä¸ $A\u0026rsquo;$ ä¸åŒçš„æ•° $c$ ã€‚é€’å½’å»æ„é€ ä¸€ä¸ª $A\u0026rsquo;\\rightarrow c \\rightarrow B\u0026rsquo;$ çš„æ–¹æ¡ˆã€‚å…¶ä¸­å‰åŠéƒ¨åˆ†çš„ç¬¬ $x$ ä½ä¸ $A$ ç›¸åŒï¼ŒååŠéƒ¨åˆ†ä¸ $B$ ç›¸åŒã€‚\né€’å½’æ„é€ å³å¯ã€‚\nCode // Code by ajcxsu // Problem: C #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef bitset\u0026lt;10\u0026gt; bs; void solve(int k, int a, int b, vector\u0026lt;int\u0026gt; \u0026amp;op) { if(k==1) { op.push_back(a), op.push_back(b); return; } int c=0; vector\u0026lt;int\u0026gt; L, R; for(; ((1\u0026lt;\u0026lt;c)\u0026amp;a)==((1\u0026lt;\u0026lt;c)\u0026amp;b); c++); int na=(a\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((a\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); int nb=(b\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((b\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); solve(k-1, na, na^1, L); solve(k-1, na^1, nb, R); for(int x:L) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;a)); for(int x:R) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;b)); } int main() { ios::sync_with_stdio(false), cin.tie(0); int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!((__builtin_popcount(a)+__builtin_popcount(b))\u0026amp;1)) cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;, exit(0); vector\u0026lt;int\u0026gt; ans; solve(n, a, b, ans); cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; for(int x:ans) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;' '; cout\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC032C Differ by 1 bit","tags":["æ„é€ "],"title":"AGC032C Differ by 1 bit","uri":"/posts/sol-agc-032-c/"},{"categories":["solution"],"content":"å¼„äº†ä¸€æ™šä¸Šï¼Œå‡ ç¯‡åšå®¢äº¤æ¢çœ‹æ‰çœ‹æ‡‚ã€‚\nå¯èƒ½ä¹Ÿæ˜¯å› ä¸ºåˆ†å¿ƒäº†çš„ç¼˜æ•…ã€‚\nSolution å°†æ•´æ£µæ ‘åˆ†ä¸º $k+1$ ä¸ªè”é€šå—ï¼Œå¯¹æ¯ä¸ªè”é€šå—æ‰¾ç›´å¾„ï¼Œç„¶åç›´å¾„ç«¯ç‚¹è¿æˆä¸€æ¡é“¾ä¸€å®šæ˜¯æœ€ä¼˜è§£ã€‚\nè€ƒè™‘è½¬åŒ–é—®é¢˜ï¼Œæ±‚æ ‘ä¸Š $k+1$ æ¡ä¸ç›¸äº¤é“¾çš„æœ€å¤§æƒå’Œã€‚\nè®¾è®¡çŠ¶æ€ã€‚è€ƒè™‘ä¸€ä¸ªç‚¹çš„åº¦æ•°åªå¯èƒ½ä¸º $0/1/2$ ã€‚ä»¤ $f_{i, j, k}$ ä¸ºç¬¬ $i$ ä¸ªç‚¹ï¼Œåº¦æ•°ä¸º $j$ ï¼Œç”¨äº† $k$ æ¡é“¾çš„å­æ ‘æœ€ä¼˜è§£ã€‚\nå†å…·ä½“é˜è¿°çŠ¶æ€ã€‚$f_{i, 0}$ ä»£è¡¨è¿™ä¸ªç‚¹åº¦æ•°ä¸º $0$ ï¼Œå³åœ¨æœ€ç»ˆçš„æ–¹æ¡ˆä¸­å®ƒå¹¶ä¸å±äºç›´å¾„ï¼Œå› æ­¤ä¸å ç”¨ä»»ä½•é“¾çš„ä¸ªæ•°ä¹Ÿä¸æä¾›ä»»ä½•è´¡çŒ®ã€‚ $f_{i, 1}$ çš„çŠ¶æ€æ­£å¸¸ã€‚ $f_{i, 2}$ ä»£è¡¨è¿™ä¸ªç‚¹çš„åº¦æ•°ä¸º $2$ ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³è¦ä¸€ä¸ªå•ç‚¹æˆä¸ºç›´å¾„ä¸­çš„ä¸€æ¡é“¾ï¼Œæˆ‘ä»¬å°±å‡è®¾æ˜¯ $i$ å‘è‡ªå·±è¿äº†è‡ªç¯ï¼Œåº¦æ•°ä¸º $2$ ä¸”å ç”¨äº†ä¸€æ¡é“¾çš„æ•°ç›®ã€‚\né‚£ä¹ˆåˆå§‹åŒ–ä¹Ÿå°±å‘¼ä¹‹æ¬²å‡ºäº†ï¼š$f_{i, 0, 0}=f_{i, 2, 1}=0$ ï¼Œå…¶ä½™ç½®ä¸º $-\\infty$ ã€‚\nè½¬ç§»ä¸éš¾ã€‚\né€šè¿‡è§‚å¯Ÿï¼ˆæ‰“è¡¨ï¼‰å‘ç°å¯¹äºä½¿ç”¨é“¾æ•°ä¸º $k$ çš„æœ€ä¼˜è§£å‘ˆå‡¸å‡½æ•°ï¼Œä½¿ç”¨ å‡¸ä¼˜åŒ–dp æ¥å»é™¤ $k$ çš„é™åˆ¶ã€‚\næ³¨æ„æˆ‘ä»¬æ˜¯å¯¹æ¯æ¡é“¾äº§ç”Ÿçš„è´¡çŒ®å‡å»æ–œç‡è€Œä¸æ˜¯å¯¹æ¯æ¡è¾¹ã€‚\né‚£ä¹ˆåˆå§‹çš„dpå»é™¤ç¬¬ä¸‰ç»´æ¥åšå°±è¡Œäº†ã€‚\nä½†æ˜¯å‡¸å‡½æ•°å¯èƒ½ä¼šå‡ºç°ä½ è¦æ‰¾çš„ç‚¹å’Œå‰åä¸¤ç‚¹å¤„äºåŒä¸€ç›´çº¿ã€‚é‚£ä¹ˆæ­¤æ—¶åº”å½“äºŒåˆ†åˆ°è¯¥ç›´çº¿çš„æ–œç‡ï¼Œå¹¶ä½¿ç”¨æ–œç‡å’Œ $k$ æ¥ç›´æ¥æ±‚å‡º $k$ çš„æœ€ä¼˜å€¼ã€‚\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 æ—å…‹å¡ç‰¹æ ‘","tags":["å‡¸ä¼˜åŒ–DP"],"title":"LP4383 æ—å…‹å¡ç‰¹æ ‘","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"ä¸€é“ä¸é”™ç›¸å¯¹ç®€å•çš„é¢˜ç›®ã€‚\nSolution å¾ˆå¤§èƒ†çš„æƒ³æ³•ã€‚è€ƒè™‘ä»¥å­æ ‘dpï¼Œç„¶åä¸€æ¡é“¾å¤§åŠ›æ‹‰ä¸‹æ¥æšä¸¾é“¾åº•éƒ¨æ±‚è´¡çŒ®ã€‚\né‚£ä¹ˆå¯¹äºæ¯æ£µå­æ ‘æ±‚æœ€ä¼˜çš„é“¾åº•ã€‚\nç”¨çº¿æ®µæ ‘ç»´æŠ¤ã€‚è€ƒè™‘ç‚¹ä¸Šç§»ï¼Œé“¾åº•è´¡çŒ®çš„å˜åŒ–é‡ã€‚\né‡é“¾è´¡çŒ®ä¸­æœ‰ $\\log$ çš„å­˜åœ¨ï¼Œä½†æˆ‘ä»¬å‘ç°æ¯ä¸ªé“¾åº•åŠå…¶æ¯æ£µå­æ ‘å¯¹é‡é“¾è´¡çŒ®çš„å˜åŒ–æ¬¡æ•°ä¸ä¼šè¶…è¿‡ $\\log$ æ¬¡ï¼Œå› æ­¤å¤æ‚åº¦æ˜¯ $O(n\\log^2 n)$ çš„ã€‚\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 æ–°å¹´çš„å°é»„é¸­","tags":["çº¿æ®µæ ‘","æ ‘å½¢dp"],"title":"UOJ462 æ–°å¹´çš„å°é»„é¸­","uri":"/posts/sol-uoj-462/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"CLOUD DRIVE SHARE ID: 18shvmR8qqAhD2OlZjs3eo1ddXM3EPJVa\n ä¸»é¢˜ç”± Kevin Tan åˆ¶ä½œï¼Œå¹¶åœ¨ Margatroid çš„ä¿®æ”¹ç‰ˆæœ¬ä¸ŠåŠ ä»¥æ”¹åŠ¨ã€‚\n ","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]