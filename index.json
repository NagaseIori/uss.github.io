[{"categories":["others"],"content":"记录一下我作为 OIER 时我折腾过的事情。\n并忠告各位 OIER，因为我折腾过了这些事情（并且我最终很惨地退役了），所以我不建议所有未退役 OIER 折腾这些事情（除非你是神仙又很闲）。\nBLOG 博客事个大坑。我第一次可追溯的博客可以到我在我家电脑上用的一台小破 树莓派 + WORDPRESS ，由于无公网 IP 于是又用了 OICP 的辣鸡域名，辣鸡端口和辣鸡内网穿透方案。因此我还买了花生壳的配件。\n这里提供两种搭建属于自己的 BLOG 的思路。\nPlan A - 使用现成的博客模板/网站 这里介绍三种我知道的，其它的由于 OIER 用的较少或者我不知道所以没有推荐。\n博客园 这是 OIER 最常用的博客网站。同时你可以修改自己的 CSS 模板，或者申请 JS 脚本的权限来让博客园变得好看。\n博客园除了最底下的广告以外，简洁，好用，甚至不需要你再去其他地方寻找图床。并且能够达到一定高度的自定义程度（简单来说就是改主题），同时保证了博客最基本的功能（分类、文章、评论），也可以很清楚的看到阅读数，并获得相对较高的曝光度和点击量。\n如果你不是很想折腾，我建议使用博客园就已经足够。使用博客园的 OIER 足够多，也不用担心想要自定义时网上没有教程（虽然绝大多数情况下你也只能用模板了）。\n效果可以参考我的博客园：http://acxblog.cnblogs.com\nCSDN 辣鸡，体验极差，我没用。\nWordpress 嗯，wordpress 也是有现成的官方网站可以直接申请使用的。但一个大问题就是国外网站（可能还用了一堆 google 的东西）导致访问速度极慢，并且在国内的曝光度相对较低，可能还会受到垃圾评论的困扰\u0026hellip; 所以虽然我没怎么用，但也觉得不是很适合 OIER 使用。\nPlan B - 使用自建的博客 如果你是一个喜欢折腾的人，那欢迎，但不建议，你走入这个大坑。\n使用自建博客即是你需要搭建一个自己的网站，这里有两种方法，其中一种方法相对比较可行。\n静态页面 静态页面我是之后才开始使用的。也就是你正在看的这个博客，实际是我搭建的最后一个博客。\n我使用的是 HUGO+GITHUB PAGE 。关于如何使用 GITHUB PAGE 网上应该有了详细的教程，但用 HUGO 的人比较少吧（因为教程比较少）。\n使用 GITHUB PAGE 的话你需要顺带学习 GIT 的基本使用方法，如果对此完全一无所知还是不太好折腾的。\n我这个博客也是勉勉强强用上的，都是看着引导和翻教程做的，所以用了几个小时弄这些东西\u0026hellip; 如果你见过我这个博客的原主题，你会发现我把首页的动画效果换了，并把右侧的 TOC 的疑似 BUG 给修复了（至少原来那个看上去是真的丑），但我说实话对 css 和 html 一无所知，完全是通过网上零碎的教程和尝试瞎折腾的，左下的 CC 协议也是复制的某位 OIER 的 博客 的（包括主题也是同款 w），所以也算浪费了很多时间吧\u0026hellip;\n静态页面 +GITHUB PAGE 有什么好处呢？免费，有较高的可自定义性（静态）。\n有什么坏处呢？由于是静态页面，包括评论等更高级的功能都需要通过 js 等来实现（但说实话应该也没有这个需求）。同时博客的所有页面的 html 源码在 GITHUB 上是完全公开的，因此隐藏页面是做不到的（但说实话应该也没这个需求），同时你需要遵守 GITHUB 协议，不能做类似于本子发布或者涩图画师推荐之类的文章（但说实话应该也没这个需求）。\n总而言之你是一个没钱的折腾党的话这个应该就够你折腾一阵子的了（笑）\n非静态页面 这个是真正的大坑，用的人也应该最少，但也还是有不少人在用。例如相当精美和实用的 MiNa!，和 ZJ 神仙 ZigZagK 的完全自建博客（主题也是自己写的，而且很好看！）。如果你想要完全的自定义并且无限的折腾性，并有充足的资金和技术来支撑你的博客，那就\u0026hellip; 真不推荐入坑，因为你会在上面耗费很多很多时间 w （至少一天？）\n由于我没有精力写完整的教程，所以只会提出一些建议。\n首先要有独立的服务器。我正在用的是 CEFHOST 的面板，这家年付在搞活动的时候比较便宜，够用，并且能够请求管理员帮你事先装好你需要的博客软件（例如 Wordpress 和 Typecho），而且续费的时候是能保持前一年的价格的\u0026hellip; 所以我一直在用这家的服务器。同时面板配置 HTTPS 什么的也很方便。关于 HTTPS，如果你用面板的话用里面一键配置的 Let\u0026rsquo;s Encrypt 就行了，否则你还得去各大网站翻哪里有免费 HTTPS \u0026hellip; 证书很贵的。\n其次是域名。我正在用的是 西部数码 注册的域名，后来转移到了 Cloudflare 。Cloudflare 有一些功能还是挺有意思的，只是他们家的 CDN 有时候从国内访问比较慢。域名我个人认为挑便宜的够用就行，我觉得 .com 和 .moe 都好贵\u0026hellip;\n最后是博客软件，也没啥好推荐的，就介绍两种吧。\nWordpress 老牌的博客软件。庞大，多功能，集成性和包装都非常漂亮。有成熟的主题和插件环境，可以进行深度自定义和强大的功能扩展。MiNa! 的博客，甚至一些老牌网站（某神社、初音社）都是使用 Wordpress 建站的。\n除非你担心你的服务器配置不够，那就用 Wordpress 吧。但 Wordpress 也会调用 Google 里的一些资源所以有时会访问比较慢，不知道现在解决了没有。\nTypecho 轻量级的博客软件。真的很轻量。相应的功能较少，插件环境较差，也算是非常小众的博客了，但我还是正在使用 Typecho ，究其原因是我不想折腾 Wordpress 了。\n优点是你想改些什么东西会比较方便吧，因为很轻量，你可以直接在 typecho 的主题模板上进行修改。但说老实话也是无关痛痒的优点。\n并且 Typecho 并不很适合普通用户使用，因为很轻量，所以在用户体验上做的也不是很好，你会经历一些相对复杂的配置，不像 Wordpress 那样一键到位，基本不需要接触代码层面的内容。\n不过 Typecho 的一些特性让我整一些有趣的内容还是挺不错的？\n关于图床 如果使用自建的博客，图床是个比较大的问题。\n我比较喜欢 Upload.cc ，其次是 sm.ms ，它们免费，轻量，良心，速度也还算不错。\n其它的我就不推荐了，奇奇怪怪的图床国内有不少。\n如何打一盘流畅，快速而完美的 CF? 即科学上网。\n这是绝大多数 OIER 感兴趣的内容，是一项必备技能（无论你是要上 Google，上 P 站，上推，上油管还是流畅的打一把 CF，而且我作为 OIER 在 Google 上能搜索到一些 baidu 上搜索不到的学术相关资料，也是很不错的），同时也是一个超级大坑。我不希望任何人在这上面折腾很久，因为折腾到最后你会发现剩下来的，大概只会是空虚。\n你在 MiNa! 上大概也会看到 相关内容，但我必须要指出几处错误避免你长时间的折腾。\n接下来的内容比较浅显但是我折腾这么久以来的经验之谈，欢迎指正。\nVultr? 关于 Vultr ，这里有几点必须说明。\n 一次充值最低限额十美元，可以使用支付宝。 服务器按小时计费，注意，关机仍然计费，除非将整个服务器删除（这意味着所有服务器内的数据和你被分配到的 IP 都会丢失），丢失数据不是大问题，因为有 Snapshot 的存在，但丢掉可用 IP是个大问题。 由于 Vultr 使用人数较多已经成为了防火墙的重点关注对象，所以你会发现大部分的 IP 都无法使用（表现为无法 ping 通，无法连接 SSH 等），这就意味着你需要同时申请多个服务器来找可用 IP，并且可能找不到。每开一个服务器成本是 0.01 刀，所以成本还是有的。 请不要使用日本服务器。可以尝试比较小众地区的服务器，或者它们新开的 High Frequency 服务器（6 刀/月，比普通的贵 1 刀）。  Vultr 其实我用了挺久的，体验还可以，但高峰期（夜晚）掉包严重\u0026hellip; 并且高峰期长时间的大流量传输可能会使你被运营商限速\u0026hellip;\n白天体验还是很不错的，但说不上快。\nSS? SSR? V2Ray? 可以肯定的是现在这两个软件很大可能被特征识别了。所以我们衷心不建议没有任何保护措施地使用这两个软件（后者用 chacha20 等加密方式可能还稍好一些）。\n你可以尝试使用 v2ray ，没有特殊需求的话，也可以使用这个人的 一键安装脚本 ，虽然他默认屏蔽一些网站。\nv2ray 我们建议使用 ws+tls 的协议，如果你有个域名的话就好办多了。tls 脚本会自动帮你配置好的。\n本文章不谈 VPN ，但建议不要使用带 VPN 三个字的东西，无论是从稳定性，速度还是安全性的角度。\n至于 Wireguard, Trojan 等更加小众的软件，我觉得没必要，所以我没折腾。\n现成的网站? VPS? 现成的网站，基本上便宜不好用，好用不便宜，好用便宜流量不够，免费的又不安全。并且不稳定，存在老板跑路的可能性。所以有是有，只要能上 Google 大概能搜到一堆，但坑比较多。虽说如此，技术门槛是最低的，只是一个钱的问题。比如说什么蓝岸啊\u0026hellip; 我正在用的那款老板跑路了，不稳定，就不推荐了。\nVPS 的话，基本上除了 Vultr 都是年付，用 ws+tls 能一直保持稳定。但一个好用又便宜的 VPS 可就很难找了\u0026hellip; 搬瓦工我用了（普通 CN2 款），觉得垃圾，退款了。好用的也是不便宜，但最后还是给我找到了\u0026hellip; 我正在使用的是 TripodCloud 的 CN2 GIA 线路服务器最便宜的一款，每月流量 500G（双向），比 Vultr 便宜，速度还是很好的。高峰期也不怎么掉包，也不会出现类似 Vultr 的限速状况。\n我只是想打个 CF，需要折腾到什么程度？ 如果你只是想偶尔打 CF 的话，那还是别折腾了吧。\n或者找个网站，按量付费。\n如果你经常上 Google，经常上 CF（并且饱受 CF 掉线折磨），或者你是 P 站用户经常搜图，或者你喜欢看油管（我觉得油管也没比 b 站好到哪去），每月有一定使用量，那你可以考虑折腾个 VPS 玩玩。\n当然，想要打一盘完美的 CF，除了科学上网以外，你还需要是一个神仙。毕竟买 iPad Pro 不能让你成为音游神仙，买 Apple Pencil 并不能让你成为会画可爱妹子的画家，买刷新率 144 Hz 的屏幕不能让你枪枪爆头，买女装也并不能让你成为真的可爱妹子（？）。\nSwitchyOmega? Ubuntu? 如果你讨厌全局代理，你可能需要这个浏览器插件。关于安装 SwitchyOmega，你可以直接用 Firefox，或者先全局代理再访问 Chrome 应用商店安装。最后在情景模式下装载 gfw 列表的 地址 就行了。\nUbuntu？抱歉我退役很久了，忘记 Ubuntu 的怎么配置了。自己上网搜吧。\nVPS 的其它使用姿势？ 比如，用来建 MC 服务器啊（不太好，但我试过），用来跑 HAH 来赚 HATH 啊 (?)，用来做反代啊（虽然一般是用于伪装），用来搭博客啊（顺便作为伪装），用来做个图站啊\u0026hellip;\n反正是你自己的服务器嘛想怎么弄怎么弄。所以我说少折腾嘛。多写题。\n让你成为神仙的 OIER 利器 (?) （待填坑）\nOIER \u0026amp; IDE （待填坑）\nOIER 的高雅艺术生活 Music （待填坑）\nAnime （待填坑）\nGame （待填坑）\n","oriTitle":"我作为 OIER 时折腾了些啥？","tags":["OI","BLOG","科学上网"],"title":"我作为 OIER 时折腾了些啥？","uri":"/posts/what_stuff_did_i_do_when_i_was_an_oier/"},{"categories":["solution"],"content":"喵。\nProblem 给出一张被划分出多个区域的平面图。区域染不同颜色会有不同的权值，如果相邻两区域颜色不同会产生额外费用。求最大贡献。\nSolution 前置知识比较多？\n极角排序和最左转线。极角排序可以用函数 atan2(y, x) 求出 $\\arctan \\frac{y}{x}$ ，返回 $[-\\pi, \\pi]$ 的结果。如果小于零就加上个 $2\\pi$ 吧，然后排序就行了。\n因为有可能被卡精度，你也可以用象限排序。如果同一象限就叉积，否则比象限。太难打就没打了。\n然后最左转线用于求这种带坐标的平面图和对偶图转化。具体请参见 miskcoo\u0026rsquo;s Blog ，这里讲得比较好，代码也写得很好。\n就是细节不少。\n然后我们发现题面的意思其实只需要我们求一种匹配方案使得 W 和 B 还有相邻产生的总贡献量最小，然后用 W 和 B 的总值减去这个值即可。\n网络流嘛。随便跑跑。\nCode // Code by ajcxsu // Problem: everfeel #define _USE_MATH_DEFINES #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=4e4+10, M=4e5+10; struct P { int x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } double ang() { double ang=atan2(y, x); if(ang\u0026lt;0) ang+=2.0*M_PI; return ang;} } p[N]; struct Edge { int w, u, v; double ang; } e[M]; vector\u0026lt;int\u0026gt; to[N]; int tp[N]; int ridx, mp; int a[N], b[N], rk[M], bel[M]; int A[M], B[M], tot; void ins(int a, int b, int w) { e[mp++]={w, a, b, (p[b]-p[a]).ang()}; } namespace NS { const int s=N-1, t=N-2; int h[N], to[M], nexp[M], W[M], p=2; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } #define sins(x, y, z) ins(x, y, z), ins(y, x, 0) int fl[N]; bool bfs() { queue\u0026lt;int\u0026gt; qu; qu.push(s); memset(fl, 0, sizeof(fl)); fl[s]=1; while(!qu.empty()) { int na=qu.front(); qu.pop(); for(int u=h[na];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; !fl[to[u]]) fl[to[u]]=fl[na]+1, qu.push(to[u]); } return fl[t]; } #define INF (0x3f3f3f3f) int dfs(int x, int op) { if(x==t) return op; int flow=0; for(int u=h[x];u;u=nexp[u]) if(W[u] \u0026amp;\u0026amp; fl[to[u]]==fl[x]+1) { int d=dfs(to[u], min(op-flow, W[u])); W[u]-=d, W[u^1]+=d, flow+=d; if(flow==op) break; } if(!flow) fl[x]=0; return flow; } void work() { for(int i=0; i\u0026lt;mp; i+=2) ins(bel[i], bel[i+1], e[i].w), ins(bel[i+1], bel[i], e[i].w); for(int i=1; i\u0026lt;=ridx; i++) sins(s, i, A[i]), sins(i, t, B[i]), tot+=A[i]+B[i]; int flow=0; while(bfs()) flow+=dfs(s, INF); printf(\u0026quot;%d\\n\u0026quot;, tot-flow); } } bool vis[N]; void findreg(int x, int eid) { if(vis[eid]) return; ++ridx; while(!vis[eid]) { vis[eid]=1; bel[eid]=ridx, x=e[eid].v; A[ridx]+=a[x], B[ridx]+=b[x]; if(!rk[eid^1]) eid=to[x].back(); else eid=to[x][rk[eid^1]-1]; } } int main() { #ifndef LOCAL freopen(\u0026quot;everfeel.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;everfeel.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif int num; gn(num); int n, m; gn(n), gn(m); int u, v, w; for(int i=1; i\u0026lt;=n; i++) gn(u), gn(v), p[i]={u, v}, gn(a[i]), gn(b[i]); vector\u0026lt;pair\u0026lt;double, int\u0026gt; \u0026gt; tmp; for(int i=1; i\u0026lt;=m; i++) { gn(u), gn(v), gn(w); ins(u, v, w); ins(v, u, w); } for(int i=0; i\u0026lt;mp; i++) tmp.push_back(make_pair(e[i].ang, i)); sort(tmp.begin(), tmp.end()); for(int i=0; i\u0026lt;mp; i++) { int eid=tmp[i].second; rk[eid]=to[e[eid].u].size(); to[e[eid].u].push_back(eid); } for(int i=1; i\u0026lt;=n; i++) for(int j=0; j\u0026lt;to[i].size(); j++) findreg(i, to[i][j]); NS::work(); return 0; } ","oriTitle":"JZOJ6092 附耳而至","tags":["计算几何","网络流"],"title":"JZOJ6092 附耳而至","uri":"/posts/sol-jzoj-6092/"},{"categories":["solution"],"content":"转化比较巧妙，考场上想傻逼了的题目。很好打。\nProblem 给定一棵只有一个点的树，1e5次操作，每次加一个点后问至多交换一次两棵子树后的最大直径长度。强制在线。\nSolution 考虑事实上就是把直径上的链剖出然后询问最长支链的长度 $lp$ ，答案就是 $d+max(lp-1, 0)$ 。\n那么考虑每次加入一个点之后直径和最长支链的变化。如果直径变化，考虑另一条被换下来的支链一定是这条原支链的现长度-1。那么如果原支链的原长度就是最长支链，就直接考虑另一条被换下来的支链更新最长支链即可。如果不是最长支链，那么理论上最长支链是不会变化的，但是为了避免奇怪的错误我们还是要更新一下最长支链的点。\n如果直径不变化，那么直接用新加的点更新最长支链即可。\n倍增维护。\nCode // Code by ajcxsu // Problem: forest #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10, OP=19; int gup[OP][N], dep[N]; void add(int x, int fa) { gup[0][x]=fa, dep[x]=dep[fa]+1; for(int j=1; j\u0026lt;OP; j++) gup[j][x]=gup[j-1][gup[j-1][x]]; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } int dis(int s, int t) { return dep[s]+dep[t]-2*dep[lca(s, t)]; } int u=1, v=1, p=1, fa, len, lp, lst; int cac(int x) { return dis(x, u)+dis(x, v)-len\u0026gt;\u0026gt;1; } int main() { #ifndef LOCAL freopen(\u0026quot;forest.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;forest.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif dep[1]=1; int n, tod; gn(n), gn(n); int tmp; for(int i=2; i\u0026lt;=n; i++) { gn(fa), fa^=lst; add(i, fa); int la=dis(u, i), lb=dis(v, i); if(la\u0026gt;len || lb\u0026gt;len) { if(la\u0026gt;lb) tod=v, v=i, len=la; else tod=u, u=i, len=lb; if((tmp=cac(tod))\u0026gt;lp) lp=tmp, p=tod; } else if(((la+lb-len)\u0026gt;\u0026gt;1)\u0026gt;lp) lp=(la+lb-len)\u0026gt;\u0026gt;1, p=i; printf(\u0026quot;%d\\n\u0026quot;, lst=len+max(lp-1, 0)); } return 0; } ","oriTitle":"JZOJ6096 森林","tags":["倍增","树的直径"],"title":"JZOJ6096 森林","uri":"/posts/sol-jzoj-6096/"},{"categories":["solution"],"content":"调调改改了一晚上才过掉。总而言之还是自己对题目理解太不深刻了。基本上是对着抄但是又抄得很无奈。\nSolution 不考虑区间限制的话，则 $S, T$ 同时匹配。如果 $S$ 向 $c$ 边转移出现了不匹配，那么将 $S$ 向上跳到匹配为止，同时 $T$ 也应该向上跳使得 $len$ 与现处的状态相符。\n考虑区间限制的话，我们使用线段树合并维护树的 $endpos$ 集合。那么对于已经固定了的字符串长度 $l\u0026rsquo;$ ，需要加上字符 $c$ ，要求 $S$ 转移后所处状态的 $endpos$ 存在于 $[l+l\u0026rsquo;, r]$ 。否则我们需要将 $l\u0026rsquo;$ 一步步减小 来查看是否匹配。当 $l\u0026rsquo;=len[fa[p]]$ 时需要将 $p$ 向上转移。\n我们同时需要意识到我们可以在 $S$ 的 parent 树上直接转移，且转移到的节点的 $len$ 是符合假想区间 parent 树构造的（或者略大，但如果向上跳一定符合），因为我们转移到的状态一定在区间 parent 树上存在。这部分我觉得我可能还需要再加深理解。\n口胡一下：对于SAM，如果从状态 $A$ 转移到状态 $B$ ，你需要保证如下条件：$endpos$ 集合存在，且 $len\u0026rsquo;$ 属于结点所属 $len$ 区间。由于 $len\u0026rsquo;=len+1$ ，所以只需要保证 $endpos$ 合法即可。\nCode // Code by ajcxsu // Problem: yourname. #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=3e6+10, M=5e7+10; struct Node { int ch[26]; int len, fa; void clr() { len=fa=0; memset(ch, 0, sizeof(ch)); } } ; struct Tree *nil; struct Tree { int v, t; Tree *ls, *rs; } po[M], *pp=po; void ini() { nil=pp++; nil-\u0026gt;ls=nil-\u0026gt;rs=nil; } Tree* newn() { assert(pp!=po+M), *pp=*nil; return pp++; } void updata(Tree *\u0026amp;x, int l, int r, int d) { if(x==nil) x=newn(); x-\u0026gt;v=max(x-\u0026gt;v, d); if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d); else updata(x-\u0026gt;rs, mid+1, r, d); } Tree* Merge(Tree *x, Tree *y) { Tree *o=newn(); if(x==nil || y==nil) return x==nil?y:x; o-\u0026gt;v=max(x-\u0026gt;v, y-\u0026gt;v); o-\u0026gt;ls=Merge(x-\u0026gt;ls, y-\u0026gt;ls), o-\u0026gt;rs=Merge(x-\u0026gt;rs, y-\u0026gt;rs); return o; } int query(Tree *x, int l, int r, int xr) { if(r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=query(x-\u0026gt;ls, l, mid, xr); if(xr\u0026gt;mid) ret=max(ret, query(x-\u0026gt;rs, mid+1, r, xr)); return ret; } typedef long long ll; struct SAM { Node nd[N]; int idx=1, lst=1; int g[N]; Tree *tr[N]; void add(int c, int mode) { int p=lst, np=lst=++idx; nd[np].clr(), nd[np].len=nd[p].len+1; if(mode) updata(tr[idx], 0, N, nd[np].len); for(; p \u0026amp;\u0026amp; !nd[p].ch[c]; p=nd[p].fa) nd[p].ch[c]=np; if(!p) nd[np].fa=1; else { int q=nd[p].ch[c]; if(nd[q].len==nd[p].len+1) nd[np].fa=q; else { int nq=++idx; nd[nq]=nd[q]; nd[nq].len=nd[p].len+1, nd[q].fa=nd[np].fa=nq; for(; p \u0026amp;\u0026amp; nd[p].ch[c]==q; p=nd[p].fa) nd[p].ch[c]=nq; } } } int id[N], bu[N]; void sort() { fill(bu, bu+idx+1, 0); // !! for(int i=1; i\u0026lt;=idx; i++) bu[nd[i].len]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[nd[i].len]--]=i; } ll ftot; void ini1() { for(int i=idx; i\u0026gt;=2; i--) ftot+=nd[i].len-nd[nd[i].fa].len; } void ini2() { for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; tr[nd[tmp].fa]=Merge(tr[nd[tmp].fa], tr[tmp]); } } char str[N]; int n; void ini(int mode=0) { idx=lst=1; ftot=0; n=strlen(str); if(mode) fill(tr, tr+N, nil); nd[1].clr(); for(int i=0; i\u0026lt;n; i++) add(str[i]-'a', mode); sort(); fill(g, g+idx+1, 0); if(!mode) ini1(); else ini2(); } ll deal() { ll cnt=0; for(int i=idx; i\u0026gt;=2; i--) { int tmp=id[i]; g[tmp]=min(g[tmp], nd[tmp].len); g[nd[tmp].fa]=max(g[nd[tmp].fa], g[tmp]); cnt+=max(g[tmp]-nd[nd[tmp].fa].len, 0); // 忘取max了... } return ftot-cnt; } inline int mov(int x, char ch) { return nd[x].ch[ch-'a']; } } s, t; int main() { ini(); scanf(\u0026quot;%s\u0026quot;, s.str); s.ini(1); int T; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); int l, r; while(T--) { scanf(\u0026quot;%s%d%d\u0026quot;, t.str, \u0026amp;l, \u0026amp;r); t.ini(); int na=1, nb=1, len=0, to; bool chg; for(int i=0; i\u0026lt;t.n; i++) { to=s.mov(na, t.str[i]); nb=t.mov(nb, t.str[i]); chg=0; while(na \u0026amp;\u0026amp; (!to || query(s.tr[to], 0, N, r)\u0026lt;l+len)) { if(!len) { na=0; break; } len--; if(len==s.nd[s.nd[na].fa].len) na=s.nd[na].fa, to=s.mov(na, t.str[i]); } if(!na) na=1, len=0; else na=to, len++; while(nb \u0026amp;\u0026amp; t.nd[t.nd[nb].fa].len\u0026gt;=len) nb=t.nd[nb].fa; nb+=!nb; t.g[nb]=max(t.g[nb], len); } printf(\u0026quot;%lld\\n\u0026quot;, t.deal()); } return 0; } ","oriTitle":"NOI2018 你的名字","tags":["SAM","线段树合并"],"title":"NOI2018 你的名字","uri":"/posts/sol-your-name/"},{"categories":["solution"],"content":"常数制造机\u0026hellip;\nSolution 考虑不重复的计算质因数。令 ${p_i}^{k_i}$ 形式的质因数成为一种颜色，贡献为 $p$ ，则最多可分割出 $n\\log V$ 种颜色，现在要做的是对限定深度不重复计算颜色的贡献。\n那么对深度设主席树（每一层的话是动态开点），然后对每个颜色计算树上差分进行贡献。同时对于每个颜色记录一个 set 来维护已出现 dfn 序，如果新加入了一个颜色在树上计算与 dfs 序相邻的已出现的点的贡献的变化量。查询的时候直接在主席树上查询即可。\n复杂度大概是 $\\log^2$ 级别？空间复杂度是玄学\u0026hellip;\nCode // Code by ajcxsu // Problem: half #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int K=1e7+10, N=1e5+10, OP=19; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } typedef pair\u0026lt;int, int\u0026gt; mpa; int dep[N], dl[N], dr[N], dd[N], idx; int gup[OP][N]; void dfs(int x, int k) { dep[x]=k, dl[x]=++idx, dd[idx]=x; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { dfs(to[u], k+1); gup[0][to[u]]=x; } dr[x]=idx; } int lca(int s, int t) { if(dep[s]\u0026lt;dep[t]) swap(s, t); for(int j=OP-1; j\u0026gt;=0; j--) if(dep[gup[j][s]]\u0026gt;=dep[t]) s=gup[j][s]; if(s==t) return s; for(int j=OP-1; j\u0026gt;=0; j--) if(gup[j][s]!=gup[j][t]) s=gup[j][s], t=gup[j][t]; return gup[0][s]; } struct Dot { int x, k, i; } ; bool cmp(const Dot \u0026amp;a, const Dot \u0026amp;b) { return dep[a.x]\u0026lt;dep[b.x]; } vector\u0026lt;Dot\u0026gt; dot; vector\u0026lt;mpa\u0026gt; lis; int val[N]; int pri[K], pre[K], inv[K], pp; bool npri[K]; void di(int x, int y) { int k=0, rua=0; while(x\u0026gt;1) { if(rua!=pre[x]) rua=pre[x], k=0; k++; lis.push_back(mpa(rua, k)); dot.push_back({y, rua, k}); x/=rua; } } struct Node *nil; struct Node { Node *ls=nil, *rs=nil; int v=1, t=0; } ; Node *nd[N]; void ini() { nil=new Node, nil-\u0026gt;ls=nil-\u0026gt;rs=nil; nd[0]=nil; } void updata(Node *\u0026amp;x, int l, int r, int d, int v, int nt) { if(x-\u0026gt;t!=nt) { Node *nd=new Node; *nd=*x, x=nd; x-\u0026gt;t=nt; } x-\u0026gt;v=1ll*x-\u0026gt;v*v%MOD; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; if(d\u0026lt;=mid) updata(x-\u0026gt;ls, l, mid, d, v, nt); else updata(x-\u0026gt;rs, mid+1, r, d, v, nt); } int query(Node *x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return x-\u0026gt;v; int mid=(l+r)\u0026gt;\u0026gt;1, ret=1; if(xl\u0026lt;=mid) ret=1ll*ret*query(x-\u0026gt;ls, l, mid, xl, xr)%MOD; if(xr\u0026gt;mid) ret=1ll*ret*query(x-\u0026gt;rs, mid+1, r, xl, xr)%MOD; return ret; } set\u0026lt;int\u0026gt; s[N*25]; int main() { #ifndef LOCAL freopen(\u0026quot;half.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;half.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); #endif ini(); ios::sync_with_stdio(false), cin.tie(0); /* pri inv */ inv[1]=1; for(int i=2; i\u0026lt;K; i++) inv[i]=(MOD-1ll*MOD/i*inv[MOD%i]%MOD); npri[1]=1; for(int i=2; i\u0026lt;K; i++) { if(!npri[i]) pri[pp++]=i, pre[i]=i; for(int j=0; j\u0026lt;pp \u0026amp;\u0026amp; i*pri[j]\u0026lt;K; j++) { npri[i*pri[j]]=1, pre[i*pri[j]]=pri[j]; if(i%pri[j]==0) break; } } /* input */ int k, n; gn(k), gn(n); int na; for(int i=1; i\u0026lt;=n; i++) { gn(na); di(na, i); } int u, v; for(int i=1; i\u0026lt;n; i++) gn(u), gn(v), ins(u, v), ins(v, u); /* up */ dfs(1, 1); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; /* lis */ sort(lis.begin(), lis.end()); int tk=unique(lis.begin(), lis.end())-lis.begin(); for(int i=0; i\u0026lt;tk; i++) val[i]=lis[i].first; for(Dot \u0026amp;x:dot) x.k=lower_bound(lis.begin(), lis.begin()+tk, mpa(x.k, x.i))-lis.begin(); sort(dot.begin(), dot.end(), cmp); /* add */ int j=0; int nx, nc, mdep=dep[dot.rbegin()-\u0026gt;x]; for(int i=1; i\u0026lt;=mdep; i++) { nd[i]=nd[i-1]; while(j\u0026lt;dot.size() \u0026amp;\u0026amp; dep[dot[j].x]\u0026lt;=i) { nx=dot[j].x, nc=dot[j].k; auto it=s[nc].lower_bound(dl[nx]); int rx=(it==s[nc].end()?-1:dd[*it]); int lx=(it==s[nc].begin()?-1:dd[*(--it)]); updata(nd[i], 1, n, dl[nx], val[nc], i); if(rx!=-1 \u0026amp;\u0026amp; lx!=-1) updata(nd[i], 1, n, dl[lca(lx, rx)], val[nc], i); if(lx!=-1) updata(nd[i], 1, n, dl[lca(lx, nx)], inv[val[nc]], i); if(rx!=-1) updata(nd[i], 1, n, dl[lca(nx, rx)], inv[val[nc]], i); s[nc].insert(dl[nx]); j++; } } /* query */ int q, lstans=0; gn(q); while(q--) { gn(u), gn(v), u=u^(k*lstans), v=v^(k*lstans); printf(\u0026quot;%d\\n\u0026quot;, lstans=query(nd[min(dep[u]+v, mdep)], 1, n, dl[u], dr[u])); } return 0; } ","oriTitle":"JZOJ6086 动态半平面交","tags":["STL","主席树"],"title":"JZOJ6086 动态半平面交","uri":"/posts/sol-jzoj-6086/"},{"categories":["algorithm"],"content":"qia ke 还是 ka qiao ？\n凸包 对向量 $\\vec{a} \\times \\vec{b}$ 的运算的正负值由 $\\vec{a}$ 旋转到 $\\vec{b}$ 的角度的 $\\cos$ 决定（含正负号）。因此如果 $\\vec{a}$ 到 $\\vec{b}$ 是逆时针旋转它们的叉积就是正数，否则反之。\n那么 $x$ 排序后左右顺序扫一遍上下凸包。对于按顺序构成凸包的向量，一定是顺时针旋转，否则便不符合凸包的定义。因此使用栈来维护，如果出现了逆时针旋转则退栈。\n被称作 Graham Scan 算法。\n注意一些重复点的细节。\n旋转卡壳 用于计算凸包点对的最长距离。考虑枚举一条边，再考虑该边的对踵点（距离该边距离最大点），枚举这样所有的点边对即可获取最长距离。可以 $O(n)$ 扫过，而且误差较小。\n注意一些细节，同时特判凸包大小为 $3$ 的情况，这意味着所有点都处于同一直线上。\nCode - Beauty Contest // Code by ajcxsu // Problem: xuan zhuan qia qiao #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5e4+10; typedef long long ll; struct P { ll x, y; P operator + (P b) { return {x+b.x, y+b.y}; } P operator - (P b) { return {x-b.x, y-b.y}; } ll norm() { return x*x+y*y; } double dis() { return sqrt(norm()); } } p[N], con[N]; ll cross(P a, P b) { return a.x*b.y-a.y*b.x; } bool cmp(const P \u0026amp;a, const P \u0026amp;b) { return a.x==b.x?a.y\u0026lt;b.y:a.x\u0026lt;b.x; } inline ll dpow(ll x) { return x*x; } double dis(P a, P b, P x) { return (double)abs(cross(a-x, b-x))/(a-b).dis(); } int t; int main() { ios::sync_with_stdio(false), cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;p[i].x\u0026gt;\u0026gt;p[i].y; sort(p+1, p+1+n, cmp); for(int i=1; i\u0026lt;=n; i++) { while(t\u0026gt;=2 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } int t2=t; for(int i=n-1; i\u0026gt;=1; i--) { while(t\u0026gt;=t2+1 \u0026amp;\u0026amp; cross(con[t]-con[t-1], p[i]-con[t-1])\u0026gt;=0) t--; con[++t]=p[i]; } if(t==3) cout\u0026lt;\u0026lt;(con[1]-con[2]).norm()\u0026lt;\u0026lt;endl, exit(0); int nt=1; ll ans=0; for(int i=1; i\u0026lt;t; i++) { while(dis(con[i], con[i+1], con[nt])\u0026lt;=dis(con[i], con[i+1], con[nt+1])) nt=nt%(t-1)+1; ans=max({ans, (con[i]-con[nt]).norm(), (con[i+1]-con[nt]).norm()}); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"凸包与旋转卡壳","tags":["计算几何","凸包","旋转卡壳"],"title":"凸包与旋转卡壳","uri":"/posts/convex-hull-and-qia-qiao/"},{"categories":["solution"],"content":"Problem 给定 $n$ ，求有多少个 $1\\to n$ 的排列可以分割成三个上升子序列。$n \\leq 500$。\nSolution 假设给定一个排列，那么我们贪心的从前往后选，维护三个上升序列，每扫到一个数字添加到能放的上升序列且保证原上升序列的最大值尽量大。这样一定能构造出一种合法方案（如果有）且分割方案唯一。\n考虑三个序列的最大值设计状态。由于不清楚插入的数具体是什么，我们令其为相对大小： $f_{i, j, k}$ ，且令 $i\u0026gt;j\u0026gt;k\\geq 0$ 。同时存在 $j=k=0$ 的情况。\n那么我们插入一个新的相对大小为 $l \\in [1, i+1]$ 的值。那么原相对大小处于 $[l, i]$ 区间的值都会被往后顶成 $[l+1, i+1]$ 。则我们分情况讨论 $l$ 的转移：\n$$ f_{i, j, k} \\rightarrow \\begin{cases} f_{i+1, j+1, l} \u0026amp; \\text{for } k\u0026lt;l\\leq j\\\\ f_{i+1, l, k} \u0026amp; \\text{for }j\u0026lt;l \\leq i\\\\ f_{i+1, j, k} \u0026amp; \\text{for }l=i+1 \\end{cases} $$\n差分即可优化到 $O(n^3)$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=501; int f[2][N][N], g[2][N][N]; int u, v=1; int n, P; int add(int \u0026amp;x, int y) { x+=y; if(x\u0026gt;=P) x-=P; return x; } int main() { freopen(\u0026quot;yuan.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;yuan.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); ios::sync_with_stdio(false), cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;P; f[v][0][0]=1; int ans=0; for(int i=1; i\u0026lt;=n; i++) { u^=1, v^=1; for(int j=0; j\u0026lt;i-1;j++) for(int k=0; k\u0026lt;=j; k++) f[v][j][k]=g[v][j][k]=0; for(int j=0; j\u0026lt;i-1; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j+1][k+1],f[u][j][k]), add(f[v][j+1][j+1],-f[u][j][k]), add(g[v][j+1][k],f[u][j][k]), add(g[v][i][k],-f[u][j][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) add(f[v][j][k],f[v][j][k-1]), add(g[v][j][k],g[v][j-1][k]); for(int j=0; j\u0026lt;i; j++) for(int k=0; (!k \u0026amp;\u0026amp; !j) || k\u0026lt;j; k++) { add(f[v][j][k],add(g[v][j][k],f[u][j][k])); if(i==n) add(ans, f[v][j][k]); } } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"JZOJ2090 圆","tags":["DP"],"title":"JZOJ2090 圆","uri":"/posts/sol-jzoj-2090/"},{"categories":["solution"],"content":"好题好做法\u0026hellip;\n感谢 gjx 的讲解。\nSolution 要用到的结论： $\\frac{1}{a}\\frac{1}{b}=(\\frac{1}{a}-\\frac{1}{b})\\frac{1}{b-a}$ 。\n我们要求的就是下面这个生成函数的第 $n$ 项： $$\\prod \\limits_{i=1}^{m} \\frac{1}{1-(ui+v)x}$$\n上面这个生成函数可以化为这样的形式： $$(\\frac{1}{ux})^{m-1} \\sum \\limits_{i=1}^m \\frac{a_i}{1-(ui-v)x}$$\n其中 $a_i$ 是该项的不定系数。\n至于为什么是这样，我们下面继续。\n令 $p_i=1-(ui+v)x$ 。我们从 $1\\to m$ 处理这个生成函数，即假设我们已经求出了 $1\\to m$ 的生成函数，然后我们要把这个函数乘上一个 $\\frac{1}{p_{m+1}}$ 来推出 $1\\to m+1$ 的生成函数。\n那我们考虑对于第二种形式的生成函数的每个 $i$ ，乘上这个之后的变化。\n即： $$\\frac{a_i}{p_i}\\frac{1}{p_{m+1}} = a_i(\\frac{1}{p_i}-\\frac{1}{p_{m+1}})\\frac{1}{u(i-m-1)x}$$\n此时我们发现对于每一项都会多乘上一个 $\\frac{1}{ux}$ ，因此我们可以将其整体提出，变成上面生成函数的形式。\n我们考虑第一次插入 $\\frac{1}{p_{i}}$ 这一项之后，令它的系数为 $f_i$ 。那么在插入 $i+1$ 项时，$f_i$ 会乘上一个 $\\frac{1}{ux(-1)}$ ，插入第 $i+2$ 项时会乘上一个 $\\frac{1}{ux(-2)}$ 。我们惊讶的发现有： $$a_i=(\\frac{1}{ux})^{m-i}(-1)^{m-i}\\frac{1}{(m-i)!}f_i$$\n再考虑 $f_{m+1}$ 的值： $$f_{m+1}=\\sum \\limits_{i=1}^{m} (-1)^{m-i}\\frac{1}{(m+1-i)!}f_i$$\n我们考虑 $f_i$ 的生成函数为 $F$ ，则有： $$F=F*(-e^{-x}+1)+x \\Rightarrow F=xe^x$$\n则我们可以得到最终生成函数的每一部分的第 $n$ 项的和： $$\\sum \\limits_{i=1}^{m} (ui+v)^{n+m-1} u^{-m+1} (-1)^{m-i} \\frac{1}{(m-i)!} f_i$$\n复杂度 $O(m\\log n)$ 。\nCode // Code by ajcxsu // Problem: IOer #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353ll) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=(ch=='-'), ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } const int N=2e5+10; typedef long long ll; ll finv[N], f[N]; ll qpow(ll x, ll y) { ll ret=1; while(y) { if(y\u0026amp;1) ret=ret*x%MOD; x=x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } ll n, m, u, v; ll pl[]={1, -1}; int solve() { int ans=0; ll invu=qpow(u, (MOD-2)*(m-1)); for(int i=1; i\u0026lt;=m; i++) ans=(ans+qpow((u*i+v)%MOD, n+m-1)*invu%MOD*f[i]%MOD*pl[(m-i)\u0026amp;1]*finv[m-i]%MOD+MOD)%MOD; return ans; } int main() { finv[0]=finv[1]=1; for(int i=2; i\u0026lt;N; i++) finv[i]=MOD-1ll*MOD/i*finv[MOD%i]%MOD; for(int i=2; i\u0026lt;N; i++) finv[i]=finv[i]*finv[i-1]%MOD; for(int i=0; i\u0026lt;N-1; i++) f[i+1]=finv[i]; int T; gn(T); while(T--) { gn(n), gn(m), gn(u), gn(v); printf(\u0026quot;%d\\n\u0026quot;, solve()); } return 0; } ","oriTitle":"JZOJ6080 IOer","tags":["数学","生成函数"],"title":"JZOJ6080 IOer","uri":"/posts/sol-jzoj-6080/"},{"categories":["solution"],"content":"⭐\nProblem 一个博弈游戏：给定一棵有根树，放一个石子在根节点，轮流执手，每次往任意叶子节点方向移一步，不能移则为输。\n现在给你 $n$ 个点，生成任意一棵有根树，问先手获胜的概率。有 $q$ 次询问。\n$n,q \\leq 10^5$\nSolution 令 $f(x), g(x)$ 分别为后手和先手必胜的 EGF ，则 $f(x)+g(x)=\\sum \\frac{(i-1)!}{i!}x^i$ 。所以有 $g(x)=-ln(1-x)-f(x)$ 。其中 $(i-1)!$ 为无标号有根树的方案数，$\\sum \\frac{(-1)^{i+1}}{i}x^i$ 为 $ln(x+1)$ 的麦克劳林级数。\n根据SG函数，因为后手必胜的子树皆为先手必胜，那么有 $xe^{g(x)}=f(x)$ 。解方程得 $f(x)=ln(1-ln(1-x))$ 。并不知道过程。\n所以可以得到最终的概率：$\\frac{(n-1)!-n!f_n}{(n-1)!}=1-nf_n$ 。\nCode #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (998244353) using namespace std; const int N=4e5+10; int f[N], g[N], h[N], r[N], n; void gen(int m) { int l=0; for(n=1; n\u0026lt;=m; n\u0026lt;\u0026lt;=1) l++; for(int i=1; i\u0026lt;n; i++) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(l-1)); } int qpow(int x, int y) { assert(y\u0026gt;=0); int ret=1; while(y) { if(y\u0026amp;1) ret=1ll*ret*x%MOD; x=1ll*x*x%MOD, y\u0026gt;\u0026gt;=1; } return ret; } void dft(int x[], int d) { for(int i=1; i\u0026lt;n; i++) if(r[i]\u0026gt;i) swap(x[i], x[r[i]]); int t, w, o; for(int i=1; i\u0026lt;n; i\u0026lt;\u0026lt;=1) { o=qpow(3, d*(MOD-1)/(i\u0026lt;\u0026lt;1)+MOD-1); for(int j=0; j\u0026lt;n; j+=(i\u0026lt;\u0026lt;1)) { w=1; for(int k=0; k\u0026lt;i; k++, w=1ll*w*o%MOD) t=1ll*x[i+j+k]*w%MOD, x[i+j+k]=(x[j+k]-t+MOD)%MOD, (x[j+k]+=t)%=MOD; } } } void mul(int x[], int y[], int z[], int m, int mode=0) { gen(m\u0026lt;\u0026lt;1); int a[N]={0}, b[N]={0}; copy(x, x+m, a), copy(y, y+m, b); dft(a, 1), dft(b, 1); for(int i=0; i\u0026lt;n; i++) if(!mode) a[i]=1ll*a[i]*b[i]%MOD; else a[i]=(2ll*b[i]-1ll*a[i]*b[i]%MOD*b[i]%MOD+MOD)%MOD; dft(a, -1); int inv=qpow(n, MOD-2); for(int i=0; i\u0026lt;m; i++) z[i]=1ll*a[i]*inv%MOD; } void inv(int a[], int f[], int deg) { assert(deg\u0026gt;0); if(deg==1) { f[0]=qpow(a[0]%MOD, MOD-2); return; } inv(a, f, (deg+1)\u0026gt;\u0026gt;1); mul(a, f, f, deg, 1); } void deri(int x[], int n) { for(int i=0; i\u0026lt;n; i++) x[i]=1ll*(i+1)*x[i+1]%MOD; x[n-1]=0; } void inte(int x[], int n) { for(int i=n-1; i\u0026gt;0; i--) x[i]=1ll*x[i-1]*qpow(i, MOD-2)%MOD; x[0]=0; } void pln(int x[], int y[], int n) { int a[N]={0}, b[N]={0}; copy(x, x+n, a); inv(a, b, n); deri(a, n); mul(a, b, a, n); inte(a, n); for(int i=0; i\u0026lt;n; i++) y[i]=a[i]; } int main() { ios::sync_with_stdio(false), cin.tie(0); int n=1e5+10; f[0]=1, f[1]=MOD-1; pln(f, g, n); for(int i=0; i\u0026lt;n; i++) g[i]=(MOD-g[i])%MOD; g[0]++; pln(g, h, n); int q; cin\u0026gt;\u0026gt;q; while(q--) { int na; cin\u0026gt;\u0026gt;na; cout\u0026lt;\u0026lt;(1-1ll*na*h[na]%MOD+MOD)%MOD\u0026lt;\u0026lt;'\\n'; } return 0; } ","oriTitle":"JZOJ6077 K君的游戏","tags":["数学","生成函数","多项式"],"title":"JZOJ6077 K君的游戏","uri":"/posts/sol-jzoj-6077/"},{"categories":["solution"],"content":"浪费了我一晚上的生命\u0026hellip;\nSolution 关于本题有两种做法，我一开始写的第一种：建立广义SAM，统计parent树上的endpos集合是否可以包含所有的字符串，如果可以就用len更新ans。可以状压。\n做法我拍了一下，大概是没问题的。但是这沙雕题卡常200ms我硬是给卡了一晚上😂然后发现一些神奇的问题。比如广义SAM是没法用基数排序来确定树上拓扑序的，所以得队列硬上，可惜不管怎么写都卡不过200ms。\n另一种做法就是神奇的转移：先建一个串，然后对于后加入的每个串计算一下状态匹配的最大值（可以通过后缀链接上传），然后再对于每个串取个最小值，最后总体取个最大值。这样的做法基本上是常数很小的 $O(n)$ ，或者是我常数制造机了\u0026hellip;\nCode - 80ms // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26]; int lst=1, idx=1; inline void add(int c) { int p=lst, np=lst=++idx; len[np]=len[p]+1; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int bu[N], id[N]; int su[N], f[N]; void solve() { int x=1, l=0; memset(su, 0, sizeof(su)); for(char *p=str; *p; p++) { if(ch[x][*p-'a']) l++, x=ch[x][*p-'a']; else { while(x \u0026amp;\u0026amp; !ch[x][*p-'a']) x=fa[x]; if(!x) l=0, x=1; else l=len[x]+1, x=ch[x][*p-'a']; } su[x]=max(su[x], l); } for(int i=idx; i\u0026gt;=1; i--) su[fa[id[i]]]=max(su[fa[id[i]]], su[id[i]]); for(int i=1; i\u0026lt;=idx; i++) len[i]=min(len[i], su[i]); } int main() { scanf(\u0026quot;%s\u0026quot;, str); for(char *p=str; *p; p++) add(*p-'a'); for(int i=1; i\u0026lt;=idx; i++) bu[len[i]]++; for(int i=1; i\u0026lt;=idx; i++) bu[i]+=bu[i-1]; for(int i=idx; i\u0026gt;=1; i--) id[bu[len[i]]--]=i; while(scanf(\u0026quot;%s\u0026quot;, str)==1) solve(); int ans=0; for(int i=1; i\u0026lt;=idx; i++) ans=max(ans, len[i]); printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; }  Code - TLE // Code by ajcxsu // Problem: LCS2 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e6+5; int len[N], fa[N], ch[N][26], in[N]; int f[N], lst=1, idx=1; inline void add(int c, int val) { int p=lst, np=lst=++idx; len[np]=len[p]+1; f[np]=1\u0026lt;\u0026lt;val; for(; p \u0026amp;\u0026amp; !ch[p][c]; p=fa[p]) ch[p][c]=np; if(!p) fa[np]=1; else { int q=ch[p][c]; if(len[q]==len[p]+1) fa[np]=q; else { int nq=++idx; for(int i=0; i\u0026lt;26; i++) ch[nq][i]=ch[q][i]; fa[nq]=fa[q], f[nq]=f[q]; len[nq]=len[p]+1, fa[q]=fa[np]=nq; for(; p \u0026amp;\u0026amp; ch[p][c]==q; p=fa[p]) ch[p][c]=nq; } } } int qu[N], h, t; char str[N]; int main() { int nidx=0; while(scanf(\u0026quot;%s\u0026quot;, str)==1) { lst=1; for(char *p=str; *p; p++) add(*p-'a', nidx); ++nidx; } nidx=(1\u0026lt;\u0026lt;nidx)-1; int ans=0, na, nf; for(int i=1; i\u0026lt;=idx; i++) in[fa[i]]++; for(int i=1; i\u0026lt;=idx; i++) if(!in[i]) qu[t++]=i; while(h!=t) { na=qu[h++], nf=fa[na]; if(f[na]==nidx \u0026amp;\u0026amp; len[na]\u0026gt;ans) ans=len[na]; f[nf]|=f[na], in[nf]--; if(!in[nf]) qu[t++]=nf; } printf(\u0026quot;%d\\n\u0026quot;, ans); return 0; } ","oriTitle":"SPOJ1812 LCS2","tags":["SAM"],"title":"SPOJ1812 LCS2","uri":"/posts/sol-spoj-1812/"},{"categories":["solution"],"content":"做法很巧妙。\nProblem 给你一棵树，和数条铁路的起点和终点，求有多少个火车会在路上相遇。\n每个火车的速度相同，起终点也算相遇，但经过终点后火车消失。\nSolution 首先如果在边上相遇一定是在中点，所以可以给每条边单独开一个点转化问题。\n然后将路径分为上行和下行，lca算在上行，求上下相交和上上相交即可。\n上上相交可以线段树合并，上下相交可以对每条重链分别处理，以重链的深度为 $x$ 轴，离起点的距离为 $y$ 轴，得到每条路径在每个重链的函数和值域，那么问题转化成求 $k=1/-1$ 的直线的交点数，可以直接离散到 $y$ 轴后扫描线求交点个数。\n注意上上相交的起点重合不要漏算。\nCode // Code by ajcxsu // Problem: correction #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; template\u0026lt;typename T\u0026gt; inline void gn(T \u0026amp;x) { char ch=getchar(); x=0; while(!isdigit(ch)) ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn(T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=2e5+10; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], fa[N], top[N], son[N], dep[N], dfn[N], len[N], idx; int bot[N]; void dfs1(int x, int k) { dep[x]=k, siz[x]=1; for(int u=h[x];u;u=nexp[u]) if(!dep[to[u]]) { fa[to[u]]=x, dfs1(to[u], k+1), siz[x]+=siz[to[u]]; if(siz[son[x]]\u0026lt;siz[to[u]]) son[x]=to[u]; } } void dfs2(int x, int t) { top[x]=t, dfn[x]=++idx; len[t]++; if(son[x]) dfs2(son[x], t); else bot[t]=x; for(int u=h[x];u;u=nexp[u]) if(!dfn[to[u]]) dfs2(to[u], to[u]); } int lca(int s, int t, int mode=0) { while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); if(mode \u0026amp;\u0026amp; fa[top[s]]==t) return top[s]; s=fa[top[s]]; } if(mode) return dep[s]\u0026lt;dep[t]?son[s]:son[t]; return dep[s]\u0026lt;dep[t]?s:t; } struct Seg { int k, b, l, r; } ; vector\u0026lt;Seg\u0026gt; td[N]; struct Node *nil; struct Node { int v, t; Node *ls, *rs; Node () { v=t=0; ls=rs=nil; } } *nd[N], *nd2[N]; void ini() { nil=new Node(), nil-\u0026gt;ls=nil-\u0026gt;rs=nil, fill(nd, nd+N, nil), fill(nd2, nd2+N, nil); } ll updata(Node *\u0026amp;x, int l, int r, int d, int v) { if(x==nil) x=new Node(); x-\u0026gt;v+=v; int mid=(l+r)\u0026gt;\u0026gt;1; if(l==r) { x-\u0026gt;t=l; return x-\u0026gt;v-v; } if(d\u0026lt;=mid) return updata(x-\u0026gt;ls, l, mid, d, v); else return updata(x-\u0026gt;rs, mid+1, r, d, v); } void Merge(Node *\u0026amp;x, Node *a, Node *b, ll \u0026amp;cnt, int mode=0) { if(a==nil) { x=b; return; } if(b==nil) { x=a; return; } if(x==nil) x=new Node(); if(!mode \u0026amp;\u0026amp; a-\u0026gt;t) cnt+=1ll*a-\u0026gt;v*b-\u0026gt;v; x-\u0026gt;v=a-\u0026gt;v+b-\u0026gt;v; Merge(x-\u0026gt;ls, a-\u0026gt;ls, b-\u0026gt;ls, cnt, mode); Merge(x-\u0026gt;rs, a-\u0026gt;rs, b-\u0026gt;rs, cnt, mode); delete b; } int n; void modify(int x, int k, int l, int r, int ry) { int b=ry-(r-dep[x])*k; td[x].push_back({k, b, l-dep[x], r-dep[x]}); } void modifyup(int s, int t, ll \u0026amp;ans) { if(dep[s]\u0026lt;dep[t]) swap(s, t); /* ↑ */ ans+=updata(nd[s], 1, n, dep[s], 1); updata(nd2[t], 1, n, dep[s], -1); int bg=dep[s]; /* ↓ */ while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], -1, dep[top[s]], dep[s], bg-dep[s]); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], -1, dep[s], dep[t], bg-dep[t]); } void modifydown(int s, int t, int rua) { int bg=min(dep[s], dep[t]); while(top[s]!=top[t]) { if(dep[top[s]]\u0026lt;dep[top[t]]) swap(s, t); modify(top[s], 1, dep[top[s]], dep[s], dep[s]-bg+rua); s=fa[top[s]]; } if(dep[s]\u0026gt;dep[t]) swap(s, t); modify(top[s], 1, dep[s], dep[t], dep[t]-bg+rua); } void dfs(int x, ll \u0026amp;cnt) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa[x]) { dfs(to[u], cnt); Merge(nd[x], nd[x], nd[to[u]], cnt); } Merge(nd[x], nd[x], nd2[x], cnt, 1); } #define lowbit(x) x\u0026amp;-x namespace BIT { const int V=N\u0026lt;\u0026lt;2; int C[V], stk[V][2], t; void updata(int x, int v, int mode=0) { if(!mode) stk[++t][0]=x, stk[t][1]=v; while(x\u0026lt;V) C[x]+=v, x+=lowbit(x); } int query(int x) { int ret=0; while(x) ret+=C[x], x-=lowbit(x); return ret; } void clr() { while(t) updata(stk[t][0], -stk[t][1], 1), t--; } } struct Query { int t, v, x, l, r; } ; Query tmp[N\u0026lt;\u0026lt;1]; int t; bool cmp(const Query \u0026amp;a, const Query \u0026amp;b) { return a.x==b.x?a.t\u0026lt;b.t:a.x\u0026lt;b.x; } ll count(int x) { t=0; for(Seg y:td[x]) if(y.k==1) { tmp[++t]={0, 1, 2*y.l+y.b, y.b+(N\u0026lt;\u0026lt;1)}; tmp[++t]={2, -1, 2*y.r+y.b, y.b+(N\u0026lt;\u0026lt;1)}; } else { tmp[++t]={1, 0, y.b, y.b-2*y.l+(N\u0026lt;\u0026lt;1), y.b-2*y.r+(N\u0026lt;\u0026lt;1)}; } sort(tmp+1, tmp+1+t, cmp); ll ret=0; BIT::clr(); for(int i=1; i\u0026lt;=t; i++) if(tmp[i].t==1) ret+=BIT::query(tmp[i].l)-BIT::query(tmp[i].r-1); else BIT::updata(tmp[i].l, tmp[i].v); return ret; } int main() { int u, v; gn(n); for(int i=1; i\u0026lt;n; i++) { gn(u, v); ins(u, i+n), ins(i+n, u); ins(v, i+n), ins(i+n, v); } ini(); dfs1(1, 1), dfs2(1, 1); ll ans=0; int m; gn(m); for(int i=1; i\u0026lt;=m; i++) { gn(u, v); int l=lca(u, v); if(l==v) modifyup(u, v, ans); else { int l2=lca(l, v, 1); modifyup(u, l, ans); modifydown(v, l2, dep[u]-dep[l]+1); } } dfs(1, ans); for(int i=1; i\u0026lt;=2*n-1; i++) if(top[i]==i) ans+=count(i); printf(\u0026quot;%lld\\n\u0026quot;, ans); return 0; } ","oriTitle":"Railway","tags":["树链剖分","扫描线"],"title":"Railway","uri":"/posts/sol-jzoj-6074/"},{"categories":["solution"],"content":"有点难\u0026hellip;\nSolution 网上已经讲得很详细了吧？\n补充几个问题。一是可以直接 $f_{R}=\\sum \\limits_{j=L-1}^R f_j$ 进行转移。但是得注意先转移大区间再转移小区间（这属于被部分包含），否则的话你可能会丢失不选小区间的决策。\n第二个问题是若速度可以相等，那么需要将开始的排序进行一些小修改。考虑 $X_i$ 的左端比它大的最小的 $j$ ，若有数个 $V_k$ 等于 $V_j$ ，那么这些 $V_k$ 的点是肯定不能被染色的。右侧同理。\nCode // Code by ajcxsu #include\u0026lt;bits/stdc++.h\u0026gt; #define MOD (1000000007) using namespace std; const int N=5e5+10; int h[N], l[N], r[N]; vector\u0026lt;int\u0026gt; L[N]; int x[N], v[N], a[N]; bool cmp(const int \u0026amp;a, const int \u0026amp;b) { return v[a]\u0026lt;v[b] || (v[a]==v[b] \u0026amp;\u0026amp; x[a]\u0026lt;x[b]); } int f[N], S[N]; int main() { ios::sync_with_stdio(false), cin.tie(0); int n, m; cin\u0026gt;\u0026gt;n; for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;v[i], a[i]=i; sort(a+1, a+1+n, cmp); int stk[N], p[N], t=0; for(int i=1; i\u0026lt;=n; i++) { if(!t || stk[t]\u0026lt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026lt;x[a[i]]) l=mid+1; else r=mid; } ::l[i]=p[r]; } t=0; for(int i=n; i\u0026gt;=1; i--) { if(!t || stk[t]\u0026gt;x[a[i]]) stk[++t]=x[a[i]], p[t]=i; int l=1, r=t, mid; while(l\u0026lt;r) { mid=(l+r)\u0026gt;\u0026gt;1; if(stk[mid]\u0026gt;x[a[i]]) l=mid+1; else r=mid; } ::r[i]=p[r]; } for(int i=1; i\u0026lt;=n; i++) L[r[i]].push_back(l[i]); f[0]=S[0]=1; for(int i=1; i\u0026lt;=n; i++) { S[i]=S[i-1]; sort(L[i].begin(), L[i].end()); for(int j:L[i]) { f[i]=(1ll*f[i]+S[i]-(j-2\u0026gt;=0?S[j-2]:0)+MOD)%MOD; S[i]=(f[i]+S[i-1])%MOD; } } cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC015E Mr.Aoki Incubator","tags":["单调栈","DP","二分"],"title":"AGC015E Mr.Aoki Incubator","uri":"/posts/sol-agc-015-e/"},{"categories":["solution"],"content":"有点神的构造，考场上想复杂了\u0026hellip;\nSolution 考虑因为变换 $2^n-1$ 次，那么 $A$ 跟 $B$ 的 $1$ 位数的奇偶性一定不同，用这个来判断是否有解。\n通过归纳可以知道如果不同是一定有解的。\n假设存在 $n=k$ 的构造方案，考虑如何构造 $k+1$ 位的构造方案。我们可以将 $A$ 和 $B$ 不同的一位（假设是第 $x$ 位）提取出来，剩下 $k$ 位数 $A\u0026rsquo;$ 和 $B\u0026rsquo;$ 。他们的位数奇偶性一定相同。那么我们再考虑一个一位与 $A\u0026rsquo;$ 不同的数 $c$ 。递归去构造一个 $A\u0026rsquo;\\rightarrow c \\rightarrow B\u0026rsquo;$ 的方案。其中前半部分的第 $x$ 位与 $A$ 相同，后半部分与 $B$ 相同。\n递归构造即可。\nCode // Code by ajcxsu // Problem: C #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef bitset\u0026lt;10\u0026gt; bs; void solve(int k, int a, int b, vector\u0026lt;int\u0026gt; \u0026amp;op) { if(k==1) { op.push_back(a), op.push_back(b); return; } int c=0; vector\u0026lt;int\u0026gt; L, R; for(; ((1\u0026lt;\u0026lt;c)\u0026amp;a)==((1\u0026lt;\u0026lt;c)\u0026amp;b); c++); int na=(a\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((a\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); int nb=(b\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((b\u0026amp;((1\u0026lt;\u0026lt;k)-1-((1\u0026lt;\u0026lt;c+1)-1)))\u0026gt;\u0026gt;1); solve(k-1, na, na^1, L); solve(k-1, na^1, nb, R); for(int x:L) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;a)); for(int x:R) op.push_back(((x\u0026amp;((1\u0026lt;\u0026lt;c)-1))|((x\u0026amp;((1\u0026lt;\u0026lt;(k-1))-1-((1\u0026lt;\u0026lt;c)-1)))\u0026lt;\u0026lt;1))|((1\u0026lt;\u0026lt;c)\u0026amp;b)); } int main() { ios::sync_with_stdio(false), cin.tie(0); int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!((__builtin_popcount(a)+__builtin_popcount(b))\u0026amp;1)) cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;, exit(0); vector\u0026lt;int\u0026gt; ans; solve(n, a, b, ans); cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; for(int x:ans) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;' '; cout\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"AGC032C Differ by 1 bit","tags":["构造"],"title":"AGC032C Differ by 1 bit","uri":"/posts/sol-agc-032-c/"},{"categories":["solution"],"content":"弄了一晚上，几篇博客交换看才看懂。\n可能也是因为分心了的缘故。\nSolution 将整棵树分为 $k+1$ 个联通块，对每个联通块找直径，然后直径端点连成一条链一定是最优解。\n考虑转化问题，求树上 $k+1$ 条不相交链的最大权和。\n设计状态。考虑一个点的度数只可能为 $0/1/2$ 。令 $f_{i, j, k}$ 为第 $i$ 个点，度数为 $j$ ，用了 $k$ 条链的子树最优解。\n再具体阐述状态。$f_{i, 0}$ 代表这个点度数为 $0$ ，即在最终的方案中它并不属于直径，因此不占用任何链的个数也不提供任何贡献。 $f_{i, 1}$ 的状态正常。 $f_{i, 2}$ 代表这个点的度数为 $2$ 。那么如果我们想要一个单点成为直径中的一条链，我们就假设是 $i$ 向自己连了自环，度数为 $2$ 且占用了一条链的数目。\n那么初始化也就呼之欲出了：$f_{i, 0, 0}=f_{i, 2, 1}=0$ ，其余置为 $-\\infty$ 。\n转移不难。\n通过观察（打表）发现对于使用链数为 $k$ 的最优解呈凸函数，使用 凸优化dp 来去除 $k$ 的限制。\n注意我们是对每条链产生的贡献减去斜率而不是对每条边。\n那么初始的dp去除第三维来做就行了。\n但是凸函数可能会出现你要找的点和前后两点处于同一直线。那么此时应当二分到该直线的斜率，并使用斜率和 $k$ 来直接求出 $k$ 的最优值。\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 林克卡特树","tags":["凸优化DP"],"title":"LP4383 林克卡特树","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"一道不错相对简单的题目。\nSolution 很大胆的想法。考虑以子树dp，然后一条链大力拉下来枚举链底部求贡献。\n那么对于每棵子树求最优的链底。\n用线段树维护。考虑点上移，链底贡献的变化量。\n重链贡献中有 $\\log$ 的存在，但我们发现每个链底及其每棵子树对重链贡献的变化次数不会超过 $\\log$ 次，因此复杂度是 $O(n\\log^2 n)$ 的。\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 新年的小黄鸭","tags":["线段树","树形dp"],"title":"UOJ462 新年的小黄鸭","uri":"/posts/sol-uoj-462/"},{"categories":["others"],"content":"$\\text{Hello world!}$ 这↑里↓就是里站了。欢迎。\n","oriTitle":"Inside Space","tags":["none"],"title":"Inside Space","uri":"/posts/my-first-post/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"CLOUD DRIVE SHARE ID: 18shvmR8qqAhD2OlZjs3eo1ddXM3EPJVa\n","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]