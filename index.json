[{"categories":["solution"],"content":"弄了一晚上，几篇博客交换看才看懂。\n可能也是因为分心了的缘故。\nSolution 将整棵树分为 $k+1$ 个联通块，对每个联通块找直径，然后直径端点连成一条链一定是最优解。\n考虑转化问题，求树上 $k+1$ 条不相交链的最大权和。\n设计状态。考虑一个点的度数只可能为 $0/1/2$ 。令 $f_{i, j, k}$ 为第 $i$ 个点，度数为 $j$ ，用了 $k$ 条链的子树最优解。\n再具体阐述状态。$f_{i, 0}$ 代表这个点度数为 $0$ ，即在最终的方案中它并不属于直径，因此不占用任何链的个数也不提供任何贡献。 $f_{i, 1}$ 的状态正常。 $f_{i, 2}$ 代表这个点的度数为 $2$ 。那么如果我们想要一个单点成为直径中的一条链，我们就假设是 $i$ 向自己连了自环，度数为 $2$ 且占用了一条链的数目。\n那么初始化也就呼之欲出了：$f_{i, 0, 0}=f_{i, 2, 1}=1$ ，其余置为 $-\\infty$ 。\n转移不难。\n通过观察（打表）发现对于使用链数为 $k$ 的最优解呈凸函数，使用 凸优化dp 来去除 $k$ 的限制。\n注意我们是对每条链产生的贡献减去斜率而不是对每条边。\n那么初始的dp去除第三维来做就行了。\n但是凸函数可能会出现你要找的点和前后两点处于同一直线。那么此时应当二分到该直线的斜率，并使用斜率和 $k$ 来直接求出 $k$ 的最优值。\nCode // Code by ajcxsu // Problem: linke kate shu #include\u0026lt;bits/stdc++.h\u0026gt; #define INF (0x7fffffff) using namespace std; template\u0026lt;typename T\u0026gt; inline void gn (T \u0026amp;x) { char ch=getchar(), pl=0; x=0; while(!isdigit(ch)) pl=ch=='-', ch=getchar(); while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); x*=pl?-1:1; } template\u0026lt;typename T, typename ...Args\u0026gt; inline void gn (T \u0026amp;x, Args \u0026amp;...args) { gn(x), gn(args...); } const int N=3e5+10, M=N\u0026lt;\u0026lt;1; typedef long long ll; struct Data { ll x; int k; friend bool operator \u0026lt; (const Data \u0026amp;a, const Data \u0026amp;b) { return a.x==b.x?(a.k\u0026lt;b.k):a.x\u0026lt;b.x; } Data operator + (const Data \u0026amp;b) { return {x+b.x, k+b.k}; } } f[3][N], tmp[3]; int h[N], to[M], nexp[M], p=1; ll W[M], rw[M]; inline void ins(int a, int b, int w) { nexp[p]=h[a], h[a]=p, to[p]=b, W[p]=w, p++; } ll delta; void dfs(int x, int fr) { for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs(to[u], x); for(int i=0; i\u0026lt;3; i++) tmp[i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}; for(int i=0; i\u0026lt;3; i++) tmp[0]=max(tmp[0], f[0][x]+f[i][to[u]]); tmp[1]=max(f[0][x]+f[0][to[u]]+(Data){W[u]-delta, 1}, f[0][x]+f[1][to[u]]+(Data){W[u], 0}); for(int i=0; i\u0026lt;3; i++) tmp[1]=max(tmp[1], f[1][x]+f[i][to[u]]); tmp[2]=max(f[1][x]+f[0][to[u]]+(Data){W[u], 0}, f[1][x]+f[1][to[u]]+(Data){W[u]+delta, -1}); for(int i=0; i\u0026lt;3; i++) tmp[2]=max(tmp[2], f[2][x]+f[i][to[u]]); for(int i=0; i\u0026lt;3; i++) f[i][x]=tmp[i]; } } int n; int check(ll v) { delta=v; for(int i=1; i\u0026lt;=n; i++) f[0][i]={0, 0}, f[1][i]={-(1ll\u0026lt;\u0026lt;60), 0x3f3f3f3f}, f[2][i]={-v, 1}; dfs(1, 0); return max({f[0][1], f[1][1], f[2][1]}).k; } int main() { int k; gn(n), gn(k); k++; int u, v, w; ll l=0, r=0, mid, ans=-INF; for(int i=0; i\u0026lt;n-1; i++) gn(u, v, w), ins(u, v, w), ins(v, u, w), r+=abs(w); l=-r; memcpy(rw, W, sizeof(W)); while(l\u0026lt;=r) { mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)\u0026gt;=k) l=mid+1, ans=mid; else r=mid-1; } check(ans); printf(\u0026quot;%lld\\n\u0026quot;, max({f[0][1], f[1][1], f[2][1]}).x+ans*k); return 0; } ","oriTitle":"LP4383 林克卡特树","tags":["凸优化DP"],"title":"LP4383 林克卡特树","uri":"/posts/sol-luogu-4383/"},{"categories":["solution"],"content":"一道不错相对简单的题目。\nSolution 很大胆的想法。考虑以子树dp，然后一条链大力拉下来枚举链底部求贡献。\n那么对于每棵子树求最优的链底。\n用线段树维护。考虑点上移，链底贡献的变化量。\n重链贡献中有 $\\log$ 的存在，但我们发现每个链底及其每棵子树对重链贡献的变化次数不会超过 $\\log$ 次，因此复杂度是 $O(n\\log^2 n)$ 的。\nCode // Code by ajcxsu // Problem: new year duck #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10, OP=19; int gup[OP][N]; int h[N], to[N\u0026lt;\u0026lt;1], nexp[N\u0026lt;\u0026lt;1], p=1; inline void ins(int a, int b) { nexp[p]=h[a], h[a]=p, to[p]=b, p++; } int siz[N], dl[N], dr[N], idx; void dfs(int x, int fr) { siz[x]=1, dl[x]=++idx; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) dfs(to[u], x), siz[x]+=siz[to[u]], gup[0][to[u]]=x; dr[x]=idx; } vector\u0026lt;int\u0026gt; add[N]; #define ls x\u0026lt;\u0026lt;1 #define rs x\u0026lt;\u0026lt;1|1 ll mi[N\u0026lt;\u0026lt;2], t[N\u0026lt;\u0026lt;2]; void pud(int x) { if(!t[x]) return; ll v=t[x]; mi[ls]+=v, mi[rs]+=v, t[ls]+=v, t[rs]+=v; t[x]=0; } void updata(int x, int l, int r, int xl, int xr, ll v) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) { mi[x]+=v, t[x]+=v; return; } pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; if(xl\u0026lt;=mid) updata(ls, l, mid, xl, xr, v); if(xr\u0026gt;mid) updata(rs, mid+1, r, xl, xr, v); mi[x]=min(mi[ls], mi[rs]); } ll query(int x, int l, int r, int xl, int xr) { if(xl\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=xr) return mi[x]; pud(x); int mid=(l+r)\u0026gt;\u0026gt;1; ll ret=1ll\u0026lt;\u0026lt;60; if(xl\u0026lt;=mid) ret=min(ret, query(ls, l, mid, xl, xr)); if(xr\u0026gt;mid) ret=min(ret, query(rs, mid+1, r, xl, xr)); return ret; } ll f[N]; int n; void addv(int x) { int fa=gup[0][x]; updata(1, 1, n, dl[x], dr[x], siz[x]); for(int u=h[x];u;u=nexp[u]) if(to[u]!=fa) updata(1, 1, n, dl[to[u]], dr[to[u]], -siz[to[u]]); } void dfs2(int x, int fr) { ll tot=0; for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { dfs2(to[u], x); tot+=f[to[u]]+siz[to[u]]; } for(int u=h[x];u;u=nexp[u]) if(to[u]!=fr) { updata(1, 1, n, dl[to[u]], dr[to[u]], tot-f[to[u]]-siz[to[u]]); addv(to[u]); } updata(1, 1, n, dl[x], dl[x], tot); for(int y:add[x]) addv(y); f[x]=dl[x]==dr[x]?0:query(1, 1, n, dl[x], dr[x]); } int main() { ios::sync_with_stdio(false), cin.tie(0); int u, v; cin\u0026gt;\u0026gt;n; for(int i=0; i\u0026lt;n-1; i++) cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v, ins(u, v), ins(v, u); dfs(1, 0); for(int j=1; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) gup[j][i]=gup[j-1][gup[j-1][i]]; for(int j=0; j\u0026lt;OP; j++) for(int i=1; i\u0026lt;=n; i++) if(gup[0][gup[j][i]]) add[gup[0][gup[j][i]]].push_back(i); dfs2(1, 0); cout\u0026lt;\u0026lt;f[1]\u0026lt;\u0026lt;endl; return 0; } ","oriTitle":"UOJ462 新年的小黄鸭","tags":["线段树","树形dp"],"title":"UOJ462 新年的小黄鸭","uri":"/posts/sol-uoj-462/"},{"categories":["others"],"content":"$\\text{Hello world!}$ Here. 如果你找到这里了\u0026hellip;\n让我猜猜？\n你是看了我的github还是查了我的子域名？\nNext. 那么这里就是Inside Space。\n平常可能会在这里记录一些OI以外的内容。\n包括游戏、音乐、动画、漫画、小说、开发。\n而以上所提到的，我也在努力的进修中。\n关于Hugo和Canoe的这个主题，是受到了 margatroid 的影响。因为觉得这个很好看。所以也顺势弄了个Github Page，成就了我一向想要做里站的愿望。虽然是里站，但是还是不能放一些不可描述的H的东西呢（笑）\n以上。\nSomething left. 由于一些不可描述的技术原因，中文搜索功能暂不能使用。\n","oriTitle":"Inside Space","tags":["none"],"title":"Inside Space","uri":"/posts/my-first-post/"},{"categories":null,"content":"","oriTitle":"Archive","tags":null,"title":"Archive","uri":"/archive/"},{"categories":null,"content":"没有什么好说的。\n有人可能已经注意到了我的头像。\n主页的一个，或许还有gravatar的那一个。\n使用这两个头像的原因是因为我认为这些表情太可爱了x\n原图的话可能只有经常在p站翻奇怪东西的人才能找出来吧？\n博客标题并不是指某飞机型号\n","oriTitle":"About Me","tags":null,"title":"About Me","uri":"/about/"}]